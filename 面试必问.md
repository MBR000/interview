**面试感知的重点**

1. 因为是科班——计网
2. vue和react都能写——vue、react区别
3. vue2、vue3——vue2和3的区别，会追问细节
4. 做过的最难的事 / 优化
5. 【项目】组件
6. h5
7. 深度的东西？



**1、跟什么人在一起工作**

**2、过去项目的挑战**

**3、自学的途径**



### 做个简单的自我介绍





### 过去遇到的挑战

**性能优化**——**一个展示页面的完全重构**

这个主要包括IO方面的优化，以及渲染方面的优化

整体性能从70多秒到几百毫秒，提升了超过100倍。这个指标是devtool里面network下的time，主要针对IO。

这个页面有三个input输入框，可以输入至多三个mid。然后下面是protable的表，最右边三列分别对应三个input。然后每一行，左边几列是一些写死的条件，比如要某个tag，或者某几种tag要至少一个。行和列的交叉点，就代表符合这些条件的数据的条数。

在我做这个之前，它们写的做法是先获取tag，然后把这个mid的数据拉下来，它为了不出问题，甚至是1000条一分片，然后concat到ret数组里，同步来做的请求。一个mid有二十万条的情况下，这个的展示要花大概一分钟，优化空间巨大。

要优化这个问题，主要是我前端这边做了重构。我先从文档里换了个支持es的接口，把原先的mongo语法改成用es语法重写，提升查询效率；而且跟后端确认了一下，改成10000条分一次片。但是es分片的逻辑是比如说查9万到10万的数据，它会先查10万条，然后只给你最后的1万条，所以每一次query的时间就越来越长。

我改成一把把所有数据拿下来，并且用source只拿它的tag属性，减小开销，防止超时。这样就降到20多秒了。基本上这种拿数据回来过滤的逻辑就优化到底了，在业务上这个页面每次都是看不同的id，缓存这方面难以优化。

后续我希望只返回值，这样的话es不用拿实际的数据然后计算，那返回的效率就会更高。我用聚类，对每一行都分别用aggregations来查一次。直接用total_value查条数而不查tag，然后用promiseall保证返回数据的顺序正确。

当然，时不时还有失败的问题，我增加了重传机制。但是promiseall的重传的粒度很大，100多个有一个错就要全重传。后续改用promise.allsettled，在每一个内部增加了重传机制。这样重传的粒度就到了每一个query，重传开销明显减小了

另外，由于这样要并发一百多条，其实也不美观，而且有限制。所以我又想到让后端给我个接口，我把这些查询打成一个数组给他，然后他分发，再合拢给我。所以这就是IO上面的一些优化



下一步，传出来以后的render机制，目前是每一个mid拿完了都让protable触发reload渲染一次，这样就算你只提交了一个mid，另两个空的，也要重排三次，性能损耗很大。目前改成三个更新完了再触发reload钩子，就减少了两次重排。

最后对渲染也优化，把第一次初始化的数据处理放在mount阶段，就没有protable表的闪动，也是对性能以及用户体验都有提升





**最拿得出手的封装组件**——

一个图表展示的组件。输入是一个从数据库里query下来的数组，数组的每一个item代表一次评测的数据，包括总的得分，以及一些指标的数据，下面还有个detail，里面是各个小项的得分。我就需要把这些数据可视化展示出来，用的是antv echarts的line组件，做成折线图。并且用了tab标签页，减少它的空间占用，交互上更友好。

它的一个特点在于传进去的值是一个数组，并且每一个点对应一个评测

这个组件拿出来做成组件放到component里面，是因为要考虑它复用的程度，以及跟父组件的耦合度。



父子组件通信

【props+v-bind / state+setstate】【emit】【vuex/pinia/redux/Mobx】【eventbus】【ref+冒泡】



**组件调用**——一号儿子调用二号儿子的儿子。在父亲声明一个ref，然后把二号儿子弄成forwardRef的，在二号里面又声明一个ref，然后把这个ref绑给孙子，并且在二号儿子里面useimperativeHandle一个函数，然后父亲就把这个ref下的函数传给一号儿子，就实现了调用。这个还是比较复杂的

**防呆防错**——比如有一个页面，如果一刷新就点击button，就会报错。后来看，是因为太快，一个组件的数据还没有传入，但是他后续就用了这个数据处理，导致报错。我就给组件都加了个判空，如果传进来的props为null，就直接返回一个空的JSX，就解决了问题。

### 你学了多久前端

我从接触三件套以来，一直断断续续地学。直到大二确定前端作为就业方向后，才系统性地开始学，包括接触框架、学习js深层的原理、前后端全栈开发等等。大概成体系地写一些项目、进公司实习也就一年多一点的时间。我觉得还是成长很快

### 为什么要干前端

1.我觉得前端可以看到图形化界面，有一种美的感受。我之前也写python，做数据分析像是打kaggle什么的，但其中最吸引我的还是可视化的部分。我觉得前端工作让我能感受到两种美，包括界面、视觉上的美；以及代码、效率上的美。我可以同时得到这两者，并且可以用自己的努力提升这两种美，这种多重的美的感受，非常吸引我。

2.大学期间对它的接触多，形成了正向反馈，做出一个个demo、实现一个个功能，还是很有成就感。

3.并且做项目做着做着，从前端工作中，收获了价值感。因为我理解前端从本质来说，是一种数据和界面的桥梁，它精妙地站在现实世界和代码世界的中间，沟通着这两个世界。你可以让他人直观地感受到你的工作，向他们展示需要的信息，便利它们的方方面面的操作。

比如我在公司里面做的是2B的系统，都是同事在用，可能大家都是算法的同事，但是依然需要我的平台来开展操作，看到信息。如果前端页面出了问题，很多的工作都无法开展。并且如果平台出了问题，别人都一筹莫展，只能让我来解决。我意识到所有的工作都是不可或缺的，没有优劣之分。我能通过其它人的使用和肯定，认识自己工作的价值，这也支持着我继续做下去。

### 你平时是怎么学习的

1.实战中遇到问题，带着问题搜索学习

比如我在实习过程中，在开发中会有很多的新需求，做的过程中就会碰到一些不会的东西。

在遇到这些场景后，我会去搜索解决方案。尤其是我每天都是外网环境、英文资料丰富，对于用Google搜索英文文档、用Stack overflow、看github issue，非常方便，也养成了这种好习惯去接触高质量的学习材料。

其中我最喜欢的是在github上找相关的issue有没有写一些用法，因为很多的开源社区的生态还是很好，有很丰富的沉淀，包括写开源库的dalao会亲自回答你。然后我学到以后会及时反馈，用这些东西马上就写，就能很及时地提升自己【举个例子】

2.我也会系统性看书，看文档，学习一些大块的知识。学vue的时候就看它的文档，列出大纲，抓住一个脉络整体性学习。看书这边【举例】

3.我也会经常看论坛，因为它们很多帖子都很有趣，涉及一些不会的、或者冷门的知识，对我扩展视野还是很有帮助，知道一些平常忽略的细节。【举例】



具体而言

实战中学习——我要给protable实现一个分页查询，就去pro components的repo，看issue包括自己提问，找到他自己提供的解决方案，就知道怎么获取一些用于我的api查询，然后返回的数据又怎么放到组件里，展示出我要的效果。以及它protable在blur以后默认刷新的问题，就看issue很多人提，才知道要手动关闭一个属性。

看书——比如红宝书，我可以分享它讲数据类型，基础数据类型就有【】，这还是拓展了我的视野，比如一些不怎么使用的数据类型，比如不同类型之间它的一种隐式转换。我觉得他就是比较全面地给你展示一个模块的知识，就像是工具书一样，它在正确性和完整性上都很好。很多别的地方不怎么提的点，书里面就会提出来，对我也是很大的提升

比如《JS权威指南》，就给了几张表，比较详细的讲了一些转换规则

看论坛——比如之前HTTP3的时候，我就在里面初涉了一下HTTP3、QUIC。我理解了它是要解决TCP、TLS握手的问题，提供基于UDP的方案。他也有一些问题，比如首包的安全性、会被服务商误认为是攻击等等。同时，对于一些我感兴趣的，我还会去更多的地方查询，不论是MDN、或者google，都可以了解更深入、更正确、更全面的信息



### 看过什么书

1.《JavaScript高级程序设计》红宝书

2.《JavaScript权威指南》犀牛书

3.《CSS解密》

深入浅出React







### 你觉得你的优势/不足有什么

优势我提两点，

第一，我是科班的学生，对于计网之类的课内知识，有先天的优势，并且前端工作也是建立在计算机基础之上的，工作中很多地方会运用课内知识。所以我的迁移运用能力更强，工作效率更高，整个成长曲线也更稳固。

第二点我说热爱。学校其实不上前端的课，我因为热爱，在实习、项目中自学了包括js语言、各种框架等等的知识，已经有一定的前端基础。并且我觉得这方面的工作很有趣，所以我愿意投入时间，在很多地方积极主动提升自己的水平，成长性和可塑性更大，更有活力。

不足在于我的技术面比较窄，很多概念，很多新兴技术，有一些都是只了解概念，没有实际遇上，就没怎么学，没有真正深入去做它。包括对于一些源码层面上的、底层的知识，还是有很大提升空间。



### 你对自己的职业规划

两个方面吧

一是技术实力的提升：我希望通过几年的工作沉淀，包括自己自学，能在技术上取得很大的进步，包括在业务上，还是在底层的机理上，都能好好学一学，更加深入一些，从源码的层次理解前端的整个的运行逻辑。并且我能用这样的技术水平做出更大的贡献，为公司创造价值，以及培养帮助更多的新人。

二是自我价值的提升：我希望在公司中能逐渐发挥更大的作用，不论是开发业务，为公司创造经济价值；还是帮助同事，营造工作的和谐气氛，这都是我希望做的。另外，因为我用了很多开源的框架，所以我希望能把自己的技术更好地回馈社区，能在更多的地方奉献自己的代码，实现作为程序员的价值。

### 你还有什么想要问我的么

我们团队是做什么的，我来了负责什么工作

**我在这个岗位会直接接触到哪些项目** 

我们是ToB还是ToC，是中台还是业务

我们团队的规模是什么样的

我们团队的技术栈是什么

**我是个校招生，想了解新人加入后能有一个怎样的成长曲线？公司、团队为我们的成长会提供什么帮助**



我接触了一些开源组织，对这方面有点兴趣。我想问公司、包括团队，在开源方面的开源文化怎么样





### react和vue区别

- 数据变化的实现原理不同。`react`使用的是不可变数据，而`Vue`使用的是可变的数据
- 响应式原理不同。`react`是你要手动更新触发，并且从root往下全部更新DOM，当然它通过很多的手段进行了优化。`Vue` 的数据是可变的，是在原地更新数据。之后它通过监听数据变化，使用diff算法，双向指针，边对比，边更新DOM，更新的粒度比react细
- 组件化通信的不同。`react`中我们通过使用回调函数来进行通信的，而`Vue`中子组件向父组件传递消息有两种方式：事件和回调函数
- 写法不同，react的尤其是function编程，它整体就是一个函数，然后把jsx return出去，整体上做到的就是把ui当成一种js元素，想把我们向写纯js方向引导。React推崇函数式编程。函数式编程最大的好处是其稳定性（无副作用）和可测试性（输入相同，输出一定相同），所以通常大家说的React适合大型应用，根本原因还是在于其函数式编程。

### vue2和vue3区别

**更小**

① 引入`tree-shaking`

基于`ES6`模板语法（`import`与`exports`），主要是借助`ES6`模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量

**更快**

② 性能提升主要体现在编译方面：

- diff算法优化

  `vue3`在`diff`算法中相比`vue2`增加了静态标记

  关于这个静态标记，其作用是为了会发生变化的地方添加一个`flag`标记，下次发生变化的时候直接找该地方进行比较

- 静态提升

  `Vue3`中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用

  这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用


③ 数据劫持优化

> 在`vue2`中，数据劫持是通过`Object.defineProperty`，这个 API只能遍历对象属性进行劫持，有一些缺陷

- 不能检测对象属性的添加和删除
- 在面对嵌套层级比较深的情况下，就存在性能问题

> `vue3`是通过 `Proxy` 劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的

同时`Proxy` 并不能监听到内部深层次的对象变化，而 `Vue3` 的处理方式是在`getter` 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归

**更友好**

④ 推出了`composition API`

⑤ `VUE3`是基于`typescipt`编写的，可以享受到自动的类型定义提示。提供了更好的类型检查，能支持复杂的类型推导

⑥ 组件现在支持有多个根节点

### 你有什么深度的理解跟我说吗

如果你说广度的话，我还是会很多，比如nodejs开发后端、mongo的数据库等等

深度上面的话，说QUIC

说canvas



### 看过什么源码

【vue diff源码】【vue3源码】

vue2采用了**双端diff算法**。核心方法是**updateChildren**,通过***新前与旧前*、*新后与旧后*、*新后与旧前*、*新前与旧后*、*暴力比对***5种查找。
 新前：newChildren中所有未处理的第一个节点
 新后：newChildren中所有未处理的最后一个节点
 旧前：oldChildren中所有未处理的第一个节点
 旧后：oldChildren中所有未处理的最后一个节点

vue3 使用了**快速diff算法**，核心方法是`patchKeyedChildren`,首先是借鉴了纯文本diff算法中的预处理思路,**处理新旧两个组子节点中相同的前置节点和后置节点**。处理完后，如果剩余节点无法**简单的通过挂载新节点或者卸载已经不存在的节点**来完成更新，则需要根据节点的索引关系，构建出一个**最长递增子序列**。最长递增子序列所指向的节点即为不需要移动的节点。



我看过react的fiber

看过antd的protable组件

