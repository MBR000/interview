前端学习冲冲

目录

- HTML（HTML5.3）
- CSS（模块）
- JS（ES6）
- VUE
- React
- 手写算法、实现
- **计算机网络**
- **操作系统**
- **浏览器**
- 构建工具和工程化
- 后端
- 进阶技能



# 计算机网络

## 分层

### OSI七层

|OSI中的层| 功能| TCP/IP协议族|
|---|---|---|
|应用层 |文件传输，电子邮件，文件服务，虚拟终端 |TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet|
|表示层| 数据格式化，代码转换，数据加密|  |
|会话层| 解除或建立与别的接点的联系 ||
|传输层| 提供端对端的接口 |TCP，UDP|
|网络层 |为数据包选择路由| IP，ICMP，RIP，OSPF，BGP，IGMP|
|数据链路层| 传输有地址的帧以及错误检测功能| SLIP，CSLIP，PPP，ARP，RARP，MTU|
|物理层| 以二进制数据形式在物理媒体上传输数据| ISO2110，IEEE802，IEEE802.2|

1、同一层中的各网络节点都有相同的层次结构，具有同样的功能。

2、同一节点内相邻层之间通过接口(可以是逻辑接口)进行通信。

3、七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。

4、不同节点的同等层按照协议实现对等层之间的通信。



第一层：物理层(PhysicalLayer)，

规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。在这一层，数据的单位称为比特(bit)。

第二层：数据链路层(DataLinkLayer):

在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧(frame)。

第三层是网络层

网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如 果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议(ARP)。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包(packet)。

第 四层是处理信息的传输层

第4层的数据单元也称作数据包(packets)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 (segments)而UDP协议的数据单元称为“数据报(datagrams)”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端(最终用户到最终用户)的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。

第五层是会话层

这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。

第六层是表示层

这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。

第七层应用层

应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。

### TCP/IP五层

应用层

传输层：四层交换机、也有工作在四层的路由器

网络层：路由器、三层交换机

数据链路层：网桥(现已很少使用)、以太网交换机(二层交换机)、网卡(其实网卡是一半工作在物理层、一半工作在数据链路层)

物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层



## HTTP

### HTTP

#### 组成

HTTP请求报文由3部分组成（**请求行**【请求方法+请求URL+HTTP版本及协议】+**请求头**+请求体）

HTTP的响应报文也由三部分组成（**响应行**【报文协议及版本+状态码】+响应头+响应体）

#### 特点

- 支持客户/服务器模式
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
- 灵活：HTTP允许传输任意类型的数据对象。**正在传输的类型由Content-Type加以标记**
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- **无状态：HTTP协议无法根据之前的状态进行本次的请求处理**

无状态

无状态是指的，无登录状态，即服务器不知道某个用户是否已登录过了。因为愚蠢的服务器不知道客户端是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在/login接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在服务端也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好。

**缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另外人们常说的“会话”概念则是上面的交互行为的另一种表述方式。**



#### 请求方法method

##### 一览

- GET 请求一个指定资源的表示形式. 使用 GET 的请求应该只被用于获取数据
- POST 用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用
- PUT 用请求有效载荷替换目标资源的所有当前表示
- DELETE 删除指定的资源
- HEAD 请求一个与 GET 请求的响应相同的响应，但没有响应体
- CONNECT 建立一个到由目标资源标识的服务器的隧道。
- OPTIONS 用于描述目标资源的通信选项。
- TRACE 沿着到目标资源的路径执行一个消息环回测试。
- PATCH 用于对资源应用部分修改。

不修改服务器数据的方法叫安全的。

同样的请求多次执行的效果是一致的、服务器效果是一致的，就叫做幂等

##### get和post区别

- `POST`比`GET` 安全，因为数据在地址栏上不可见

  然而，从传输的角度来说，他们都是不安全的，因为`HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。只有使用`HTTPS`才能加密安全

- post比get慢

  对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应200（返回数据）
  
  对于`POST`，浏览器先发送`header`，服务器响应100 `continue`，浏览器再发送`data`，服务器响应200 ok
  
- post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作。所以GET具有幂等性和安全性，POST不符合

**对options的理解**

**在跨域的情况下，在浏览器发起"复杂请求"时，要主动发起options**。

跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器**必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求**。服务器确认允许之后，才发起实际的 HTTP 请求。

当我们发起跨域请求时，如果是简单请求，那么我们只会发出一次请求，但是如果是复杂请求则先发出 options 请求，用于确认目标资源是否支持跨域，然后浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。

由此可见，当触发预检时，跨域请求便会发送 2 次请求（不是2个options，只有第一个是option），既增加了请求数，也延迟了请求真正发起的时间，严重影响性能。

优化 Options 请求主要有 2 种方法。

1. 转为跨域请求或者简单请求
2. 对 options 请求进行缓存，服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）

> 官方将头部带自定义信息的请求方式称为**带预检（preflighted）**的跨域请求。在实际调用接口之前，会首先发出一个options请求，**检测服务端是否支持真实的请求进行跨域的请求**。真实请求在options请求中，通过request-header将 Access-Control-Request-Headers与Access-Control-Request-Method发送给后台，另外浏览器会自行加上一个Origin请求地址。服务端在接收到预检请求后，根据资源权限配置，在response-header头部加入access-control-allow-headers（允许跨域请求的请求头）、access-control-allow-methods（允许跨域请求的请求方式）、access-control-allow-origin（允许跨域请求的域）。另外，服务端还可以通过Access-Control-Max-Age来设置一定时间内无须再进行预检请求，直接用之前的预检请求的协商结果即可。**浏览器再根据服务端返回的信息，进行决定是否再进行真实的跨域请求**。这个过程对于用户来说，也是透明的。



#### 请求头

**1.Accept**

- **Accept: text/html** 浏览器可以接受服务器回发的类型为 text/html。
- **Accept: \*/\***  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。

2.Accept-Encoding

- **Accept-Encoding: gzip, deflate** 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。

3.Accept-Language

- **Accept-Language:zh-CN,zh;q=0.9** 浏览器申明自己接收的语言。

4.Connection

- **Connection: keep-alive** 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的**TCP连接不会关闭**，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
-  **Connection: close** 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

**5.Host（发送请求时，该报头域是必需的）**

- **Host:www.baidu.com** 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。

6.Referer

- **Referer:https://www.baidu.com/?tn=62095104_8_oem_dg** 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

7.User-Agent

- **User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36** 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

8.Cache-Control

- Cache-Control:private 默认为private 响应只能够作为私有的缓存，不能再用户间共享
- Cache-Control:public 响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
- Cache-Control:must-revalidate 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
- Cache-Control:no-cache 响应不会被缓存,而是实时向服务器端请求资源。
- **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
- **`Cache-Control:no-store `**在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

9.Cookie

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

10.Range（用于断点续传）

- **Range:bytes=0-5** 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。



#### 状态码

状态码第一位数字决定了不同的响应状态，有如下：

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误


下面给出一些常见状态码：

- 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输

- 200：客户端请求成功

- 206：一般用来做断点续传，或者是视频文件等大文件的加载

- 301：永久重定向。新域名替换旧域名，旧的域名不再使用

- 302：临时重定向

  > 有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。
  >
  > 也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。
  >
  > 我的理解是，从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了。
  >
  > 301跳转对查找引擎是一种对照驯良的跳转编制，也是查找引擎能够遭遇的跳转编制，它告诉查找引擎，这个地址弃用了，永远转向一个新地址，可以转移新域名的权重。而302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”。

- **304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分**

- 400：参数有误，请求无法被服务器识别

- **403：告诉客户端禁止访问该站点或者资源**，如在外网环境下，然后访问只有内网IP才能访问的时候则返回

- 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时

- **503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503**

- 504：网关超时

#### 响应头

1.Cache-Control（对应请求中的Cache-Control）

- **Cache-Control:private** 默认为private  响应只能够作为私有的缓存，不能再用户间共享
- Cache-Control:public 浏览器和缓存服务器都可以缓存页面信息。
- **Cache-Control:must-revalidate**  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
- **Cache-Control:no-cache**  浏览器和缓存服务器都不应该缓存页面信息。
- **Cache-Control:max-age=10** 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。
- **Cache-Control:no-store** 请求和响应的信息都不应该被存储在对方的磁盘系统中。

2.Content-Type

- **Content-Type：text/html;charset=UTF-8** 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

3.Content-Encoding

- **Content-Encoding:gzip** 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

4.Date

- **Date: Tue, 03 Apr 2018 03:52:28 GMT** 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

5.Server

- **Server：Tengine/1.4.6** 这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**

6.Transfer-Encoding

- **Transfer-Encoding：chunked** 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

7.Expires

- **Expires:Sun, 1 Jan 2000 01:00:00 GMT** 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

8.Last-Modified

- **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT** 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

9.Connection

- **Connection：keep-alive** 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

**10.Etag**

- **ETag: "737060cd8c284d8af7ad3082f209582d"** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

11.Refresh

- **Refresh: 5; url=http://baidu.com** 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。

**12.Access-Control-Allow-Origin** 

- **Access-Control-Allow-Origin: \***  *号代表所有网站可以跨域资源共享，如果当前字段为*那么Access-Control-Allow-Credentials就不能为true
- **Access-Control-Allow-Origin: www.baidu.com** 指定哪些网站可以跨域资源共享

13.Access-Control-Allow-Methods

- **Access-Control-Allow-Methods：GET,POST,PUT,DELETE** 允许哪些方法来访问

14.Access-Control-Allow-Credentials

- **Access-Control-Allow-Credentials: true** 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true

**15.Content-Range**

- **Content-Range: bytes 0-5/7877** 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。



#### 请求头+响应头

通过配合请求头和响应头，可以满足一些场景的功能实现：

##### **协商缓存**

**利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的**

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

##### 会话状态

`cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定

作为一段一般**不超过 4KB** 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `Cookie`有效期、安全性、使用范围的可选属性组成

`Cookie` 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等



### HTTP版本

#### HTTP1.0

`HTTP`协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本

`HTTP 1.0` 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个`TCP`连接。服务器完成请求处理后立即断开`TCP`连接，服务器不跟踪每个客户也不记录过去的请求

简单来讲，**每次与服务器交互，都需要新开一个连接**。最终导致，一个`html`文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接

> 服务器给浏览器推送的第一个页面，页面里通常嵌入了图片资源文本链接、以及动态页面资源链接、或第三方网站的链接资源，还需要浏览器根据这些文本链接内容，去链接所对应的服务器，继续下载链接所对应的内容。 浏览器通常采用的流程是，重新建立一个TCP连接、TLS连接、HTTP交易。 这又是一个漫长的4RTT等待过程，用户看到浏览器完整页面的时间为 完整页面加载时间 = 4RTT * 2 = 8RTT

#### HTTP1.1

在`HTTP1.1`中，**默认支持长连接**（`Connection: keep-alive`），即在一个TCP连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟

建立一次连接，多次请求均由这个连接完成

同时，`HTTP 1.1`还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间

同时，`HTTP1.1`在`HTTP1.0`的基础上，有完善的功能

- **引入了更多的缓存控制策略**，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略
- 引入range，允许值请求资源某个部分
- 引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点
- 添加了**其他的请求方法**：`put`、`delete`、`options`

#### HTTP2.0

长连接 `Connection: keep-alive` 带来了新的问题

> 多个HTTP流使用同一个TCP连接，遵守同一个流量状态控制。只要第一个HTTP流遭遇到拥塞，剩下的HTTP流压根没法发出去，这就是头部阻塞（Head of line Blocking）。

而`HTTP2.0`添加了特性：

- **多路复用**

  复用`TCP`连接，在一个连接里，客户端和浏览器都可以**同时发送多个请求或回应**，而且不用按照顺序一一对应，这样就避免了”队头堵塞”（其实只在应用层解决了这个问题，TCP上的队头阻塞没有解决）

- **二进制分帧**

  采用二进制格式传输数据，而非 `HTTP 1.x`的文本格式，解析起来更高效

  **将请求和响应数据分割为更小的帧，并且它们采用二进制编码**

  `HTTP2`中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流

  每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件

- **首部压缩**

  在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

- **服务器推送**

  允许服务端推送资源给客户端

  服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源

  免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源



#### HTTP3

**HTTP2留下了一些问题：**

- [队头阻塞](https://www.zhihu.com/search?q=队头阻塞&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1802535193})；

  > 当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。

- TCP 与 TLS 的握手时延迟；

- 网络迁移需要重新连接

  > 一个 TCP 连接是由四元组]（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。

**HTTP3 于 2022年6月6日成为标准**。形成了 IP / UDP / QUIC / HTTP 的创新架构

> Google开发QUIC协议，QUIC协议集成了TCP可靠传输机制、TLS安全加密、HTTP /2 流量复用技术。 **QUIC 协议**具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。
>
> 此外，完成QUIC交易的连接的Session ID会缓存在浏览器内存里，如果用户再次打开该页面，无需建立TLS连接，直接使用缓存Session ID 对应的加密参数，服务器可以根据Session ID在缓存里查找对应的加密参数，并完成加密。 换句话说，重连TLS连接是一个0 RTT 事件，用户所要等待的页面加载时间 = HTTP交易时间 = 1 RTT。
>
> 之后把 QUIC 和 HTTP 分离

IETF的QUIC标准集成了TLS 1.3版本，1.3版本更简练，建立TLS连接不再需要1.5 RTT，而只需要1 RTT，是因为浏览器第一次就把自己的密钥交换的素材发给服务器，这样就节省了第三次消息，少了0.5个RTT时间。 （但是牺牲了首包的完全前向安全性）

页面的整体加载时间 = TLS 1.3连接时间 + HTTP交易时间 = 1RTT + 1RTT = 2 RTT 

重连页面的加载时间 = HTTP交易时间 = 1 RTT 



**问题**

首先是因为这些年性能的优化提升都针对 TCP ，使得 UDP 性能没有任何改进。当然随着 QUIC 的发布，相信后续应该会有相对的投入。

其次是安全问题，也就是反射攻击，即伪造原地址。这个指发送数据包时的原地址是伪造的，不是真正的地址，会引起放大攻击。

- 原因是 QUIC 握手过程是不对称的，特别是第一次请求时，[客户端](https://www.zhihu.com/search?q=客户端&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1763708333})只需要发送几个字节的信息到服务器，而服务器则需要把证书等很多东西返还给客户端，这不对称的机会造成了放大。
- 草案 27 定义了两个规则和机制来限制[反射攻击](https://www.zhihu.com/search?q=反射攻击&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1763708333})：客户端发送Initial包，即第一个数据包时，其长度必须在 1200 bytes以上，不足部分用 Padding 帧填充，同时，当服务端不确定客户端可靠性时，可以发送 Retry 包要求客户端再次提供验证信息。

**优点**

- HTTP/3 使用 [stream](https://www.zhihu.com/search?q=stream&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1763708333}) 进一步扩展了 HTTP/2 的[多路复用](https://www.zhihu.com/search?q=多路复用&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1763708333})。在 HTTP/3 模式下，一般传输多少个文件就会产生对应数量的 stream。当这些文件中的其中一个发生丢包时，你只需要重传丢包文件的对应 stream 即可。

- HTTP/3 不再是基于 TCP 建立的，而是通过 UDP 建立，在用户空间保证传输的可靠性，相比 TCP，UDP 之上的 QUIC 协议提高了连接建立的速度，降低了延迟。

- 通过引入 Connection ID，使得 HTTP/3 支持连接迁移以及 NAT 的重绑定。

- HTTP/3 含有一个包括验证、加密、数据及负载的 built-in 的TLS安全机制。

- 拥塞控制。TCP 是在[内核区](https://www.zhihu.com/search?q=内核区&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1763708333})实现的，而 HTTP/3 将拥塞控制移出了内核，通过用户空间来实现。这样做的好处就是不再需要等待内核更新可以实现很方便的进行快速迭代。

- 头部压缩。HTTP/2 使用的 HPACK，HTTP/3 更换成了兼容 HPACK 的 QPACK 压缩方案。QPACK 优化了对乱序发送的支持，也优化了压缩率。

### HTTPS

#### 从HTTP开始的修改

HTTP 的缺点如下：

1. 通信使用明文，传输内容可能被窃听
2. 不验证后通信方的身份，容易伪装进行请求
3. 无法保证报文的完整性，可能遭遇篡改

为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 HTTPS = HTTP + SSL/TLS，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

`SSL` 协议位于`TCP` 协议与各种应用层协议（如HTTP）之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

#### 建立SSL连接的过程

- 首先客户端通过URL访问服务器建立SSL连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给服务器
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

#### 区别

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了**加密处理**，相对更安全
- **HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443**
- HTTPS 由于需要设计加密以及多次握手，**性能方面不如 HTTP**。HTTPS除了 TCP 的三个包，还要加上 ssl 握手的包，花费更多

  > HTTPS通信时间总和 = TCP连接时间 + TLS 连接时间 + HTTP交易时间 = 1.5 RTT + 1.5 RTT + 1 RTT = 4 RTT
- HTTPS需要SSL，https协议需要到CA申请证书，一般免费证书很少，**需要交费**

#### 加密方法一览

类型：

- 对称加密：采用协商的密钥对数据加密
- 非对称加密：实现身份认证和密钥协商
- 摘要算法：验证信息的完整性
- 数字签名：身份验证

**对称加密**

对称加密指的是**加密和解密使用的秘钥都是同一个**，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性

**非对称加密**

非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密

公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密

> 如果采用对称加密，**秘钥有可能在开始阶段由主动方发出时被黑客截获，后面任何加密信息将失去保密效果** ，而如果采用非对称加密，那么黑客即使截获了公钥，也没有任何作用，因为只有掌握在通讯双方手中的私钥才是揭开密文的唯一“钥匙

**摘要算法**

实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数。可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”

**摘要算法保证了“数字摘要”和原文是完全等价的**。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性

**数字签名**

数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名

原理其实很简单，就是用私钥加密，公钥解密

签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的



#### HTTPS的加密

Https采用混合加密机制（**对称加密** + **非对称加密**），如果密钥能够保证安全交换，那么全程有可能仅使用对称密钥加密来进行通信，如果不能保证密钥安全交换，可在密钥交换环节使用非对称加密方式，**之后使用对称加密方式**。这样做的目的是因为对称密钥加密相较非对称秘钥加密处理速度更快。

HTTPS 加密传输过程中需要传输公开密钥，那么公开密钥又是如何保证其正确性呢，当然是数字认证机构颁发的公开密钥证书。

上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决。因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是**摘要算法**





### 地址栏输入 URL 敲下回车后发生了什么

简单的分析，从输入 `URL`到回车后发生的行为如下：

URL解析——DNS 查询——TCP 连接——HTTP 请求——响应请求——页面渲染

#### URL解析

首先判断你输入的是一个合法的`URL` 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作

#### DNS查询

一级级查询DNS服务器，获得需要的ip

#### TCP连接

在确定目标服务器服务器的`IP`地址后，则经历三次握手建立`TCP`连接

#### http 请求

当建立`tcp`连接之后，就可以在这基础上进行通信，浏览器发送 `http` 请求到目标服务器

请求的内容包括：【请求行、请求头、请求主体】

当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个`HTTP`响应消息，包括：【状态行、响应头、响应正文】

在服务器响应之后，由于现在`http`默认开始长连接`keep-alive`，当页面关闭之后，`tcp`链接则会经过四次挥手完成断开

#### 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析：

- 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等
- **查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式**



## TCP、UDP

### TCP

TCP（Transmission Control Protocol），传输控制协议，是一种可靠、**面向字节流的通信协议**，把上面应用层交下来的数据看成无结构的字节流来发送

可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小

`TCP`报文首部有20个字节，额外开销大

#### 单工双工

单工：指数据传输只支持数据在一个方向上传输

> 优点：
>
> 可以利用通信信道的整个带宽，所以一次性可以传输更多的数据。

> 缺点：
>
> 通信是单向的，设备之间没有相互通信，效率低。

双工：指二台通讯设备之间，允许有双向的资料传输。通常有两种双工模式。一种叫半双工，另一种叫全双工

全双工（full-duplex）的系统允许二台设备间同时进行双向数据传输。一般的电话、手机就是全双工的系统，因为在讲话时同时也可以听到对方的声音。

> 优点
>
> 通信双方可以同时发送和接收数据，效率很高。

> 缺点：
>
> 假如设备之间不存在专用路径，那么信道容量就会减少一半。

半双工（half-duplex）的系统允许二台设备之间的双向数据传输，但不能同时进行。因此同一时间只允许一设备传送资料，若另一设备要传送资料，需等原来传送资料的设备传送完成后再处理。

>优点：
>
>半双工在同一时刻也是占用整条带宽，所以每次也能传输很多数据。

> 缺点：
>
> 半双工由于在通信的时候，通信一方在传输数据，另一方只能等待接收数据，存在一点时延。

### UDP

UDP（User Datagram Protocol），用户数据包协议，是一个简单的**面向数据报的通信协议**，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层

也就是说无论应用层交给`UDP`多长的报文，它统统发送，一次发送一个报文

而对接收方，接到后直接去除首部，交给上面的应用层就完成任务

`UDP`报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小

特点：

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
- **传输途中出现丢包，UDP 也不负责重发**
- **当包的到达顺序出现乱序时，UDP没有纠正的功能。**
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

### 区别

|          | TCP                              | UDP                            |
| -------- | -------------------------------- | ------------------------------ |
| 可靠性   | 可靠                             | 不可靠                         |
| 连接性   | 面向连接                         | 无连接                         |
| 报文     | 面向字节流                       | 面向报文                       |
| 效率     | 传输效率低                       | 传输效率高                     |
| 双共性   | 全双工                           | 一对一、一对多、多对一、多对多 |
| 流量控制 | 滑动窗口                         | 无                             |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复 | 无                             |
| 传输效率 | 慢                               | 快                             |

- TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手
  UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取
- TCP 提供可靠的服务，**传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。**
  UDP 则尽可能传递数据，但不保证传递交付给对方
- TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。
  UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
- TCP 只能点对点全双工通信。
  UDP 支持一对一、一对多、多对一和多对多的交互通信

### TCP三次握手

过程如下：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

每一次握手的作用如下：

- 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了

> ISN是动态生成的：三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号
>
> 半连接队列：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
>
> 三次握手过程中可以携带数据吗：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

### TCP四次挥手

过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态

> 四次挥手释放连接时，等待2MSL的意义——保证客户端发送的最后一个ACK报文段能够到达服务端；防止本次链接的相关信息出现在下个连接中。

### TCP/IP

#### 定义

TCP/IP，**传输控制协议**/**网际协议**，是指能够在多个不同网络间实现信息传输的协议簇

- TCP（传输控制协议）

一种面向连接的、可靠的、基于字节流的传输层通信协议

- IP（网际协议）

用于封包交换数据网络的协议

TCP/IP协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇，只是因为在`TCP/IP`协议中`TCP`协议和`IP`协议最具代表性，所以通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols）

#### 分层

TCP/IP协议族按层次分别了五层体系或者四层体系。五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括**应用层、传输层、网络层、数据链路层和物理层**

**应用层**

`TCP/IP` 模型将 `OSI`参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务

如：`FTP`、`Telnet`、`DNS`、`SMTP` 等

**传输层**

该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能

传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）

其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输

**网络层**

负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机

在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送

**数据链路层**

数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧

**物理层**

保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境



## CDN

### 概念

CDN (全称 Content Delivery Network)，即内容分发网络

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是根据用户位置分配最近的资源

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。

### 原理

在没有应用`CDN`时，我们使用域名访问某一个站点时的路径为

> 用户提交域名→浏览器对域名进行解释→`DNS` 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

`CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键

### 使用

**负载均衡**

由于没有返回`IP`地址，于是本地`DNS`会向负载均衡系统再发送请求 ，则进入到`CDN`的全局负载均衡系统进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
- 看用户所在的运营商网络，找相同网络的边缘节点
- 检查边缘节点的负载情况，找负载较轻的节点
- 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的缓存代理

> 用户发送域名给DNS→DNS转给CDN专用DNS解析→返回IP给浏览器→浏览器访问CDN服务器

**缓存代理**

缓存系统是 `CDN`的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源。其中有两个衡量`CDN`服务质量的指标：

- 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
- 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户。回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源

现在的商业 `CDN`命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上

## 跨域

URL包括协议、域名、端口（浏览器默认80端口号省略）

同源（orgin）指的是**端口号、协议、域名相同**。scheme hostname port 三部分任意不同就是跨域

不是同源情况下，也就是不同端口、不同域名、不同协议的数据交互会产生跨域。

> 可以看F12里面的header，里面很多信息可以仔细分析

### 跨域后的限制

1、本地储存，比如**Cookie、LocalStorage、SessionStorage都是保存到浏览器端的，而且是同源的，所以这些都不能访问到**

2、无法获取资源（CSS、JS、HTML中的DOM）

3、无法进行数据交互Ajax

### **解决思路**

跨域的解决思路 1 —— 不使用XHR

> 不要发出 XHR 请求，这样就算是跨域，浏览器也不会有非同源限制，解决方案是 JSONP，通过动态创建一个 script，通过 script 发出请求

跨域的解决思路 2 —— 调用时声明支持跨域

> 根据 W3C 的跨源资源共享方案，在被调用方修改代码，加上字段，告诉浏览器该网站支持跨域

跨域的解决思路 3 —— 用不跨域的代理地址获取

> 使用 Nginx 反向代理，在 a 域名里面的的请求地址使用反向代理指向 b 域名，让浏览器以为一直在访问 a 网站，不触发跨域限制

### JSNOP

- 普通请求值 XHR，希望得到服务端返回的 content-type 一般是 json
- JSONP 发出的是 script 请求，希望得到的返回是 js 脚本

#### **JSONP 原理**

以 JQuery 为例，发送 ajax 请求的时候，设置`dataType:"jsonp"`，将使用 JSONP 方式调用函数，函数的 url 变为`myurl?callback=e5bbttt`的形式，e5bbttt 就是一个临时方法名，后端会根据`callback`的值返回一个 js 脚本，如

```html
<script>
    e5bbttt({"a":"aaa","b":"bbb"});
</script>
```

JQuery 会提前根据 ajax 中 success 的内容生成一个临时函数，名字就是 xxx

```javascript
$.ajax({
    // 其他省略
    dataType:"jsonp",
    success:function(data){
        console.log(data.a);
        console.log(data.b);
    },
    jsonp:"e5bbttt"
})

// JQuery 生成的临时函数
function e5bbttt(data){
    ajaxObject.success(data);
}
```

服务端返回给客户端的`e5bbttt({"a":"aaa","b":"bbb"});`，相当于调用立即（？）调用了 JQuery 生成的`e5bbttt`函数，用完这个函数就销毁了（？）

JSONP 也算是一个约定俗成的“协议”，callback 是约定俗成的作为定义临时函数名的参数。如果想自定义这个参数名，需要在 ajax 中用 jsonp 属性定义。

#### **JSONP 的弊端**

1. 需要服务器改动代码
2. 只支持 GET 请求
3. 发送的不是 xhr 请求
4. **不安全**

### CORS

为了解决浏览器跨域问题，W3C 提出了跨源资源共享方案，即 CORS(Cross-Origin Resource Sharing)。CORS 可以在不破坏即有规则的情况下，通过后端服务器实现 CORS 接口，就可以实现跨域通信。

**本质上，只需要增加一些 `HTTP` 头，让服务器能声明允许的访问来源**

CORS 将请求分为两类：简单请求和非简单请求，分别对跨域通信提供了支持。

**简单请求**

举例：一个简单请求：

```http
GET /test HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate, sdch, br
Origin: http://www.test.com
Host: www.test.com
```

对于简单请求，CORS 的策略是请求时在请求头中增加一个 Origin 字段，表示请求发出的域。服务器收到请求后，根据该字段判断是否允许该请求访问。

- **如果允许，则在 HTTP 头信息中添加 Access-Control-Allow-Origin 字段，并返回正确的结果**
- 如果不允许，则不添加 Access-Control-Allow-Origin 字段

除了上面提到的 Access-Control-Allow-Origin，还有几个字段用于描述 CORS 返回结果

- Access-Control-Allow-Credentials：可选，用户是否可以发送、处理cookie
- Access-Control-Expose-Headers：可选，可以让用户拿到的字段。有几个字段无论是否允许跨域都可以拿到的：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma

**非简单请求**

一般是发送 JSON 格式的 ajax 请求，或带有自定义头的请求

对于非简单请求的跨源请求，**浏览器会在真实请求发出前，增加一次 OPTION 请求，称为预检请求**。预检请求将真实请求的信息，包括请求方法、自定义头字段、源信息添加到 HTTP 头信息字段中，询问服务器是否允许这样的操作

例如一个 GET 请求的预检请求，包含一个自定义参数 X-Custom-Header

```http
OPTIONS /test HTTP/1.1
Origin: http://www.test.com
Access-Control-Request-Method: GET // 请求使用的 HTTP 方法
Access-Control-Request-Headers: X-Custom-Header // 请求中包含的自定义头字段
Host: www.test.com
```

服务器收到请求时，需要分别对 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 进行验证，验证通过后，会在返回 HTTP 头信息中添加：

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://www.test.com // 允许的域
Access-Control-Allow-Methods: GET, POST, PUT, DELETE // 允许的方法
Access-Control-Allow-Headers: X-Custom-Header // 允许的自定义字段
Access-Control-Allow-Credentials: true // 是否允许用户发送、处理 cookie
Access-Control-Max-Age: 172800 // 预检请求的有效期，单位为秒。有效期内，不需要发送预检请求，ps 48小时
```

当预检请求通过后，浏览器才会发送真实请求到服务器。这样就实现了跨域资源的请求访问。

所以后端处理其实处理的就是这次预检请求

### Node 正向代理

代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。

在`webpack`中可以配置`proxy`来快速获得接口代理的能力。

```js
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  entry: {
    index: "./index.js"
  },
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist")
  },
  devServer: {
    port: 8000,
    proxy: {
      "/api": {
        target: "http://localhost:8080"
      }
    }
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: "index.html",
      template: "webpack.html"
    })
  ]
};
```

修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）

```html
<button id="getlist">获取列表</button>
<button id="login">登录</button>
<script src="https://cdn.bootcss.com/axios/0.19.2/axios.min.js"></script>
<script>
  axios.defaults.withCredentials = true;
  getlist.onclick = () => {
    axios.get("/api/corslist").then(res => {
      console.log(res.data);
    });
  };
  login.onclick = () => {
    axios.post("/api/login");
  };
</script>
```

`express`框架等等也可以，本质上就是proxy拦截

### Nginx 反向代理

Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的

配置下 hosts

```
127.0.0.1 local.test
```

配置 nginx

```text
server {
        listen 80;
        server_name local.test;
        location /api {
            proxy_pass http://localhost:8080;
        }
        location / {
            proxy_pass http://localhost:8000;
        }
}
```

启动 nginx

```
sudo nginx
```

重启 nginx

```
sudo nginx -s reload
```

前端代码

```html
<script>
  axios.defaults.withCredentials = true;
  getlist.onclick = () => {
    axios.get("/api/corslist").then(res => {
      console.log(res.data);
    });
  };
  login.onclick = () => {
    axios.post("/api/login");
  };
</script>
```

后端代码

```js
router.get("/api/corslist", async ctx => {
  ctx.body = {
    data: [{ name: "秋风的笔记" }]
  };
});

router.post("/api/login", async ctx => {
  ctx.cookies.set("token", token, {
    expires: new Date(+new Date() + 1000 * 60 * 60 * 24 * 7)
  });
  ctx.body = {
    msg: "成功",
    code: 0
  };
});
```

### Websocket

[WebSocket](https://link.zhihu.com/?target=http%3A//dev.w3.org/html5/websockets/)规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。详细教程可以看[https://www.html5rocks.com/zh/tutorials/websockets/basics/](https://link.zhihu.com/?target=https%3A//www.html5rocks.com/zh/tutorials/websockets/basics/)

这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制，没有什么过多的解释直接上代码吧。

前端部分

```html
<script>
  let socket = new WebSocket("ws://localhost:8080");
  socket.onopen = function() {
    socket.send("秋风的笔记");
  };
  socket.onmessage = function(e) {
    console.log(e.data);
  };
</script>
```

后端部分

```js
const WebSocket = require("ws");
const server = new WebSocket.Server({ port: 8080 });
server.on("connection", function(socket) {
  socket.on("message", function(data) {
    socket.send(data);
  });
});
```

### window.postMessage

**window.postMessage()**方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数`Document.domain`设置为相同的值) 时，这两个脚本才能相互通信。**window.postMessage()**方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。

一般用于

1.页面和其打开的新窗口的数据传递

2.多窗口之间消息传递

3.页面与嵌套的 iframe 消息传递

- 

# 操作系统

### 进程和线程

进程：

代表 CPU 所能处理的单个任务。是并发执行的程序在执行过程中竞争计算机系统资源的基本单位。

线程：

是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。

# 浏览器

## 浏览器存储

客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。

### Cookie

由于HTTP是一种无状态的协议，服务器***单纯从网络连接上\***无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。 

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，***浏览器把请求的网址连同该Cookie一同提交给服务器\***。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

####  Cookie的不可跨域名性

 很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？

答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。

Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。

#### Cookie的一个实例 

cookie还用一个很广泛的用途就是记住用户的登录账号和密码，这样当用户以后再次需要登录同一个网站或系统的时候就不需要再次填写这两个字段而是直接点击“登录”按钮就好。这就相当于给了一些“甜头”给用户，这就回应了“cookie”这个词语的字面意思了。

> 如果用户是在自己家的电脑上网，登录时就可以记住他的登录信息，下次访问时不需要再次登录，直接访问即可。

实现方法是把登录信息如账号、密码等保存在Cookie中，并控制Cookie的有效期，下次访问时再验证Cookie中的登录信息即可。

**保存登录信息的多种细分的cookie方案**

- 方案一：最直接的是把用户名与密码都保持到Cookie中，下次访问时检查Cookie中的用户名与密码，与数据库比较。这是一种比较危险的选择，一般不把密码等重要信息保存到Cookie中。
- 方案二：是把密码加密后保存到Cookie中，下次访问时解密并与数据库比较。这种方案略微安全一些。如果不希望保存密码，还可以把登录的时间戳保存到Cookie与数据库中，到时只验证用户名与登录时间戳就可以了。
- 方案三：只在登录时查询一次数据库，以后访问验证登录信息时不再查询数据库。实现方式是把账号按照一定的规则加密后，连同账号一块保存到Cookie中。下次访问时只需要判断账号的加密规则是否正确即可。

> 一和二两种方案验证账号时都要查询数据库。
>
> 方案三把账号保存到名为account的Cookie中，把账号连同密钥用MD5算法加密后保存到名为ssid的Cookie中。验证时验证Cookie中的账号与密钥加密后是否与Cookie中的ssid相等。
>
> 提示：该加密机制中最重要的部分为算法与密钥。由于MD5算法的不可逆性，即使用户知道了账号与加密后的字符串，也不可能解密得到密钥。因此，只要保管好密钥与算法，该机制就是安全的。

 

### Session

- Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。
- 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。
- 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。
- Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。



### Session和Cookie的关系

cookie 是一个实际存在的、具体的东西，http 协议中定义在 header 中的字段。session 是一个抽象概念、开发者为了实现中断和继续等操作，将client和server之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。即session描述的是一种通讯会话机制，而cookie只是目前实现这种机制的主流方案里面的一个参与者，它一般是用于保存session ID。



## 页面渲染

### 输入页面URL到页面渲染完成的流程

- 解析URL
- 浏览器本地缓存
- DNS解析
- 建立TCP连接（三次握手）
- 建立TLS协商（三次握手）
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文【状态代码、响应头字段】
- 浏览器根据深度遍历的方式把html节点遍历构建DOM树
- 遇到CSS外链，异步加载解析CSS，构建CSSOM
- 遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer / async属性则异步加载JS资源
- **将dom树和CSS DOM树构造成render树**。渲染树包含有关显示哪些节点及其计算样式的信息，但不包含每个节点的尺寸或位置。
- **布局（回流）**
- **绘制（重绘）**为了确保重绘可以比初始绘制更快地完成，屏幕上的绘图通常被分解成几层。 如果发生这种情况，则需要进行合成。
- **展示**

---

**AST**

当 Javascript 代码进入 Javascript 引擎时，它首先被解析。 这意味着代码被读取，并且在这种情况下，代码被转换为称为`抽象语法树` (AST) 的数据结构。 代码将被拆分成与语言相关的部分（如 `function` 或 `const` 关键字），然后所有这些部分将构建抽象语法树。

构建 AST 后，它会被翻译成机器代码并立即执行，因为现代 Javascript 使用即时编译。 这段代码的执行将由 Javascript 引擎完成，利用称为“调用堆栈”的东西。

> 调用堆栈是解释器（如 Web 浏览器中的 JavaScript 解释器）跟踪其在调用多个函数的脚本中的位置的机制——当前正在运行的函数以及从该函数中调用的函数等。

**可访问（无障碍）树**

除了我们一直在讨论的所有这些树（DOM、CSSOM 和 AST）之外，浏览器还构建了一种称为`可访问（无障碍）树`的东西。

> Web 开发中的可访问性（通常缩写为 A11y — 如“a”，然后是 11 个字符，然后是“y”）意味着让尽可能多的人能够使用网站，即使这些人的能力在某种程度上受到限制。

可访问性树是使用 DOM 构建的，稍后辅助设备将使用它来解析和解释我们正在访问的网页的内容。 ACT 就像 DOM 的语义版本，每次 DOM 更新时它都会更新。 每个需要暴露给辅助技术的 DOM 元素都会在 ACT 中有一个对应节点。 在未构建 ACT 之前，屏幕阅读器无法访问内容。

要查看可访问性树的实际的样子，您可以通过 Google Chrome 浏览器。 打开调试器 (F12) 并转到“元素”选项卡。 从那里，你可以在右侧选择“辅助功能”窗格。



### 浏览器渲染流程

拿到服务端资源后浏览器渲染的流程：


1. 解析 HTML 文件，构建 DOM 树，同时浏览器主进程负责下载 CSS 文件
2. CSS 文件下载完成，解析 CSS 文件成树形的数据结构，
3. CSSOM树结合 DOM 树合并成 RenderObject 树
4. 布局 RenderObject 树 （Layout/reflow），负责 RenderObject 树中的元素的尺寸，位置等计算
5. 绘制 RenderObject 树 （paint），绘制页面的像素信息
6. 浏览器主进程将默认的图层和复合图层交给 GPU 进程，GPU 进程再将各个图层合成（composite），最后显示出页面

### 重绘和回流

**回流必将引起重绘，反之不一定**

**重绘（Repaint）**

当页面中元素样式的改变并**不影响它在文档流中的位置**时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**回流（Reflow）**

当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。



#### **如何触发：** 

style变动造成repaint和reflow。 

**不涉及任何DOM元素的排版问题**的变动为repaint，例如元素的color/text-align/text-decoration等等属性的变动。 

**除上面所提到的DOM元素style的修改基本为reflow。**例如元素的任何涉及长、宽、行高、边框、display等style的修改。 

**常见触发场景：** 

repaint

1. color的修改，如color=#ddd；        
2. text-align的修改，如text-align=center；        
3. a:hover也会造成重绘。        
4. :hover引起的颜色等不导致页面回流的style变动。  
5. visibility:hidden

reflow

1. width/height/border/margin/padding的修改，如width=778px；        
2. 动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；        
3. appendChild等DOM元素操作；        
4. font类style的修改；        
5. background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；        
6. scroll页面，这个不可避免；        
7. resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。        
8. **读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；**



#### 如何避免

##### **CSS**

- **避免使用 table 布局。**
- 尽可能在 DOM 树的最末端改变 class。
- 避免设置多层内联样式。
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。
- **避免使用 CSS 计算表达式（例如：calc()）。**

##### **Javascript**

- 避免频繁操作样式，最好一次性重写 style 属性，或者**将样式列表定义为 class 并一次性更改 class 属性**。
- 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。
- 也可以先**为元素设置 display: none，操作结束后再把它显示出来**。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对**具有复杂动画的元素使用绝对定位，使它脱离文档流**，否则会引起父元素及后续元素频繁回流。

##### **图片懒加载**

图片懒加载在一些图片密集型的网站中运用比较多，通过图片懒加载可以让一些不可视的图片不去加载，避免一次性加载过多的图片导致请求阻塞（浏览器一般对同一域名下的并发请求的连接数有限制），这样就可以提高网站的加载速度，提高用户体验。

将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。注意，图片要指定宽高。

```text
<img src="default.jpg" data-src="666.jpg" />
```

当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。

### 防抖和节流

**防抖（debounce）**

防抖就是将函数的执行延迟一定时间，如果在该时间内重新触发事件，那么延迟的时间会重置，只有真正达到延迟时间，才会执行回调函数。

举个例子：游戏中的回城就可以认为是防抖，在回城的读秒过程中，如果再次执行回城操作，那么会重新进行读秒，只有整个读秒过程都没有再次执行回城操作，那么等到读秒结束才能成功回城。

- 输入框频繁输入内容，搜索或者提交信息。
- 频繁点击按钮，触发某个事件。
- 监听浏览器滚动事件。
- 监听用户缩放浏览器resize事件。

**节流（throttle）**

节流是指当事件触发时，会执行这个事件的响应函数。

但是该事件如果被频繁触发，那么**节流函数会按照一定的频率来执行函数**。

**节流类似于技能cd，不管你按了多少次，必须等到cd结束后才能释放技能。也就是说在如果在cd时间段，不管你触发了几次事件，只会执行一次。只有当下一次cd转换，才会再次执行。**

#### 防抖实现

```js
// 第一个参数是需要进行防抖处理的函数，第二个参数是延迟时间，默认为1秒钟
function debounce(fn, delay = 1000) {
// 实现防抖函数的核心是使用setTimeout
    // time变量用于保存setTimeout返回的Id
    
    let time = null
    
    function _debounce() {
        // 如果time不为0，也就是说有定时器存在，将该定时器清除
        if (time !== null) {
            clearTimeout(time)
        }
        
        time = setTimeout(() => {
            fn()
        }, delay)
    }
    
    // 防抖函数会返回另一个函数，该函数才是真正被调用的函数
    return _debounce
}
```

上面防抖函数的实现，已经基本上可以实现防抖的效果，但是还是会有一点小问题，比如说**this的指向和原来的函数是不一致的以及参数问题。**

```js
// 第一个参数是需要进行防抖处理的函数，第二个参数是延迟时间，默认为1秒钟
function debounce(fn, delay = 1000) {
// 实现防抖函数的核心是使用setTimeout
    // time变量用于保存setTimeout返回的Id
    
    let time = null
    
    // 将回调接收的参数保存到args数组中
    function _debounce(...args) {
        // 如果time不为0，也就是说有定时器存在，将该定时器清除
        if (time !== null) {
            clearTimeout(time)
        }
        
        time = setTimeout(() => {
            // 使用apply改变fn的this，同时将参数传递给fn
            fn.apply(this, args)  
        }, delay)
    }
    
    // 防抖函数会返回另一个函数，该函数才是真正被调用的函数
    return _debounce
}
```

当前我们实现的防抖函数已经基本没有什么问题了，但是**事件第一次触发时，函数也没有立即执行**

#### 节流实现

```js
// interval 间隔时间，也就是cd的长短
function throttle(fn, interval) {
    //该变量用于记录上一次函数的执行事件
    let lastTime = 0
    
    const _throttle = function(...args) {
        // 获取当前时间
        const nowTime = new Date().getTime()
        
        // cd剩余时间
        const remainTime = nowTime - lastTime
        // 如果剩余时间大于间隔时间，也就是说可以再次执行函数
        if (remainTime - interval >= 0) {
            fn.apply(this, args)
            // 将上一次函数执行的时间设置为nowTime，这样下次才能重新进入cd
            lastTime = nowTime
        }
    }
    // 返回_throttle函数
    return _throttle
}
```

上面的代码就是基本的节流函数实现，但是会发现**第一次事件的响应函数会立即执行**。这是因为我们的**lastTime一开始设置为0**，而当我们**触发事件时，获取到的nowTime是一个非常大的值，那么减去lastTime就会大于interval，所以第一次会立即执行。**

## 性能优化

首屏加载的意义不言而喻，毕竟第一印象最重要，直接影响用户体验和留存。当用户使用你的产品的时候，一上来半天刷不出首页，很多用户往往就直接给你Ctrl+F4了。

在了解怎么优化之前，我们需要知道首屏加载的几个重要时刻。

- **首次加载**——FP
- **什么时候加载出页面**——First Meaningful Paint
- **什么时候用户可以交互**——Time To Interactive

### 浏览器：

- `减少HTTP请求`
   如Chrome浏览器最多同时允许对同一个域名Host建立6个TCP连接，不同的浏览器有所区别，减少http请求也就是减少我们html里css/js等资源的数量
- `使用HTTP2.0`
   需要配置一个支持h2的web服务器，并下载安装一张TLS证书，让浏览器与服务器通过h2链接
   http2.0优势：
  1. 采用二进制格式传输数据, 1.1是文本格式
  2. 对消息头采用Hpack进行压缩传输，能够节省消息头占用的网络流量，1.1每次请求，都会携带大量冗余的头信息，浪费了很多宽带资源
  3. 异步连接多路复用
  4. Server Push，服务器端能够更快的把资源推送到客户端
  5. 保持与HTTP 1.1语义的向后兼容性也是该版本的一个关键
- `设置浏览器缓存策略`
   主要为设置缓存策略：强缓存和协商缓存
- `页面使用骨架屏，白屏时间做加载动画`
   增强用户体验

### 资源：

- `静态资源cdn`
   静态css/js/img等资源可以做cdn缓存，这样把资源同步到全国全球各地，用户就能更快访问到
- `静态资源单独域名`
  1. 浏览器请求并发限制（同一域名（包括二级域名）在同一时间支持的并发请求数量的限制）
  2. cookie传输，单独域名，不会携带cookie
  3. 方便分流和缓存（动静分离，有利于静态资源做cdn缓存）
- `gzip压缩`
   使资源体积更小
   服务端配置，如nginx可配置支持gzip压缩资源传输的方式
   如果浏览器支持gzip解析，服务器就会推送gzip的资源，在http的相应头里可以看到显示Content-Encoding:gzip
- `做服务端渲染（SSR）`
   现在主流框的react、vue导致的一个痛点，就是页面构建交给了客户端来渲染，构建的过程无疑是排在了请求到html/js资源后，也就是至少两次http请求后才开始构建，这无疑是导致白屏的关键点之一，所以做ssr页面的话，能够直接返回页面，减少了不少首屏渲染时间
- `将CSS放在文件头部，JavaScript文件放在底部`
   单线程js可能会阻滞文档加载

### 图片：

- `字体图标代替图片图标`
   一些通用的小图标，如箭头，叉，可以使用字体图标，减少请求，渲染更快
- `精灵图`
   一些带有企业特色的小图标，如淘宝购物车，笑脸娃娃，可以使用精灵图，让一张图上带有多个小图，然后使用css背景定位来显示出合适的位子，能大大减少请求
- `图片懒加载`
   为了首屏渲染更快，图片可设置一张加载图代替，当页面在可视区域内时在替换为正真的图片
   如果有首屏很大的高清图，可先渲染清晰度低的缩略图，在首页基本构建完成下一次事件循环再去替换为高清图

   - 通过 JavaScript 监听 onscroll 事件，通过 `getBoundingClientRect` API 获取元素图片距离视口顶部的距离，配合当前可视区域的位置实现图片的懒加载

   - 通过 JavaScript ，通过 HTML5 的 `IntersectionObserver` API，配合监听元素的 `isIntersecting` 属性，判断元素是否在可视区内，能够实现比监听 onscroll 性能更佳的图片懒加载方案

   - 添加CSS的 `content-visibility: auto` 属性。不在可视区域内的内容，一开始是没有被渲染的，在每次滚动的过程中，才逐渐渲染，以此来提升性能。但是图片资源的 HTTP/HTTPS 请求，依然会在页面一开始被触发！

   - HTML5 新增了一个 `loading` 属性，属性的值为 `loading=lazy` 会告诉浏览器，如果图像位于可视区时，则立即加载图像，并在用户滚动到它们附近时获取其他图像。

   - `decoding=async` 实现图片的异步解码。`decoding` 属性用于告诉浏览器使用何种方式解析图像数据。

     它的可选取值如下：

     - `sync`: 同步解码图像，保证与其他内容一起显示。
     - `async`: 异步解码图像，加快显示其他内容。
     - `auto`: 默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。

- `图片预加载`
   可以在window.onload之后请求一些其他地方需要的图片资源
   比如我们有一个活动页使用了高清图，我们可以在它的入口前的首页就加载它，当我们进去页面时，浏览器就会从缓存里读取这张图片
- `使用png格式的图片`
   PNG 格式是WEB 图像中最通用的格式，它是一种无损压缩格式
- `小于10k的图片可以打包为base64格式`
   可以使用webpack url-loader处理

### 代码：

- `慎用全局变量`
  1. 全局变量定义在全局执行上下文，是所有作用域链的顶端。局部找不到就会一直往上找，影响性能
  2. 全局执行上下文一直存在于上下文执行栈，直到程序退出，不利于GC回收
  3. 命名污染
- `缓存全局变量`
   将使用中无法避免的全局变量缓存到局部
- `减少重绘回流`
   回流：当元素的规模尺寸，布局，隐藏等改变的时候，render dom需要重新构建，这就称为回流
   重绘：元素只更新外观，风格，而不会影响布局的，叫重绘
- `节流、防抖`
- `少用闭包、减少内存泄漏`
- `减少数据读取次数`

## 缓存

### 分类

我们使用 HTTP 缓存，通过复用缓存资源，减少了客户端等待时间和网络流量，同时也能缓解服务器端的压力。可以显著的提升我们网站和应用的性能。

通常根据是否需要向服务器重新发起HTTP请求去确认缓存是否有效将缓存分为强制缓存和协商缓存

`强制缓存`就是直接从浏览器缓存查找该结果，并根据结果的缓存规则来决定是否使用该缓存的过程。**强制直接使用缓存**

`协商缓存`就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，**由服务器根据缓存标识决定是否使用缓存的过程**

### 强缓存

在 HTTP 中，我们可以通过设置响应头以及请求头来控制缓存策略。

**强缓存可以通过设置`Expires`和`Cache-Control` 两种响应头实现。如果同时存在，`Cache-Control`优先级高于`Expires`。**

#### Expires

Expires 响应头，代表该资源的过期时间，其值为一个绝对时间。它告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。由于是个绝对时间，客户端与服务端的时间时差或误差等因素可能造成客户端与服务端的时间不一致，将导致缓存命中的误差。如果在`Cache-Control`响应头设置了 `max-age` 或者 `s-max-age` 指令，那么 `Expires` 会被忽略。

#### Cache-Control

`Cache-Control` 出现于 HTTP/1.1。可以通过指定多个指令来实现缓存机制。主要用表示资源缓存的最大有效时间。即在该时间端内，**客户端不需要向服务器发送请求**。优先级高于 Expires。**其过期时间指令的值是相对时间，**它解决了绝对时间的带来的问题。



### 协商缓存

#### Last-Modified、If-Modified-Since

`Last-Modified`与`If-Modified-Since` 的值都是 GMT 格式的时间字符串，代表的是文件的最后修改时间。

1. 在**服务器在响应请求时，会通过`Last-Modified`告诉浏览器资源的最后修改时间**。
2. 浏览器再次请求服务器的时候，请求头会包含`Last-Modified`字段，后面跟着在缓存中获得的最后修改时间。
3. **服务端收到此请求头发现有`if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。**如果已经修改，那么开始传输响应一个整体，服务器返回：200 OK

但是在服务器上经常会出现这种情况，一个资源被修改了，但其实际内容根本没发生改变，会因为`Last-Modified`时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP/1.1 推出了`Etag`。**Etag 优先级高与`Last-Modified`。**

#### Etag、If-None-Match

`Etag`都是服务器为每份资源生成的唯一标识，就像一个指纹，资源变化都会导致 ETag 变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的。

在浏览器发起请求，浏览器的请求报文头会包含 `If-None-Match` 字段，其值为上次返回的`Etag`发送给服务器，服务器接收到次报文后发现 `If-None-Match` 则与被请求资源的唯一标识进行对比。**如果相同说明资源没有修改，则响应返 304，浏览器直接从缓存中获取数据信息。**如果不同则说明资源被改动过，则响应整个资源内容，返回状态码 200。

## 调试工具

### Web的devtool（F12）

#### element

显示元素的种类和样式

左边是html。右边可以看细节，甚至可以修改一些style属性，

左上角的剪头可以选中

#### computed

在computed里面可以搜索想调试的类名

#### console

可以打印出日志。一般有 log error warn info debug 五种方法，其打印出来的颜色不一样

console.dir 打开文件树，可以查找更多属性

#### source

左边有个page，可以在下面的文件下看到项目源代码

右边有个断点调试的显示，可以看不同的项目，展示的东西不同。scope可以看各个变量的值，call stack看执行栈。XHR可以制造请求时断点，发生请求就断下来

可以在中间的主界面打断点——手动打断点就是往代码里加debugger，执行到断点时就暂停，右边会显示此时的相关状态

一般还是console来调

**压缩后的代码怎么调试**——前端代码天生具有 “开源”属性，出于安全考虑，上线之前 JavaScript 代码通常会被压缩，压缩后的代码只有一行，变量使用‘a‘、‘b‘等替换

可以用source-map：当有错误的时候，可以在console里面点击，就回原来的代码了

#### network

展示站点请求的各种资源

瀑布图会看是并行还是串行

可以模拟在弱网络下运行

#### application

左边分栏展示各种存储相关的本地存储信息

#### performance

先点左上方按钮录制5秒

可以对各个部分的耗时进行统计

可以控制生成一个慢网速、慢硬件的场景来调试

#### lighthouse

点击性能分析

