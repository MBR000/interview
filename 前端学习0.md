目录

- **HTML（HTML5.3）**

- **CSS（模块）**

- JS（ESnext）

- VUE

- React

- 算法

- 数据结构

- 计算机网络

- 浏览器原理

- 操作系统

- 其它（Node+Git+Webpack）

  

# HTML

**HTML5.0 **

**【canvas绘图】【SVG绘图】【原生拖放】【地理位置】【视频和音频】【增强型表单】【语义化标签】【Web Storage】【Web Worker】【Web Socket】**

## 结构

### **文档类型声明**

即`<!DOCTYPE html>`，这是html5的写法。用来说明该文档是HTML文档。所有的HTML文档开始于文档声明之后，它说明了文档的类型及其所遵守的标准规范集，是必须的组成部分。

### \<html>

\<html>标签位于HTML文档的最前面，用来标识HTML文档的开始；\</html>标签位于HTML文档的最后面，用来标识HTML 文档的结束；这两个标签对成对存在，中间的部分是文档的头部和主题。

两个属性

dir 是用来指定浏览器用什么方向来显示包含在元素中的文本，它决定文本在整个文档中将以什么方向显示，该属性有ltr和rtl两种，前者规定文本从左到右显示，后者与之相反。除非特殊需要，一般不需要为<html>便签制定dir属性，省略即可

lang 用来指明文档内容或者某个元素内容使用的语言，理想情况下，浏览器可以使用lang属性将文本更好的显示给用户。比如`<html lang="en">`、`<html lang="zh">`。好处一是避免不兼容，二是容易被搜索引擎收录

#### html5

`<html manifest="demo.appcache">` 带有缓存 manifest 的 HTML 文档（用于离线浏览）

### \<head>

可以包含一些辅助性标签，如`<title>` ,`<base>` ,`<link>` ,`<meta>` ,`<style>` ,`<script>`

#### `<title>`

必需的。在标题栏显示页面标题

> 但是，也有特殊情况可以省
>
> The title element is a required child in most situations, but when a higher-level protocol provides title information, e.g. in the Subject line of an e-mail when HTML is used as an e-mail authoring format, the title element can be omitted.

#### `<base>` 

标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接。

`<base href="http://www.runoob.com/images/" target="_blank">`

#### `<link>` 

通常用于链接到**外部样式表** `<link rel="stylesheet" type="text/css" href="mystyle.css">`

也有链接其它东西的

#### `<style>`

生成**内部样式表**

> CSS一共分三种：内联样式表（写标签里）、嵌入样式表（写style里）、外部样式表（写link里）

#### `<meta>` 

描述了一些基本的元数据，使用于浏览器，搜索引擎，或其他Web服务。

1. 最常用的设置是用来**设置字符集**。对于中文网页需要使用`<meta charset='utf-8'>`，否则会乱码

2. 此外，meta标签共有两个属性，分别是http-equiv属性和name属性。
   - name——`<meta name="参数" content="具体的描述">`
     1. 参数`keywords`告诉搜索引擎，你网页的关键字
     2. 参数`description`告诉搜索引擎，你网站的主要内容
     3. 参数`viewport`用于设计移动端网页
     4. 参数`author`用于标注网页作者
     5. `copyright` ,`generator` ,`revisit-after` ,`renderer`, `robots`
   - http-equiv——`<meta http-equiv="参数" content="具体的描述">`
     1. 参数`cache-control`指定请求和响应遵循的缓存机制
        - `no-siteapp`用于禁止当前页面在移动端浏览时被百度自动转码
        - 用于HTTP缓存，参数有no-cache, no-store, public, private, maxage
     2. 参数`X-UA-Compatible`用于告知浏览器以何种版本来渲染页面
     3. 参数`expires`用于设定网页的到期时间，过期后网页必须到服务器上重新传输
     4. 参数`refresh`表明将在设定的时间内，自动刷新并调向设定的网址
     5. 参数`Set-Cookie`表明如果网页过期。那么这个网页存在本地的cookies也会被自动删除
        `<meta http-equiv="Set-Cookie" content="User=des; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT"> `

#### `<script>`

script 元素比较常用的几个属性

- src：可选，用于引用外部 javascript 文件。`<script src=”xxx.js”></script>`
- type：可选，编写代码使用的脚本语言的类型，默认值为 text/javascript
- async：可选，异步加载脚本，只对外部脚本文件有效。
  下载不阻塞其他脚本的下载和HTML解析；但是一下载完就执行，会阻塞HTML解析。
  `async script`的执行顺序依赖于它们下载完成的快慢
- defer：可选，延迟脚本加载，只对外部脚本文件有效。
  下载不阻塞其他脚本的下载和HTML解析；在构建完 DOM 之后，DOMContentLoaded 之前执行
  多个`defer script`的执行顺序与它们在document出现的顺序一致
- **注：普通情况下，scripts 下载、执行都会阻碍html解析。所以有【js的放置位置】的问题**

可以直接内联，在`<script>`, `</script>`包着的地方直接写js代码

#### ` <noscript>`

对于不支持js的环境下，显示这个内容

### \<body>

各种标签

## 常考问题

### 标签分类

块元素——p、div

行内元素——span

行内块元素——img

## DOM BOM

### 综述

**DOM**：文档对象模型（Document Object Model，简称**DOM**），是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准**编程接口** W3C已近定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式

**DOM树**

- 文档：一个页面就是一个文档，DOM中使用document表示
- 元素：页面中的所有标签都是元素，DOM中使用element表示
- 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示

**BOM**（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。

BOM 缺乏标准，由于没有标准，不同的浏览器实现同一功能，可以通过不同的实现方式。例如，加入收藏夹这个功能：

```js
IE浏览器: window.external.AddFavorite(url,title);
FireFox浏览器: window.sidebar.addPanel(title, url, "");
```

**BOM 比 DOM 更大，它包含 DOM**



### BOM

#### window对象

| 属性/方法                                        | 含义                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| opener                                           | 当前窗口的父窗口                                             |
| length                                           | 窗口中的框架数                                               |
| document                                         | 窗口中当前显示的文档对象                                     |
| **alert(string)**                                | 创建一个警告对话框，显示一条信息                             |
| close()                                          | 关闭窗口                                                     |
| confirm()                                        | 创建一个需要用户确认的对话框                                 |
| open(url,name,[options])                         | 打开一个新窗口并返回新 window 对象                           |
| **prompt(text,defaultInput)**                    | 创建一个对话框要求用户输入信息                               |
| setInterval(expression,milliseconds)             | 经过指定时间间隔计算一个表达式                               |
| setInterval(function,millis enconds,[arguments]) | 经过指定时间间隔后调用一个函数                               |
| setTimeout(expression,milli seconds)             | 在定时器超过后计算一个表达式                                 |
| setTimeout(expression,milli seconds,[arguments]) | 在定时器超过时后计算一个函数                                 |
| resizeTo()                                       | 调整当前窗口的尺寸至指定的宽度高度                           |
| resizeBy()                                       | 按照指定的像素调整窗口的大小                                 |
| onscroll                                         | 当浏览器的滚动条滚动时会触发该事件,或者鼠标滚轮滚动时触发(前提是有滚动条) |


window的所有属性和方法，都可以两种表示方法调用：

(1) window.属性 / window.方法()

(2) 直接属性 / 方法() 的方式调用



#### location 对象

console.log(location);
console.log(location.href);//完整的URL路径
console.log(location.protocol);//协议名            
console.log(location.hostname);//主机名
console.log(location.port);//端口号
console.log(location.host);//主机名+端口号        
console.log(location.pathname);//文件路径
console.log(location.search);//从？开始的参数部分
console.log(location.hash);//从#开始的锚点部分

**location对象不仅仅是window对象的一个属性，还是document对象的一个属性。**

**这意味着：**

> **window.location = location = document.location**



#### history 看浏览记录

1. length; 查看浏览器的历史访问的网页的个数；
2. back(); 加载history列表中的前一个url
3. forward();加载history列表中的下一个url
4. go(); 加载history列表中的某个具体页面

 [history.pushState()](https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState) 创建并激活新的历史记录

 [history.replaceState() ](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API#The_replaceState()_method) 修改了当前的历史记录项



#### navigator 看浏览器状态

1. appCodeName;浏览器的代码名。
2. appName;完整的浏览器名称。
3. appVersion;浏览器的平台和版本信息。
4. userAgent;包含浏览器的名称、内核、版本号等。
5. plugins;检测有无插件。
6. onLine;表示是否连接到了因特网。

#### screen 看屏幕状态

height;屏幕的像素高度

width;屏幕的像素宽度

availHeight;屏幕的像素高度减去系统部件高度之后的值(只读)

availWidth;屏幕的像素宽度减去系统部件宽度之后的值(只读)

availLeft;未被系统部件占用的最左侧的像素值(只读)[chrome和firefox返回0，IE不支持]

availTop;未被系统部件占用的最上方的像素值(只读)[chrome和firefox返回0，IE不支持]



#### **常用属性：**

 **window.scrollX，window.scrollY**    滚动条 卷曲距离

 **获取浏览器组件对象**

 **window.locationbar**        地址栏对象
 **window.menubar**        菜单栏对象
 **window.scrollbars**        窗口的滚动条对象
 **window.toolbar**        工具栏对象
 **window.statusbar**        状态栏对象
 **window.personalbar**        用户安装的个人工具栏对象

 **全局对象属性：**

 **window.document**        指向 document   对象
 **window.location**       指向 Location对象，用于获取当前窗口的 URL 信息。它等同于 document.location 属性
 **window.navigator**        指向 Navigator 对象，用于获取环境信息 
**window.history**        指向 History 对象，表示浏览器的浏览历史 
**window.localStorage**        指向本地储存的localStorage 数据 
**window.sessionStorage**       指向本地储存的sessionStorage 数据 
**window.console**        指向 console 对象，用于操作控制台 
**window.screen**        指向 Screen 对象，表示屏幕信息



### event

#### 注册事件

将JavaScript函数与指定的事件相关联，被绑定的函数成为该事件的句柄。当该事件被触发时，绑定的函数会被调用。

注册事件具有以下三种方式实现：

- HTML页面元素提供的事件属性
- DOM标准规范中HTML相关对象提供的事件属性
- 通过向HTML页面中指定元素添加事件监听器

#### 事件流

所谓事件流，就是当触发某个元素的事件时，事件会按照DOM结构树进行传播，传播的过程如下：

1. **捕获阶段**：该阶段是由网景公司提出的。按照DOM结构由`document`对象向下的顺序传播，直到目标元素为止。
   (1) `document`
   (2) `<html>`
   (3) `<body>`
   (4) `<div>`
2. **目标阶段**：该阶段就是值目标元素触发当前事件
3. **冒泡阶段**：该阶段是由微软公司提出的，按照DOM结构树由目标元素向上的顺序传播，直到`document`对象

触发事件流的条件如下所示：

- 这些元素之间的关系是祖先与后代的关系
- 这些元素绑定相同的事件

**取消事件冒泡**

取消事件冒泡有两种方式，

一种是**通过`addEventListener()`方法注册事件时，将第三个参数设置为`true`**；

另一种就是**通过`event`对象提供的`stopPropagation()`方法**。

#### event常见使用

**enent.perventDefault() // 阻止默认行为**

**event.stopPropagation() // 阻止冒泡** 方法作用在后续节点上，目的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序


event.stopImmediatePropagation() 方法作用在后续节点上，目的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序


event.currentTarget() 常用于事件委托，表示当前被点击的元素


event.target 当前绑定的事件



#### 列举event

**onload 和 onunload 事件**

- 当用户进入后及离开页面时，会触发 onload 和 onunload 事件。
- onload 事件可用于检测访问者的浏览器类型和浏览器版本，然后基于该信息加载网页的恰当版本。
- onload 和 onunload 事件可用于处理 cookie。

**onchange 事件**

- onchange 事件经常与输入字段验证结合使用。
- 下面是一个如何使用 onchange 的例子。当用户改变输入字段内容时，会调用 upperCase() 函数。

**onmouseover 和 onmouseout 事件**

- onmouseover 和 onmouseout 事件可用于当用户将鼠标移至 HTML 元素上或移出时触发某个函数：

**onmousedown, onmouseup 以及 onclick 事件**

- onmousedown, onmouseup 以及 onclick 事件构成了完整的鼠标点击事件。
- 首先当鼠标按钮被点击时，onmousedown 事件被触发；然后当鼠标按钮被释放时，onmouseup 事件被触发；最后，当鼠标点击完成后，onclick 事件被触发。



| 常见事件（鼠标） | 触发条件                       |
| ---------------- | ------------------------------ |
| click            | 单击                           |
| dblclick         | 双击                           |
| mouseenter       | 鼠标悬停在元素上,替代mouseover |
| mouseleave       | 鼠标离开元素,替代mouseout      |
| focus            | 鼠标按键按下                   |
| blur             | 鼠标按键抬起                   |

| 常见事件（键盘） | 触发条件                                   |
| ---------------- | ------------------------------------------ |
| keydown          | 键盘按键按下                               |
| keypress         | 键盘按键按下，仅用于字符按键，不识别功能键 |
| keyup            | 键盘按键抬起                               |

> 执行顺序：keydown → keypress → keyup



#### 事件是否可以冒泡

事件	是否可以冒泡
click	√
dbclick	√
keydown	√
keyup	√
mousedown	√
mousemove	√
mouseout	√
mouseover	√
mouseup	√
keyup	√
scroll	√
**focus	×**
**load	×**
**resize	×**
**unload	×**
**mouseenter	×**
**mouseleave	×**



### DOM

**DOM和文档有关，这里的文档指的是网页，也就是HTML文档**。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的HTML都是一样的，**所以DOM和浏览器无关，它关注的是网页本身的内容。**由于和浏览器关系不大，所以标准就好定了。

#### 查

1. element.getAttribute(attributeName)     //括号传入属性名，返回对应属性的属性值
2. getElementById() 返回匹配指定选择器的第一个元素(获取不到为 null)
3. getElementsByClassName 通过class来获取元素，返回元素对象数组
4. getElementsByTagName 通过标签名获取元素，返回元素对象数组
5. getElementsByName 通过name属性获取id号，返回元素对象数组
6. querySelector() 返回匹配指定选择器的第一个元素
7. querySelectorAll() 返回匹配指定选择器匹配的所有元素
8. element.parentNode     //返回当前元素的父节点对象
9. element.chlidren        //返回当前元素所有子元素节点对象，只返回HTML节点
10. element.chilidNodes   //返回当前元素多有子节点，包括文本，HTML，属性节点。（回车也会当做一个节点）
11. element.firstChild      //返回当前元素的第一个子节点对象
12. element.lastChild       //返回当前元素的最后一个子节点对象
13. element.nextSibling          //返回当前元素的下一个同级元素 没有就返回null
14. element.previousSibling   //返回当前元素上一个同级元素 没有就返回null
15. element.innerHTML   //返回**元素的所有文本，包括html代码**
16. element.innerText     //返回当前元素的自身及子代所有文本值，**只是文本内容，不包括html代码**

总结：

(1)所有获取DOM对象的方法中，**只有getElementById()和querySelector()这两个方法直接返回的DOM对象本身**，可直接为其绑定事件。

(2)getElementXXX类型的方法，除了通过Id获取元素，其他都返回一个集合，如果需要取到具体 的DOM元素，需要加索引，如：document.getElementsByClassName(“div”)[0] =>获取class为 box的所有元素中的第一个DOM元素。

#### 删

element.removeChild(Node)    //删除当前节点下指定的子节点，删除成功返回该被删除的节点，否则返回null

#### 改

element.setAttribute(attributeName,attributeValue)    //传入属性名及设置的值

removeAttribute

src、herf

innerHTML、innerText

style

className

value、type、disabled

#### 增

document.**createElement**("h3")    //创建一个html元素，这里以创建h3元素为例

document.**createTextNode**(String); //创建一个文本节点；

document.**createAttribute**("class"); //创建一个属性节点，这里以创建class属性为例

element.**appendChild**(Node);  //往element内部最后面添加一个节点，参数是节点类型

element.**insertBefore**(newNode,existingNode); //在element内部的existingNode前面插入newNode

#### 问题

**innerHTML与outerHTML的区别？**

DOM元素的innerHTML, outerHTML, innerText, outerText属性的区别也经常被面试官问到， 比如对于这样一个HTML元素：

```
<div>content<br/></div>
```

- innerHTML：内部HTML，`content<br/>`；
- outerHTML：外部HTML，`<div>content<br/></div>`；
- innerText：内部文本，`content`；
- outerText：内部文本，`content`；



## HTML5

### Canvas

#### 使用

在js中`var c=document.getElementById("myCanvas");`获取某个canvas对象

用`var ctx=c.getContext("2d");` 创建context对象，之后在这个对象上进行绘图操作。

#### context的api

canvas只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。所有其他类型的图形都是通过一条或者多条路径组合而成的。

**图形：**

[`fillRect(x, y, width, height)`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect)绘制一个填充的矩形

[`strokeRect(x, y, width, height)`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeRect)绘制一个矩形的边框

[`clearRect(x, y, width, height)`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clearRect)清除指定矩形区域，让清除部分完全透明。

**线条：**

beginPath()

新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。

closePath()

闭合路径之后图形绘制命令又重新指向到上下文中。

stroke()

通过线条来绘制图形轮廓。

fill()

通过填充路径的内容区域生成实心的图形。

moveTo(x, y)

将笔触移动到指定的坐标 x 以及 y 上

arc(x, y, radius, startAngle, endAngle, counterclockwise)

画弧线，counterclockwise是start和end合拢的时候画直线还是曲线

**色彩**

[`fillStyle = color`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillStyle)

设置图形的填充颜色。

[`strokeStyle = color`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeStyle)

设置图形轮廓的颜色。

**线性**

[`lineWidth = value`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineWidth)

设置线条宽度。

[`lineCap = type`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineCap)

**文本：**

[`fillText(text, x, y [, maxWidth\])`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillText)

在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。

[`strokeText(text, x, y [, maxWidth\])`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/strokeText)

在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。

**图片：**

**`drawImage(image, x, y)`**

其中 `image` 是 `image` 或者 `canvas` 对象，`x` 和 `y` 是其在目标 `canvas` 里的起始坐标。

`drawImage` 方法的又一变种是增加了两个用于控制图像在 canvas 中缩放的参数。

[`drawImage(image, x, y, width, height)`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage)

这个方法多了 2 个参数：`width` 和 `height，`这两个参数用来控制 当向 canvas 画入时应该缩放的大小

`drawImage` 方法的第三个也是最后一个变种有 8 个新参数，用于控制做切片显示的。

[`drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage)

第一个参数和其他的是相同的，都是一个图像或者另一个 canvas 的引用。其他 8 个参数最好是参照右边的图解，前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小。

![drawImage](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage/canvas_drawimage.jpg)

#### 细节

canvas 2d 坐标系的原点在左上角。canvas 2d 坐标系的y 轴方向是朝下的。

canvas 2d 坐标系的坐标基底有两个分量，分别是一个像素的宽和一个像素的高，即1个单位的宽便是1个像素的宽，1个单位的高便是一个像素的高。

webgl坐标系的坐标原点在画布中心。webgl坐标系的y 轴方向是朝上的。

webgl坐标基底中的两个分量分别是半个canvas的宽和canvas的高，即1个单位的宽便是半个个canvas的宽，1个单位的高便是半个canvas的高。

### webGL

#### 简介

WebGL是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，**WebGL可以为HTML5 Canvas提供硬件3D加速渲染（部分计算GPU）**，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。总结一下，**WebGL的本质 —— JavaScript操作OpenGL接口**。

```js
// CPU
const vertexShader = `shader source code` // 顶点着色器代码
const fragmentShader = `shader source code` // 片段着色器代码
const points = [{ x: 1, y: 1, z: 1 }/* ... */]  // 准备数据
gl.draw(points, vertexShader, fragmentShader) // 将数据和着色器发送给 GPU

// GPU
const positions = data.map(point => vertexShader(point)) // 运行顶点着色器
const frags = Rasterization(positions) // 光栅化
const colors = frags.map(frag => fragmentShader(frag)) // 运行片段着色器
Display(colors) // 渲染到屏幕
```

#### 基本使用

要获得这个接口的对象以用于 2D 和 3D 的图形渲染，可以通过在 `<canvas>` 元素上调用 [`getContext()`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/getContext) 函数，调用时传入“webgl”参数。其实3D上下文就是指WebGL

相比Canvas只有找画布、找画笔、开始画画，webgl更像电脑绘画，其绘画的步骤里除了之外还多了一层介质

webgl 绘图需要两种**着色器**：

- **顶点着色器（Vertex shader）：描述顶点的特征，如位置、颜色等。**
- **片元着色器（Fragment shader）：进行逐片元处理，如光照。**

顶点着色器用于处理图形的每个点，也就是上面例子中三角形的三个顶点。处理完毕后会进行光栅化，大家可以把光栅化理解成把图形变成一个个像素，我们显示器屏幕是一个个像素组成的，要显示图形就需要计算出图形中的每个像素点。片段着色器可以先理解成像素着色器，也就是将光栅化中的每个像素拿过来，给每个像素计算一个颜色。

```html
<canvas id="canvas"></canvas>

<!-- 顶点着色器 -->
<script id="vertexShader" type="x-shader/x-vertex">
    void main() {
        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
        gl_PointSize = 100.0;
    }
</script>

<!-- 片元着色器 -->
<script id="fragmentShader" type="x-shader/x-fragment">
    void main() {
        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
</script>

<script>
    // canvas 画布
    const canvas = document.getElementById('canvas');
    canvas.width=window.innerWidth;
    canvas.height=window.innerHeight;
    // webgl画笔
    const gl = canvas.getContext('webgl');
    // 顶点着色器
    const vsSource = document.getElementById('vertexShader').innerText;
    // 片元着色器
    const fsSource = document.getElementById('fragmentShader').innerText;
    // 初始化着色器
    initShaders(gl, vsSource, fsSource);
    // 指定将要用来清理绘图区的颜色
    gl.clearColor(0., 0.0, 0.0, 1.0);
    // 清理绘图区
    gl.clear(gl.COLOR_BUFFER_BIT);
    // 绘制顶点
    gl.drawArrays(gl.POINTS, 0, 1);

    function initShaders(gl,vsSource,fsSource){
        //创建程序对象
        const program = gl.createProgram();
        //建立着色对象
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        //把顶点着色对象装进程序对象中
        gl.attachShader(program, vertexShader);
        //把片元着色对象装进程序对象中
        gl.attachShader(program, fragmentShader);
        //连接webgl上下文对象和程序对象
        gl.linkProgram(program);
        //启动程序对象
        gl.useProgram(program);
        //将程序对象挂到上下文对象上
        gl.program = program;
        return true;
    }

    function loadShader(gl, type, source) {
        //根据着色类型，建立着色器对象
        const shader = gl.createShader(type);
        //将着色器源文件传入着色器对象中
        gl.shaderSource(shader, source);
        //编译着色器对象
        gl.compileShader(shader);
        //返回着色器对象
        return shader;
    }
</script>
```



### Three.js

官网：Javascript 3D library（JavaScript 3D 库）。Three.js是基于webGL的封装的一个易于使用且轻量级的3D库，**Three.js**对WebGL提供的接口进行了非常好的封装，简化了很多细节，大大降低了学习成本，极大地提高了性能，功能也非常强大，用户不需要详细地学习 **WebGL**，就能轻松创作出三维图形，是前端开发者研发3D绘图的主要工具。微信小游戏跳一跳也是在基于Three.js研发的，Threejs现在是独领风骚。

#### Thress.js 三大要素（核心）：

**场景（scene）、相机（camera）、渲染器（renderer）**。相机获取到场景内显示的内容，然后再通过渲染器渲染到画布上面

#### 场景初始化

定义好渲染尺寸的常量，我们需要覆盖满整个窗口，所以宽高的取值是 `window.innerWidth` 和 `window.innerHeight`。如果需要渲染到具体 `DOM` 中，那么宽高就取 `DOM` 的宽高。然后初始化渲染器、场景和相机。

```js
// 定义渲染尺寸
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight
}

// 初始化渲染器
const canvas = document.querySelector('canvas.webgl');
const renderer = new THREE.WebGLRenderer({ canvas: canvas });
renderer.setSize(sizes.width, sizes.height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// 初始化场景
const scene = new THREE.Scene();

// 初始化相机
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);
camera.position.z = 3;
scene.add(camera);
```

`WebGLRenderer` 用 `WebGL` 渲染出场景。通过 `new THREE.WebGLRenderer` 初始化渲染器，并将 `canvas` 容器作为参数传给它。通过调用 `setSize` 方法设置渲染器的尺寸；调用 `setPixelRatio` 设置 `canvas` 的像素比为当前设备的屏幕像素比，避免高分屏下出现模糊情况。

`Scene` 是场景对象，所有的网格对象、灯光、动画等都需要放在场景中，使用 `new THREE.Scene` 初始化场景，下面是场景的一些常用属性和方法。

- `fog`：设置场景的雾化效果,可以渲染出一层雾气，隐层远处的的物体。
- `overrideMaterial`：强制场景中所有物体使用相同材质。
- `autoUpdate`：设置是否自动更新。
- `background`：设置场景背景，默认为黑色。
- `children`：所有对象的列表。
- `add()`：向场景中添加对象。
- `remove()`：从场景中移除对象。
- `getChildByName()`：根据名字直接返回这个对象。
- `traverse()`：传入一个回调函数访问所有的对象。

为了在场景中显示物体，就必须给场景添加相机，相机类型可以分为**正交相机**和**透视相机**，本例中使用的是透视相机 `PerspectiveCamera`，可以像下面这样使用透视相机。

```js
PerspectiveCamera(fov, aspect, near, far)
```

- `fov`：表示视场，就是能够看到的角度范围，人的眼睛大约能够看到 `180度` 的视场，视角大小设置要根据具体应用，一般游戏会设置 `60~90` 度，默认值 `45`。
- `aspect`：表示渲染窗口的长宽比，如果一个网页上只有一个全屏的 `canvas` 画布且画布上只有一个窗口，那么 `aspect` 的值就是网页窗口客户区的宽高比 `window.innerWidth/window.innerHeight`。
- `near`：属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。 默认值 `0.1`。
- `far`：属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小，会有部分场景看不到，默认值 `1000`。

#### 页面缩放适配

为了防止画布渲染内容在浏览器尺寸发生变化时产生变形和移位，可以对 `resize` 事件进行监听，当页面发生变化时，同时更新渲染器的尺寸和相机视角比例，并调用 `.updateProjectionMatrix()` 手动更新相机对象的投影矩阵属性。

```js
// 页面缩放事件监听
window.addEventListener('resize', () => {
  sizes.width = window.innerWidth;
  sizes.height = window.innerHeight;
  // 更新渲染
  renderer.setSize(sizes.width, sizes.height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
  // 更新相机
  camera.aspect = sizes.width / sizes.height;
  camera.updateProjectionMatrix();
});
```

#### 逻辑开发

要创建可加载显示在场景中的内置三维模型，需要添加网格 `Mesh`，并为它创建几何体 `Geometry` 和 材质 `Material`。本示例中添加了一个 `Three.js` 内置的立方体网格模型。

```js
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x03c03c });
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
复制代码
```

`BoxGeometry` 是四边形的原始几何类，来创建立方体或者不规则四边形。

```js
BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)
```

- `width`：`X轴` 的宽度，默认为 `1`。
- `height`：`Y轴` 的高度，默认为 `1`。
- `depth`：`Z轴` 的深度，默认为 `1`。
- `widthSegments`：可选，宽度的分段数，默认是 `1`。
- `heightSegments`：可选，高度的分段数，默认是 `1`。
- `depthSegments`：可选，深度的分段数，默认是 `1`。

基础网格材质是一种一个以简单着色方式来绘制几何体的材质，它不受光照的影响。

```js
MeshBasicMaterial(parameters: Object)
```

- `parameters`：可选，用于定义材质外观的对象，具有一个或多个属性如 `color`、`map` 等。

#### 动画更新

完成上面的内容，如果你在浏览器中直接运行，会发现页面不会加载任何东西，因为还没有进行真正的渲染。为此，我们需要调用 `requestAnimationFrame` 在页面重回动画中更新渲染内容。在这里创建了一个 `tick` 动画方法，它的功能是使渲染器可以在每次屏幕刷新时对场景进行绘制的循环，在大多数屏幕上，requestAnimationFrame刷新率一般为 60次/秒。

```js
// 动画
const tick = () => {
  // 更新渲染器
  renderer.render(scene, camera);
  // 给网格模型添加一个转动动画
  mesh && (mesh.rotation.y += .02);
  mesh && (mesh.rotation.x += .02);
  // 页面重绘时调用自身
  window.requestAnimationFrame(tick);
}
tick();
```



### SVG

#### 介绍

SVG 是一种使用 XML 描述 2D 图形的语言，好处是清晰、体积小。可以直接用url、src引入到img等当中呈现。

#### 使用方式

在HTML5中，提供了SVG，可以直接生成一块svg对象。

使用`<svg width="100" height="100" viewBox="50 50 50 50"></svg>`在html中制作一个svg对象，这个100*100范围内就是svg的画布，视口是以(50,50)为左上角，宽和高50的矩形。然后在svg和/svg标签之中加其它标签进行绘制

如果 SVG 代码直接写在 HTML 网页之中，它就成为网页 DOM 的一部分，可以直接用 DOM 操作。

#### svg标签

`<circle>`标签代表圆形

`<line>`标签用来绘制直线

`<polyline>`标签用于绘制一根折线

`<rect>`标签用于绘制矩形

`<ellipse>`标签用于绘制椭圆

`<polygon>`标签用于绘制多边形

`<path>`标签用于制路径

`<text>`标签用于绘制文本

`<use>`标签用于复制一个形状

`<image>`标签用于插入图片文件

`<animate>`标签用于产生动画效果

`<animateTransform>`标签是因为 `<animate>`标签对 CSS 的transform属性不起作用，如果需要变形，就要使用这个

#### 和canvas区别

svg 是一种矢量图，而 canvas 依赖于分辨率。所以 **svg 放大不会失真**，但是 canvas 绘制的图形会失真。

svg 支持事件处理器，而 canvas 不支持事件处理器。

svg 中的文字独立于图像，文字可保留，可编辑和可搜索，canvas 的文本渲染能力弱。

canvas 适合图像密集型的游戏，频繁地重绘图像，svg 绘制的复杂度高时减慢渲染的速度。

canvas 绘制的图形可以多种格式 (jpg、png) 保存图片，但是 svg 绘制的只能以 .svg 格式保存，使用时可以引入 html 文件。

canvas 适合开发游戏，svg 不适合游戏应用。

### 原生拖放API

#### 创建

先创建一个对象（所有的HTML元素都可以），设置元素的 draggable 属性为 true，就可拖拽了。比如`<img id="dragImg" draggable="true" />`

#### 拖动

拖拽之后，一松鼠标就没了，所以要联合使用js的事件监听。js提供了几个默认的钩子

对拖拽元素：

- `ondragstart`当拖拽开始时调用
- `ondragleave` 当**鼠标离开拖拽元素时**调用
- `ondragend` 当拖拽结束时调用
- `ondrag` 整个拖拽过程都会调用

对目标元素：

- `ondragenter` 当拖拽元素进入时调用
- `ondragover` 当拖拽元素停留在目标元素上时，就会连续一直触发（不管拖拽元素此时是移动还是不动的状态）。注意，**一定要在这个function里加`e.preventDefault()`阻止拖拽事件的默认行为**，不然ondrop() 无法触发
- `ondrop` 当在目标元素上松开鼠标时调用
- `ondragleave` 当鼠标离开目标元素时调用

例如：

```javascript
var box = document.getElementById('dragImg');
    box.ondragstart = function () {
        console.log('拖拽开始.');
    }
    box.ondragleave = function () {
        console.log('拖拽离开..');
    }
    box.ondragend = function () {
        console.log('拖拽结束...');
        console.log("---------------");
    }ja
    box.ondrag = function () {
        console.log('拖拽');
    }
```

### 地理位置

```javascript
function notice() {
            //判断是否支持获取位置
            if (window.navigator.geolocation) {
                window.navigator.geolocation.getCurrentPosition(success, error, {
                    enableHighAccuracy:true,//设置高精度的地理位置信息
                    timeout:3600, //毫秒
                    maximumAge:3600, //对地理位置信息的缓存时间
                });
                //成功
                function success(position) {
                    var pos = position.coords;
                    console.log("纬度：" + pos.latitude);
                    console.log("经度：" + pos.longitude);
                    console.log("当前地理位置的海拔高度：" + pos.altitude);
                    console.log("获取到的经度或纬度的精度：" + pos.accuracy);
                    console.log("获取到的海拔高度的精度：" + pos.altitudeAccuracy);
                    console.log("设备前进的方向：" + pos.heading);
                    console.log("设备前进的速度：" + pos.speed);
                }
                //失败
                function error(error) {
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            console.log(" 用户拒绝对获取地理位置的请求。"); break;
                        case error.POSITION_UNAVAILABLE:
                            console.log(" 位置信息是不可用的。"); break;
                        case error.TIMEOUT:
                            console.log(" 请求用户地理位置超时。"); break;
                        case error.UNKNOWN_ERROR:
                            console.log(" 位置错误 "); break;
                    }
                }
            } else {
                alert("当前不支持获取位置功能！");
            }
        }
```

### 视频和音频

#### video

````html
<video src="./test.mp4" controls="controls" width="700px" height="400px"></video>

<video controls="controls" width="700px" height="400px">
    //我们插入的播放器带有多个源文件，浏览器会根据需要来选择源文件
    <source src="./test.mp4" type="video/mp4">
    <source src="./test.ogg" type="video/ogg">
    您的浏览器不支持 video 标签
</video>
````

- src 将要播放的视频的 URL

- controls 如果设置该属性，则向用户显示控件，例如播放按钮，音量按钮等
- autoplay 如果设置该属性，则视频在就绪后马上播放，设置了 autoplay 后会忽略属性 preload
- width 设置视频播放器的宽度
- height 设置视频播放器的高度
- loop 如果设置该属性，则当媒介文件完成播放后再次开始播放 
- muted 设置视频的音频输出应该被静音
- poster 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像 
- preload 如果设置该属性，则视频在页面加载时进行加载，并预备播放

#### audio

```html
//跟video基本一致
<audio controls="controls">
    <source src="./test.mp4" type="audio/mpeg">
    <source src="./test.ogg" type="audio/ogg">
    您的浏览器不支持 audio 标签
</audio>
```

- src 将要播放的音频的 URL

- controls 如果设置该属性，则向用户显示控件，例如播放按钮
- autoplay 如果设置该属性，则在就绪后马上播放，设置了 autoplay 后会忽略属性 preload
- loop 如果设置该属性，则当完成播放后再次开始播放 
- muted 设置音频输出应该被静音
- preload 如果设置该属性，则在页面加载时进行加载，并预备播放

### 增强型表单

HTML5中，新标准把文本框提示信息、表单校验、日期选择控件、颜色选择控件、范围控件、进度条、标签跨表单等功能直接加入新的表单标签中。

#### input标签中type的值

H4原有：text password radio checkbox submit reset button file；

H5新增：

- email 用来表示一个应该输入邮箱格式文本的输入框，如果格式不对会给提示
- url 用来表示一个应该输入网址格式文本的输入框，如果格式不对会给提示
- number 用来表示一个应该包含数值域的输入框；它的属性有：min表示输入域的最小值，max表示输入域的最大值，step表示步长，即每次加或减得数量，默认step为1
- search 用来表示搜索域，比如站点搜索或 Google 搜索。它显示为常规的文本域
- color 用来表示一个拾色器，点开它可以选择你要的颜色
- **date 用来表示日期的一个输入框点开后会给一个日期表供你选择日期**
- month 和上面的date一样也会给你一个日期表供你选择日期，只是只能选择年和月
- week 和上面的date和month一样会给你一个日期表供你选择，只是你只能选择xxxx年第xx周
- tel 用来输入一个电话号码的输入框，在电脑端与type="text"差不多，在移动手机端会自动将输入法换成是数字
- **range 用来显示一个滑块控件，可拖动，和number一样可以设置最大值、最小值和步长**
- **time 用来写入时间的输入框，点开后可以选择到xx时xx分**

#### input、form的新属性

- autocomplete 属性规定 form 或 input 域应该拥有自动完成功能，当用户在自动完成域中开始输入时，浏览器应该在该域中显示以前填过的内容作为填写的选项
- novalidate 是一个 boolean(布尔) 属性，规定在提交表单时不应该验证 form 或 input 域
- autofocus 属性是一个布尔属性，规定在页面加载时，域自动地获得焦点

#### 新增表单控件

H4原有：input/（select/option）/label。

H5新增：

- datalist 为文本框提供一个可选的列表

  ```html
  <form method="post">
      输入网址：<input type="text" list="urlList"/>
      <datalist id="urlList">
          <option label="百度一下" value="https://www.baidu.com/"></option>
          <option label="百度翻译" value="https://fanyi.baidu.com/"></option>
          <option label="百度文库" value="https://wenku.baidu.com/"></option>
      </datalist>
  </form>
  ```

- keygen 对即将传输的数据加密

- output 进行一个计算的输出

  ```html
  <form oninput="x.value=parseInt(a.value)+parseInt(b.value)">0
    <input type="range" id="a" value="50">100 +
    <input type="number" id="b" value="50">=
    <output name="x" for="a b"></output>
  </form>
  ```

### 语义化标签

#### 表示结构的标签

- `<header>` 表示页面中一个内容区块或整个页面的标题。
- `<section> ` 页面中的一个内容区块，如章节、页眉、页脚或页面的其他地方，可以和h1、h2……元素结合起来使用，表示文档结构。
- `<article>`  表示页面中一块与上下文不相关的独立内容，如一篇文章。
- `<aside>` 表示`<article>`标签内容之外的，与`<article>`标签内容相关的辅助信息。
- `<hgroup>  `表示对整个页面或页面中的一个内容区块的标题进行组合。
- `<figure> ` 表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。
- `<figcaption> ` 定义`<figure>`标签的标题。
- `<nav> ` 表示页面中导航链接的部分。
- `<footer> ` 表示整个页面或页面中一个内容区块的脚注。一般来说，它会包含创作者的姓名、创作日期及联系方式。

#### 有功能的标签

- progress 进度条，可以用于标记下载进度
  `<progress value="0.5">50%</progress>`
- meter 计量条，表示某种计量，适用于温度、重量、金额等量化的表现。
  `<meter value="0.5"></meter>`
- mark 高亮文本标签
- address 个人或者某个组织的联系信息等等
- del 移除的内容

### Web Storage

跟浏览器缓存不是一个东西

#### 以前的存储方式cookie

**Cookie的例子**

用户首次访问购物网站，网站server为用户生成了一个sessionId，并在响应中携带Set-Cookie: sessionId=123;  Expires=Tue, 15 Jan 2021 21:47:38 GMT;。

浏览器收到服务端的响应，从响应中获取到Set-Cookie，将sessionId=123存储浏览器cookie中。由于Set-Cookie中携带了Expires属性，浏览器同时为该cookie设置过期时间（如果没有Expires属性，浏览器会把该cookie作为session cookie处理，当用户关闭浏览器时，该cookie会被删除）

用户将一个iphone商品加入购物车，浏览器会将此购物车操作发送给server，并且在该请求中的cookie中自动携带上sessionId=123。server会记住sessionId=123的用户在购物车中添加了一个iphone

用户然后关闭了该购物网站

数小时后，用户再此打开此购物网站并访问购物车，网站从后端请求购物车数据。浏览器查找本地cookie，发现保存了此网站sessionId=123的有效cookie，浏览器在网站请求头中附带自动附带sessionId=123的cookie。

服务端收到购物车查询请求，并获从请求头中获取到sessionId=123，服务器查找内存中的id=123的session，发现有此用户的购物车商品数据（一台iphone）。服务器将此数据返回给前端。

用户在购物车中看到了自己上次访问网站是添加的iphone，选中此商品完成结算。



**cookie属性项**

| 属性项     | 属性项介绍                                                   |
| :--------- | :----------------------------------------------------------- |
| NAME=VALUE | 键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样 |
| Expires    | 过期时间，在设置的某个时间点后该 Cookie 就会失效。否则关闭浏览器时才失效 |
| Domain     | 生成该 Cookie 的域名，如 domain="[www.baidu.com](http://www.baidu.com)" |
| Path       | 决定哪些路径允许使用Cookie                                   |
| Secure     | 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie   |
| HttpOnly   | 降低客户端脚本访问受保护cookie的风险                         |

HttpServletResponse提供的Cookie操作只有一个addCookie(Cookie cookie)，所以想要修改Cookie只能使用一个同名的Cookie来覆盖原先的Cookie。如果要删除某个Cookie，则只需要新建一个同名的Cookie，并将maxAge设置为0，并覆盖原来的Cookie即可。

新建的Cookie，除了value、maxAge之外的属性，比如name、path、domain都必须与原来的一致才能达到修改或者删除的效果。否则，浏览器将视为两个不同的Cookie不予覆盖。

值得注意的是，从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。浏览器提交Cookie时只会提交name和value属性，maxAge属性只被浏览器用来判断Cookie是否过期，而不能用服务端来判断。



**问题：**

> 特定域名下的cookie的数量有限，当超过这个限制之后会清除以前设置的cookie。
>
> cookie的大小限制为4kb。
>
> 存在安全问题，如果cookie被拦截了，拦截者无需解密cookie，只需转发cookie就能达到某种目的。
>
> cookie只能同源，无法跨域使用。



**安全问题**

①

中间人攻击：

- 在网络环境中，客户端与服务端之间的通路上会经过很多节点（wifi路由器，运营商网关），而基于HTTP的传输数据是未经加密的，很容易被攻击者劫持篡改或者截取信息。
- 在上图中，攻击者通过在路由器上部署木马，将路由器的浏览过滤并转发到自己的服务器。（比如将用户访问某银行的请求）
- 攻击者获取到请求数据后，从请求中获取cookie信息，并利用该cookie信息构造恶意请求，比如构造一个转账请求发送给服务器，由于cookie是真实有效的，服务器收到请求后会接受该请求，并执行转账操作导致用户资金进入攻击者的账户。

防御方法：

- 网站使用https来传输数据
- 服务端在Set-Cookie中设置secure属性，指示浏览器必须在使用https的请求中才能携带cookie信息，在http中不携带cookie，避免被攻击者截取破解。

②

DNS缓存中毒

- 攻击者利用DNS服务器，构造一条虚假的DNS记录，通常是被攻击网站的子域名。这里被攻击网站是a.com，攻击者构造的DNS记录是fabric.a.com
- 用户访问[a.com后，浏览器中会保存a.com的cookie信息](https://link.juejin.cn?target=http%3A%2F%2Fa.com%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BC%9A%E4%BF%9D%E5%AD%98a.com%E7%9A%84cookie%E4%BF%A1%E6%81%AF)
- 攻击者制作了一张美女图片，访问链接为[fabric.a.com/meizi.png，并…](https://link.juejin.cn?target=http%3A%2F%2Ffabric.a.com%2Fmeizi.png%EF%BC%8C%E5%B9%B6%E5%BC%95%E8%AF%B1%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%EF%BC%88%E7%BE%A4%E5%8F%91%E9%82%AE%E4%BB%B6%EF%BC%8C%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%AB%99%E5%8F%91%E5%B8%83%E7%AD%89%EF%BC%89)
- 由于a.com的cookie没有指定domain，默认会在所有子域名中携带cookie，因此当用户访问该图片时，携带了a.com下的所有cookie，发送给了攻击者伪造的服务器
- 攻击者从服务器中获取到用户的cookie，并利用改cookie完成用户信息的盗用

防御方式：

- 网站采用https，并为cookie设置Secure属性
  - 如果攻击者伪造的图片是基于Http的，由于Secure属性的存在，a.com下的cookie将不会被携带其中
  - 如果攻击者试图构造一张基于Https的图片，由于其无法获取TSL证书，当用户访问该图片时，浏览器会显示该证书非法，访问存在风险，从而帮助用户识别风险。
- DNS服务商采用更有效的安全策略来防止DNS被污染

③

XSS攻击之cookie盗用

- 攻击者在a.com网站发布包含恶意脚本的文章（网站服务器没有对用户上传的内容做安全校验），如图中，该文章中包含一个按钮「点我看美女」。此按钮实际是一个包含恶意脚本的标签
- 用户浏览a.com，点击了含有恶意代码的帖子，触发js脚本，导致浏览器携带cookie访问attacker.com 
- 在这种攻击方式下，即使a.com使用了https，攻击者仍然能够偷取用户的cookie。 

 防御方式：  

- 在a.com中对cookie设置HttpOnly属性，该属性会禁止前端通过js读取网站的cookie数据，从而防止cookie被盗用。



#### 以前的存储方式indexDB

> IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。

**特点**

 非关系型数据库(NoSql)：主要以键值对的形式存储数据

持久化存储：手动删除该数据库才能删掉，清除缓存依然保留

异步操作：不会锁浏览器，与localstorage形成鲜明的对比，后者是同步的。

支持事务：失败了自动回滚

同源策略

存储容量大



#### session

cookie和[session](https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020)都是用来跟踪浏览器用户身份的会话方式。

cookie数据保存在客户端，session数据保存在服务端。

简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。


#### Storage 介绍

Web Storage的两个主要目标是：提供一种在cookie之外存储会话数据的途径；提供一种存储大量可以跨会话存在的数据的机制。

**Web Storage分为两种： sessionStorage 和localStorage，区别是数据存储的位置** 。从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，用户在浏览某个网站过程中才一直存在；而localStorage则一直将数据保存在客户端本地； 不管是sessionStorage，还是localStorage，可使用的API都相同。

HTML5存储是**基于键值对（key/value）的形式存储**的，每个键值对称为一个项（item）。存储和检索数据都是通过指定的键名，键名的类型是字符串类型。值可以是包括字符串、布尔值、整数，或者浮点数在内的任意JavaScript支持的类型。但是，最终数据是以字符串类型存储的。

#### 接口

setItem(key,value)、getItem(key)、removeItem(key)、clear()、key(index)

#### 疑难

> **问题——sessionStorage在同一网站多个标签页内共享数据吗？**

- 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的会话；

- 在新标签或窗口打开一个页面时会**复制**顶级浏览会话的上下文作为新会话的上下文，这点和session cookies 的运行方式不同；

- 打开多个相同的 URL 的 Tabs 页面，会创建各自的 sessionStorage；

- 关闭对应浏览器或窗口，会清除对应的 sessionStorage。

总结：

只有在页面中以窗口或标签打开的同源页面才会复制sessionStorage，但之后的数据变化互不影响。所以说：**多窗口之间 sessionStorage 不可以共享状态，在某些场景下新开的页面会复制之前页面的 sessionStorage，相互之间无关联。**



### Web Worker

#### 背景

单线程始终是一个痛点，为了利用多核 CPU 的计算能力， HTML5 提出 Web Worker 标准，它的作用就是给JS创造多线程运行环境，使得**一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作**。允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。

#### 限制

1. 同源限制
   worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧
2. 文件限制
   为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源
3. DOM操作限制
   Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象
4. 通信限制
   worker线程与主线程不在同一个上下文，不能直接通信，需要通过`postMessage`方法来通信。
5. 脚本限制
   worker线程不能执行`alert`、`confirm`，但可以使用 `XMLHttpRequest` 对象发出ajax请求。

#### 使用方法

主线程采用`new`命令，调用`Worker()`构造函数，新建一个 Worker 线程。

```javascript
var myWorker = new Worker(jsUrl, options)
//例子：
var myWorker = new Worker('worker.js', { name : 'myWorker' });
```

#### api

主线程

- `worker.postMessage()` 向 Worker 发消息
- `worker.onmessage` 指定监听函数，接收子线程发回来的消息。
- `worker.terminate()` Worker 完成任务以后，主线程就可以把它关掉。
- `worker.onerror()` worker出错了，主线程就检测到，执行这里面的代码

Worker线程

- `this.addEventListener()` 监听函数，监听函数的参数是一个事件对象，它的`data`属性包含主线程发来的数据
- `self.postMessage()` 向主线程发送消息
- `self.close()` 用于在 Worker 内部关闭自身
- `importScripts()` 用于Worker 内部加载其他脚本

#### 通信

主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种用postMessage的通信是拷贝关系，即是传值而不是传址

### Web Socket

#### 介绍

HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能轮询，轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）

WebSocket是一种通信协议，可在单个TCP连接上进行**全双工**通信，允许服务端主动向客户端推送数据，不需要服务器推送。在WebSocket API中，采用**二进制帧**结构传输。

#### 优势

WebSocket以外，一般有两种方法实时通信。AJAX轮询和Long Polling长轮询。

AJAX轮询也就是定时发送请求，也就是普通的客户端与服务端通信过程，只不过是无限循环发送，这样，可以保证服务端一旦有最新消息，就可以被客户端获取。

Long Polling长轮询是客户端发起一个Long Polling，服务端如果没有数据要返回的话，会hold住请求，等到有数据，就会返回给客户端。客户端又会再次发起一次Long Polling，再重复一次上面的过程。

上边这两种方式都有个致命的弱点，开销太大，被动性。假设并发很高的话，这对服务端是个考验。而**WebSocket一次握手，持久连接，以及主动推送的特点可以解决上边的问题，又不至于损耗性能。**



#### 细节

客户端发起一次HTTP握手（不是三次握手），告诉服务端进行WebSocket协议通讯，并告知WebSocket协议版本。服务端确认协议版本，升级为WebSocket协议。之后如果有数据需要推送，会主动推送给客户端。

连接开始时，客户端使用HTTP协议和服务端升级协议，升级完成后，后续数据交换遵循WebSocket协议。我们看看Request Headers就可以分辨，有**ws和wss协议**

- 用new来构造，`var ws = new WebSocket('ws://localhost:8080');` 执行上面语句之后，客户端就会与服务器进行连接。

- `ws.readyState` 返回实例对象的当前状态
  CONNECTING：值为0，表示正在连接。 
  OPEN：值为1，表示连接成功，可以通信了。 
  CLOSING：值为2，表示连接正在关闭。 
  CLOSED：值为3，表示连接已经关闭，或者打开连接失败。
- `ws.onopen` 用于指定连接成功后的回调函数
  注：如果要指定多个回调函数，可以使用`addEventListener`方法
- ``ws.onclose`` 用于指定连接关闭后的回调函数
- `ws.onmessage` 用于指定收到服务器数据后的回调函数
- `ws.send('your message');` 向服务器发送数据
- `ws.bufferedAmount` 还有多少字节的二进制数据没有发送出去
- `ws.onerror  ` 报错时的回调函数



# CSS

### 长度

**px**

表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的

**vh、vw**

把视窗均分成100份，主要用于页面视口大小布局，在页面布局上更加方便简单

**em**

相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（`1em = 16px`）

**rem**

相对单位，相对的只是HTML根元素`font-size`的值

em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素root（根源）。**

- 子元素字体大小的em是相对于父元素字体大小

- rem是全部的长度都相对于根元素，根元素是谁？<html>元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。

**百分比**



### font字体

- font-family：设置字体；

  - **family-name：字体名称，一个字体名称就代表一种字体，比如“微软雅黑”就是一种字体**
  - **inherit：从父元素继承字体的设置**
  - serif：有衬线字体，即在文字笔画的结尾添加特殊的装饰线或衬线
  - sans-serif：无衬线字体，即在文字笔画结尾处是平滑的
  - monospace：等宽字体，即每个文字的宽度都是相同的
  - cursive：草书字体，该字体有连笔或者特殊的斜体效果，会给人一种手写的感觉
  - fantasy：具有特殊艺术效果的字体

- font-style：设置字体的风格，例如倾斜、斜体等；

  - italic：显示的字体的斜体版本
  - oblique：倾斜的普通字体

- font-weight：设置字体粗细；

  - **100、200：由细到粗的设置字体粗细，100 为最细的字体，400 等同于 normal，700 等同于 bold**

- font-size：设置字体尺寸；

  - length：以数值加单位的形式把字体设置为一个固定尺寸，例如 18px、2em
  - %： 以百分比的形式为字体设置一个**相对于父元素字体**的大小

- font-variant：将小写字母转换为小型大写字母；

  -  small-caps：将文本中的小写英文字母转换为小型大写字母

- font：字体属性的缩写，可以在一个声明中设置多个字体属性。

  ````
  遵循顺序font：[[font-style||font-variant||font-weight||font-stretch]?font-size[ /line-height]?font-family] | caption | icon | menu | message-box | small-caption | status-bar
  font-size 和 font-family 两个属性不可忽略
  若要定义 line-height 属性，则需要使用斜线/将 font-size 和 line-height 属性分开。
  
  例如： font: italic bold 12px/30px arial, sans-serif;
  ````

### 文字外观样式

color 颜色【可以rgba调半透明】

line-height 行间距

text-aligh 水平对齐方式【left center right】

letter-spacing 字间距

word-spacing 单词间距，用于英文

word-break 是否允许英文在单词内换行

text-shadow 文字阴影，可以制造凸起效果

text-indent 首行缩进

text-decoration 文本装饰 【none underline overline line-through】

**text-overflow 过长的文本进行修饰 【ellipsis clip fade】**

**white-space 过长的文本能不能换行显示【nowrap】**

text-emphasis 在文字的上方或下方加着重符号

text-transform 把文字做大小写等变换 【capitalize uppercase lowercase】

### 背景

background-color：设置元素的背景颜色；

background-image：设置元素的背景图像；

- url('URL')：指向图像的路径，可以将 url() 看作是一个函数，括号中的 URL 为图像的具体路径
- **linear-gradient( 方向/角度 , 颜色1，颜色2，颜色3....);**
- repeating-linear-gradient(45deg, #F27121 20px, #E94057 30px, #8A2387 40px);
- radial-gradient(farthest-corner at 60% 55%, red, yellow, black);
- repeating-radial-gradient(circle at 20% 40%,#eea2a2 20px, #57c6e1 20px, #b49fda 40px, #7ac5d8 40px, #b49fda 60px, #4F9C9C 60px, #57c6e1 80px, #99CCCC 80px, #eea2a2 100px);

background-repeat：控制背景图像是否重复；
默认情况下背景图像会从元素内容的左上角开始（若有内边距则从元素内边距区域的左上角开始），在水平和垂直方向上重复背景图像以填充整个元素区域（不包括元素的外边距区域），您可以使用 background-repeat 属性用来设置背景图像是否重复或如何重复，该属性的可选值如下：

- repeat 默认值，背景图像将在垂直方向和水平方向上重复
- repeat-x 背景图像仅在水平方向上重复
- repeat-y 背景图像仅在垂直方向上重复
- no-repeat 背景图像仅显示一次，不在任何方向上重复

background-position：设置**背景图像**的起始位置

background-attachment：控制背景图像是否跟随窗口滚动；

- scroll 默认值，背景图像随着页面元素的滚动而移动
- fixed 当页面的其余部分滚动时，背景图像固定不动

background-size：设置背景图像的尺寸；

- xpos ypos
- x% y%
- cover 保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以完全覆盖元素所在的区域
- contain 保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以完整的显示在元素所在区域

background-origin：设置 background-position 属性相对于什么位置来定位背景图像；

- padding-box 相对于元素的内边距区域来定位背景图像
- border-box 相对于元素的边框区域来定位背景图像
- content-box 相对于元素的内容区域来定位背景图像

background-clip：设置背景图像的显示区域；

background：背景属性的缩写，可以在一个声明中设置所有的背景属性。推荐按照：

```
background-color || background-image || background-position [/ background-size]? || background-repeat || background-attachment || background-origin || background-clip
```

如果同时设置 background-position 和 background-size 属性，这两个属性之间需要使用斜线/分隔，并且需要遵循 background-position 属性在前 background-size 属性在后的顺序；

如果同时设置 background-origin 和 background-clip 属性，需要遵循 background-origin 属性在前 background-clip 属性在后的顺序。如果 background-origin 与 background-clip 属性的值相同，则可以只设置一个值。

#### 精灵图技术

将网页中的一些背景图像整合到一张大图中，减少服务器接受和发送请求的次数，提高页面的加载速度

使用background-image、background-repeat和background-position属性进行背景定位

#### icon-font

#### 滑动门技术

滑动门技术的关键在于不要给中间的盒子指定宽度，其宽度由内部的内容撑开。

### 选择器

元素标签里style > Internal style sheet > External style sheel

**！important > 行内样式（标签内写style） > ID 选择器 > 类选择器，伪类选择器 > 标签选择器**

#### 通配符选择器

通配符选择器常用 * 号表示，它是所有选择器里作用范围最广的，能匹配页面中所有的元素。

```
*{
margin：0；       /*定义外边距*/
padding：0；     /*定义内边距*/
}
```

#### 标签选择器

标签选择器是指用HTML标记名称作为选择器，按标记名称分类，为页面中某一类标签指定统一的CSS样式。

```
p{ font-size: 12px; color: #666; font-family:"微软雅黑"; }
```

#### 类选择器

类选择器使用**‘.’**(英文点号)进行标识，后面紧跟类名。

```
.red{color: red;}
```

#### id选择器

id选择器使用**‘#’**进行标识，后面紧跟id名。

```
#bold{font-weight:bold; }
```

#### 属性选择器

属性选择器可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。

[attribute]	              用于选取带有指定属性的元素
[attribute=value]	  用于选取带有指定属性和值的元素
[attribute~=value]	用于选取属性值中包含指定词汇的元素
[attributel=value]	 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词
[attribute^=value]	匹配属性值以指定值开头的每个元素
[attribute$=value]	匹配属性值以指定值结尾的每个元素
[attribute*=value]	匹配属性值中包含指定值的每个元素

```
input[type="text"]
{
  width:150px;
  display:block;
  margin-bottom:10px;
  background-color:yellow;
  font-family: Verdana, Arial;
}
```

使用属性选择器，可以只指定元素的某个属性，还可以同时指定元素的某个属性和其对应的属性值。

#### 并集选择器

并集选择器是同时匹配多个选择器，取多个选择器的并集，选择器之间用逗号隔开

```
span, div, .content {
    color:darkorange;
}
```

#### 后代选择器

后代选择器也称包含选择器，用来选择特定元素的后代。如.asideNav li{ }，表示先匹配第二个选择器的元素，并属于第一个选择器内。

```
ul li a {
	font-size: 12px;
}
```

注意：

1. 后代包括儿子，孙子，只要是放在指定标签的后代都是。
2. 也可以不用标签名称1、2，也可以用id和class名，分别用id和class来选择。
3. 后代选择器可以无限衍生。

#### 子代选择器

子代选择器使用 **‘>’** 表示，如ul>li{ }，表示匹配第二个选择器，且为第一个选择器的元素的后代

```
#box>p{
   color: darkorange;  /*设置颜色为 深橙色*/
   font-size: 80px;
}
```

注意：

1. 只会查找儿子，不会查找其他被嵌套的标签。
2. 子元素选择器也可以用其他的id和class选择器来进行查找。
3. 子元素选择器也可以通过>符号一直延续下去。

#### 兄弟选择器

如果需要选择在另一个元素后的元素，而且二者有相同的父元素，可以使用兄弟选择器。

相邻兄弟选择器使用+号表示，如p+a{ }，表示匹配紧跟第一个选择器并匹配第二个选择器的元素。而~ 选择器 ：作用是查找某一个指定元素的后面的所有兄弟结点。

```
li + li {
    color:red;
}
h1 ~ p{
    color:red;
}
```

#### 伪类选择器

动态伪类，必须按照a:link 、a:visited 、a:hover 、a:active的顺序写

| 伪类选择器 | 作用                                   | 应用对象              |
| ---------- | -------------------------------------- | --------------------- |
| :hover     | 标记在鼠标悬停(划过)时的样式           | 所有显示标记          |
| :link      | 标记在未访问状态下的样式               | a标签                 |
| :focus     | 标记在获取焦点时的样式                 | a标签(IE浏览器不支持) |
| :visited   | 标记被访问过后的样式，只能改变颜色属性 | a标签                 |
| :active    | 鼠标点击但是不松开时的样式             | a标签                 |

结构伪类



| 伪类选择器         | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| **:first-child**   | 一大堆元素里始终选择第一个                                   |
| **:last-child**    | 一大堆元素里始终选择最后一个                                 |
| :nth-last-child()  | 倒着数的nth-child                                            |
| :nth-child()       | 改变某些行数的，比如可以:nth-child(n)<br />也可以搞算法，比如:nth-child(2n)<br />也可以填odd、even |
| **:not()**         | 填**需要排除**的元素，比如li:not(li:first-child)             |
| **:first-of-type** | 直接选择父元素标签内**指定**标签的第一个元素，这样这个CSS效果就**不会失效** |

状态伪类

:disabled :enabled :checked


#####  伪元素选择器

伪对象选择器根据对象内部的局部元素定义其样式。

| 伪对象选择器   | 作用                   |
| -------------- | ---------------------- |
| ::first-letter | 选择元素的首字母       |
| ::first-line   | 选择元素的首行         |
| ::before       | 元素之前插入内容       |
| ::after        | 元素之后插入内容       |
| ::selection    | 选择用户选择的元素部分 |

伪元素不是真正的页面元素，html没有对应的元素，但是所有用法和真正的页面元素一样。伪元素选择器本质上是插入了一个inline元素，用content属性控制内容

### 标签模式

#### 块级元素

特点：
1）总是从新行开始；
2）**高度、行高、外边距以及内边距都是可以控制的**
3）宽度默认是容器的100%
4）可以容纳内联元素和其他块元素

常见的块元素

**<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>**

#### 行内元素

特点：
1）和相邻行内元素在一行上
2）**宽、高无效**，但水平方向的padding和margin可以设置，**垂直方向无效**
3）默认宽度就是他本身内容的宽度
4）行内元素只能容纳文本或其它行内元素

常见的行内元素

**<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>**

#### 行内块元素

在行内元素中有几个特殊的标签——<img>、<input>、<td>，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。

特点：
1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。
2）默认宽度就是它本身内容的宽度。
3）**高度，行高、外边距以及内边距都可以控制**。

#### display

进行标签显示模式转换

块转行内：display:inline;
行内转块：display:block;
块、行内元素转换为行内块： display: inline-block;

### 盒模型

一般东西都是盒子。但是图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容

#### border

- border-width

  ```
  一个值：上下左右一样
  两个值：上下一样；左右一样
  三个值：第一个上，第二个左右，第三个下
  四个值：上右下左
  ```

- border-style 【none solid dashed dotted double】

- border-color

- border-image

- border 简写顺序 width-style-color

- 分别写四面边框

- border-collapse: collapse 把重叠的边框合并在一起，成为一个边框，实现单线边框的效果

- border-radius 
  即使元素没有边框，圆角也可以用到 `background`上面，具体效果受 `background-clip`影响。

  ```
  border-radius: 4px 3px 6px / 2px 4px;
  /* 等价于： */
  border-top-left-radius:     4px 2px;
  border-top-right-radius:    3px 4px;
  border-bottom-right-radius: 6px 2px;
  border-bottom-left-radius:  3px 4px;
  
  一个值：四个角一样
  两个值：左上、右下一样；右上、左下一样
  三个值：第一个左上，第二个右上、左下，第三个右下
  四个值：左上开始顺时针循环
  ```

注：最大值超过宽高最大值，会按照宽高最大值等比缩放

#### padding

#### margin

给**块级元素**的外边距指定auto，实现居中对齐

清除内外边距

- margin：0；padding：0
- 尽量不要给行内元素指定上下的内外边距

#### 外边距塌陷

描述

- 相邻元素合并：当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者
- 父子合并：当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并
- 自己合并：假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。如果这个外边距遇到另一个元素的外边距，它还会继续合并

注：只有普通文档流中**块框**的垂直外边距才会发生外边距合并。**行内框、浮动框或绝对定位之间的外边距不会合并。**

解决思路——不要让margin碰到一起

1. 用padding代替margin
2. 用border
3. 触发BFC

#### 盒模型稳定性

width > padding > margin

#### box-sizing 

如何计算一个元素的总宽度和总高度

- content-box：如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。
- border-box：如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减去 (border + padding) 的值。**不包括margin**

#### box-shadow

`<inset>`  `<offset-x>`  `<offset-y>` `<blur-radius>` `<spread-radius>` `<color>`

```
box-shadow:
       inset 0 -3em 3em rgba(0,0,0,0.1),
             0 0  0 2px rgb(255,255,255),
             0.3em 0.3em 1em rgba(0,0,0,0.3);
//包括了三种 shadow，内置的阴影，常规的下沉阴影，和一个 2 个像素宽度的 border 式的阴影            
```



### 列表

有序 ol ——参数有【默认 A a I i】

无序 ul

用list-style:none 去除列表项前的标记

### 浮动

#### 起源

CSS三种流——普通流（标准流）、浮动、定位

最初时，浮动只能用于图像（某些浏览器还支持表的浮动），目的就是为了允许其他内容（如文本）“围绕”该图像。而后来的CSS允许浮动任何元素。浮动以后，上面的背景会在它的底下，但是文字会环绕，这就是与绝对定位在设计上不同的地方

#### 创建

`float` 属性用于创建浮动框，将其移动到一边，**直到左边缘或右边缘碰到包含块或另一个浮动框的边缘**。

#### 浮动的特点

1. 脱离标准流，不占位置（**自己原来的位置漏给后面的标流**）
2. 浮动的元素一排显示，如果父亲装不下了，默认另起一行显示。浮动的元素之间默认无缝隙。
3. 任何元素都可以添加浮动，无论它是块元素还是行内元素，**浮动后是行内块（块级元素可以在一行显示）**，可直接设置宽高。若块级元素没有设置宽度，则默认和父级一样宽；浮动盒子中间无间隙

#### 浮动与兄弟盒子的关系

浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。

排列：都浮动的盒子，盒子顶对齐

#### 浮动与父盒子的关系

如果一个父盒子里面有浮动，那这些浮动会继续影响下个父级盒子内的标准流

#### 清除浮动

用于解决因子元素浮动而造成的父元素高度为0的问题。清除浮动不是真的把浮动清除，而是清除加了浮动带给后面的标流的影响。

- 内墙法（在浮动元素的后面加一个空的**块级元素**并且设置`clear:both；`属性）
  当应用于非浮动块时，它将非浮动块的边框边界移动到所有相关浮动元素外边界的下方。
  注：**clear规则只能影响使用清除的元素本身，不能影响其他元素**
- 伪元素清除法（对父元素使用after或者使用before和after双伪元素清除浮动）
- 激活父元素BFC

### 定位

#### position

`position`属性用来指定一个元素在网页上的位置，一共有5种定位方式，即`position`属性主要有五个值。

 - `static` 默认值，代表普通流（标准流）。这时`top`、`bottom`、`left`、`right`无效。

 - `relative` 
   相对于默认位置（即`static`时的位置）进行偏移，即定位基点是元素的默认位置

 - `fixed` 
   相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。

 - `absolute` 
   相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。它有一个重要的限制条件：**定位基点（一般是父元素）不能是`static`定位，否则定位基点就会变成整个网页的根元素`html`**。因此有口诀【子绝父相】

 - `sticky`
   会产生动态效果，很像`relative`和`fixed`的结合：一些时候是`relative`定位（定位基点是自身默认位置），另一些时候自动变成`fixed`定位（定位基点是视口）。
   比如，网页的搜索工具栏，初始加载时在自己的默认位置（`relative`定位）。页面向下滚动时，工具栏变成固定位置，始终停留在页面头部（`fixed`定位）。

   应用：工具栏动态固定、图片的堆叠效果、表格的表头锁定

#### z-index

z-index属性是设置元素的层级，数值低的会被数值高的遮住。absolute、fixed常用

### 显示和隐藏

#### 隐藏

3. **display:none元素在页面上将彻底消失，导致浏览器的重排和重绘**
2. **visibility:hidden不会触发重排，但是会触发重绘，无法响应点击事件**
3. opacity:0变透明，不会引发重排，会引发重绘，无法响应点击事件
4. 设置height、width模型属性为0元素不可见，不占据页面空间，无法响应点击事件
5. position:absolute移出区域，元素不可见，不影响页面布局
6. clip-path元素不可见，占据页面空间，无法响应点击事件

#### overflow溢出

visible默认值。内容不会被修剪，会呈现在元素框之外。

hidden内容会被修剪，并且其余内容是不可见的。

scroll内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。

auto如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。

inherit

### 用户界面样式

#### cursor

#### outline

border以外的一圈，跟border的格式一样。轮廓线**不会占据空间**，也不一定是矩形。

#### resize

#### vertical-align

vertical-align影响**行内元素（inline、inline-block）和table-cell元素**的盒子，在line box中竖直方向的对齐位置。根据MDN描述，vertical-align对::first-letter和::first-line同样适用。

**设置元素的vertical-align属性，并没有改变该元素的baseline位置，只改变对齐线。**对齐线会变化，比如一个空div的默认对齐线是他的底，但是div里加了文字，默认对齐线就是文字的baseline了。

vertical-align基于baseline的选取

- baseline：子元素在这个line box中，对齐线对齐父元素的baseline
- middle：元素盒子的**垂直中点**与父盒子的**baseline加上父盒子的x字母高度的一半**位置对齐
- text-top：将盒子的顶端(margin-top边界)与**父盒子的文本区域顶端**对齐
- text-bottom：将盒子的底端（margin-bottom边界） 与父盒子的文本区域底端对齐

vertical-align基于line box的选取

- top：将子元素盒子的顶部和其所在的line box顶部对齐
- bottom：将子元素盒子的底部和其所在的line box底部对齐

**vertical-align去除图片底侧空白缝隙**：**可以想象内容最后总是存在一个没有没有任何对齐方式的内联元素x**。本质原因是字母'x'就临近行盒子底部，出现了baseline和bottom-line之间的空隙。解决方案就是改变在line box的对齐位置，让字母'x'的baseline和bottom-line之间的空隙因高度太小而被div的更大的高度掩饰住。



### transition

通过该功能，可以将元素从一种样式在指定时间内**平滑的过渡到另一种样式**，类似于简单的动画，但无需借助 flash 或 JavaScript。

- transition-property：设置元素中参与过渡的属性；
- transition-duration：设置元素过渡的持续时间；
- transition-timing-function：设置元素过渡的动画类型；
  - linear 以始终相同的速度完成整个过渡过程，等同于 cubic-bezier(0,0,1,1)
  - ease 以慢速开始，然后变快，然后慢速结束的顺序来完成过渡过程，等同于 cubic-bezier(0.25,0.1,0.25,1)
  - ease-in 以慢速开始过渡的过程，等同于 cubic-bezier(0.42,0,1,1)
  - ease-out 以慢速结束过渡的过程，等同于 cubic-bezier(0,0,0.58,1)
  - ease-in-out 以慢速开始，并以慢速结束的过渡效果，等同于 cubic-bezier(0.42,0,0.58,1)
  - cubic-bezier(n, n, n, n) 使用 cubic-bezier() 函数来定义自己的值
- transition-delay：设置过渡效果延迟的时间，默认为 0；
- transition：简写属性，用于同时设置上面的四个过渡属性。

注意：写在div里面，不要写在hover里

#### 2D

##### translate

```
transform:translate(x,y);   或者分开写
transform:transformX(n);
transform:transformY(n);
```

1. 定义2D转换中的移动，沿着X和Y轴移动元素
2. translate最大的优点：不会影响到其他元素的位置
3. translate中的百分比单位是相对于自身元素的translate:(50%，50%)
4. 对行内标签没有效果

##### rotate

```
transform: rotate(45deg)
```

1. rotate里面跟度数，单位是deg 比如rotate（45deg）
2. 角度为正时，顺时针，负时，为逆时针
3. 默认旋转的中心点是元素的中心点

##### transform-origin

1. 注意后面的参数x和y用空格隔开
2. x y默认的中心点是元素的中心点（50% 50%）作为元素转换的中心点
3. 还可以给x y设置 像素 或者 方位名词 （top bottom left right center）

##### scale

1. transform:scale(2,2);等价于transform:scale(2);
2. transform:scale(0.5,0.5):缩小
3. scale缩放最大的优势：默认以中心点缩放，**可以设置转换中心点缩放，而且不影响其他盒子**。

#### 动画

制作动画分为两步：先定义动画，再使用（调用）动画

##### 定义动画

```
@keyframes 动画名称{
	0%{
			width:100px;
	}
	100%{
	  		width:200px;
	}
}
0%是动画的开始，100%是动画的完成。这样的规则就是动画序列。
用百分比来规定变化发生的时间，或用关键词from和to，等同于0%和100%。
```

##### 使用动画

```
animation:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态
```

元素可以添加多个动画，用逗号隔开


| 属性                      | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| animation-name            | 规定@keyframes动画的名称（必须的）                           |
| animtion-duration         | 规定动画完成一个周期所花费的秒或毫秒，默认是0.（必须的）     |
| animation-timing-function | 规定动画的速度曲线，默认是ease                               |
| animtion-delay            | 规定动画何时开始，默认是0                                    |
| animation-iteration-count | 规定动画被播放的次数，默认是1，还有infinite（无限）          |
| animtion-direction        | 规定动画是否在下一周期逆向播放，默认是normal ，alternate逆播放 |
| animation-play-state      | 规定动画是否正在运行或暂停。默认是running 还有pause          |
| animtion-fill-mode        | 规定动画结束后状态，保持forwards，回到起始backwards          |

#### 3D

常用 `transform-style: preserve-3d;` 生成一个3D

变化：

transform: translateZ(100px); 沿着某个轴平移

transform: rotateY(180deg); 围绕某个轴旋转

之后一般会联合使用动画效果

### BFC

**BFC全称块级格式化上下文，是一个独立的布局环境，BFC内部的元素布局与外部互不影响**。我们经常使用到BFC，只不过不知道它是BFC而已。

#### 用处

清除浮动

#### 创建

BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素决定，CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。【ofdp】

- 元素的**float**不是 `none`，指定float为left或者right
- 元素的 **`position`** 为 `absolute` 或 `fixed`
- **display**:inline-block，display:table-cell，display:flex，display:inline-flex
- **overflow**指定除了visible的值
- 根元素

#### 特点

- **BFC的区域不会与浮动的元素区域重叠**，不会与浮动盒子产生交集，而是紧贴浮动边缘。可以用于制作右侧自适应
- **计算BFC的高度时，浮动元素也参与计算。**利用这个特性可以清除浮动和父元素塌陷
- BFC是隔离的独立容器，**容器里面的子元素不会影响到外面的元素**。可以用来消除margin塌陷
- 每一个盒子的左边缘碰到容器左边缘

### flex

`flex` 布局是 `flexible box` 的缩写 ，意思为 `弹性布局` ，用来为盒状模型提供最大的灵活性。
任何一个容器都可以指定为弹性布局。

#### flex容器

```css
display: flex | inline-flex
```

分别生成一个块状或行内的 flex 容器盒子。简单说来，如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。

**设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效**



#### flex容器上的属性

1. **flex-direction 决定主轴的方向(即项目的排列方向)**
   - row 主轴为水平方向，起点在左端
   - row-reverse 主轴为水平方向，起点在右端
   - column 主轴为垂直方向，起点在上沿
   - column-reverse 
2. **flex-wrap 决定容器内项目是否可换行**
   - nowrap 默认情况下，项目都排在主轴线上。当空间不足时，项目尺寸会随之调整而并不会挤到下一行。
   - wrap 项目主轴总尺寸超出容器时换行，第一行在上方
   - wrap-reverse 换行，第一行在下方
3. flex-flow：flex-direction 和 flex-wrap 的简写形式
4. **justify-content：定义了项目在主轴的对齐方式**
   主轴为水平方向时测试，即 flex-direction: row，有以下结果：
   - flex-start：左对齐
   - flex-end：右对齐
   - center：居中
   - **space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。**
   - **space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。**
5. **align-items: 定义了项目在交叉轴上的对齐方式**
   - stretch 默认值，如果项目未设置高度或者设为 auto，将占满整个容器的高度。
   - flex-start：交叉轴的起点对齐
   - flex-end：交叉轴的终点对齐
   - center：交叉轴的中点对齐
   - baseline: 项目的第一行文字的基线对齐
6. **align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用**
   当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。
   - flex-start：轴线全部在交叉轴上的起点对齐
   - flex-end：轴线全部在交叉轴上的终点对齐
   - center：轴线全部在交叉轴上的中间对齐
   - space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。
   - space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。

#### flex容器中各个item的属性

1. **order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0**

2. flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间
   当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。

   - 当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。
   - 当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。

3. flex-grow: 定义项目的放大比例
   当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。

   - 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。

   - 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。

   当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用。如果flex-wrap是wrap、wrap-reverse，那每一行的右端都可能会有剩余空间，flex-grow也会起作用。

4. flex-shrink: 定义了项目的缩小比例

   - 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。
   - 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。

5. **flex：flex-grow, flex-shrink 和 flex-basis的简写**

6. **align-self: 允许单个项目有与其他项目不一样的对齐方式**
   跟align-items 属性一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。



### grid

`display: grid`或者`display:inline-grid`指定一个容器采用网格布局。

设为网格布局以后，容器子元素（项目）的`float`、`display: inline-block`、`display: table-cell`、`vertical-align`和`column-*`等设置都将失效。

#### 列宽和行高

`grid-template-columns` 属性设置列宽，`grid-template-rows` 属性设置行高，这两个属性在 `Grid` 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的，下面针对 `grid-template-columns` 属性进行讲解

- grid-template-columns: 200px 100px 200px; 
  //固定的宽度
  
- grid-template-rows: repeat(2, 50px);
  //使用repeat函数，两个50px的
  
- grid-template-columns: **repeat(auto-fill, 200px);**
  //列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素
  
  很好的响应式布局方法
  
- grid-template-columns: 200px **1fr 2fr;**
  //fr是对剩下的距离进行等分
  
- grid-template-columns: 1fr 1fr **minmax(300px, 2fr);**
  //第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。
  
- grid-template-columns: 100px auto 100px;
  //第一第三列为 100px，中间由浏览器决定长度

#### 行间距和列间距

`grid-row-gap` 属性、`grid-column-gap` 属性分别设置行间距和列间距。`grid-gap` 属性是两者的简写形式。

#### 单元格合并

`grid-template-areas` 属性用于定义区域，一个区域由一个或者多个单元格组成。一般这个属性跟网格元素的 `grid-area` 一起使用

```
.wrapper{
  grid-template-areas:
    ". header  header"
    "sidebar content content";
  //六个单元格分别赋予了这六种类型
  //. 符号代表空的单元格，也就是没有用到该单元格
}

.sidebar {
  grid-area: sidebar;
}
//sidebar被合并到一起，并且属于.sidebar这个class名
```

#### 单元格标号顺序

`grid-auto-flow` 控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即默认值 `row`。

- row 先行后列
- row dense 先行后列，尽量减少空隙
- column 先列后行

#### 单元格中的内容放置

`justify-items` 属性设置每个单元格中内容的水平位置（左中右），`align-items` 属性设置单元格内容的垂直位置（上中下）

```
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
```

#### 单元格的放置

`justify-content` 属性是整个内容区域在容器里面的水平放置模式（左中右），`align-content` 属性是整个内容区域的垂直放置模式（上中下）。

```
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
注：space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔
```

#### **隐式和显示网格**

显式网格包含了你在 `grid-template-columns` 和 `grid-template-rows` 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列，它的行高和列宽可以根据 `grid-auto-columns` 属性和 `grid-auto-rows` 属性设置。

#### 用网格线选定网格

- grid-column-start 属性：左边框所在的垂直网格线

  - ```
    grid-column-start:span n //横跨n列
    ```
- grid-column-end 属性：右边框所在的垂直网格线
- grid-row-start 属性：上边框所在的水平网格线
- grid-row-end 属性：下边框所在的水平网格线

注：网格线最左上是横线1、竖线1，不是0

如果有冲突，可以设置 `z-index` 去决定它们的层级关系

```
.two { 
  grid-column-start: 2;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 2;
  /*   如果有重叠，就使用 z-index */
  z-index: 1;
  background: #8CC7B5;
}
```

#### 一个单元格单独改排列

`justify-self` 属性设置单元格内容的水平位置（左中右），跟 `justify-items` 属性的用法完全一致，但只作用于单个项目

`align-self` 属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目

#### 一些技巧

fr 实现等分响应式

```css
grid-template-columns: 1fr 1fr 1fr;
```

repeat+auto-fit——固定列宽，改变列数量

```css
grid-template-columns: repeat(auto-fit, 200px);
```

repeat+auto-fit+minmax 去掉右侧空白

```css
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
```

repeat+auto-fit+minmax-span-dense 解决空缺问题

```css
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
grid-auto-flow: row dense;
```

### 实战：水平和垂直居中

#### line-height

```
.div0{
  width:200px;
  height:150px;
  border:1px solid #000;
  line-height:150px;
  text-align:center;
}
.redbox{
  display:inline-block;
  width:30px;
  height:30px;
  background:#c00;
}
```

#### 伪元素+vertical-align

vertical-align这个属性，这个属性虽然是垂直居中，不过却是指在元素内的所有元素垂直位置互相居中，并不是相对于外框的高度垂直居中

所以要让一个**伪元素高为100%，撑开盒子以后来居中**

不过不过不过！div记得要把display设为inline-block，毕竟**vertical-align:middle；是针对行内元素**，div本身是block，所以必须要做更改！

```text
.div0{
  width:200px;
  height:150px;
  border:1px solid #000;
  text-align:center;
}
.redbox{
  width:30px;
  height:30px;
  background:#c00;
  display:inline-block;
  vertical-align:middle;
}
.div0::before{
  content:'';
  width:0;
  height:100%;
  display:inline-block;
  position:relative;
  vertical-align:middle;
  background:#f00;
}
```

#### calc动态计算

用到CSS特有的calc动态计算的能力，我们只要让要居中的div的top属性，与上方的距离是“50%的外框高度+ 50%的div高度”，就可以做到垂直居中，至于为什么不用margin-top，因为margin相对的是水平宽度，必须要用top才会正确。

```
.div0{
  width:200px;
  height:150px;
  border:1px solid #000;
}
.redbox{
  width:30px;
  height:30px;
  background:#c00;
  float:left;
  top:calc(50% - 15px);
  margin-left:calc(50% - 45px);
}
```

#### transform

transform是CSS3的新属性，主要掌管元素的变形、旋转和位移，利用transform里头的translateY（改变垂直的位移，如果使用百分比为单位，则是以元素本身的长宽为基准），搭配元素本身的top属性，就可以做出垂直居中的效果，比较需要注意的地方是，子元素必须要加上position:relative，不然就会没有效果喔。

```
.use-transform{
    width:200px;
    height:200px;
    border:1px solid #000;
}
.use-transform div{
    position: relative;
    width:100px;
    height:50px;
    top:50%;
    transform:translateY(-50%);
    background:#095;
}
```

#### 绝对定位

绝对定位就是CSS里头的position:absolute，利用绝对位置来指定，但垂直居中的做法又和我们正统的绝对位置不太相同，是要**将上下左右的数值都设为0，再搭配一个margin:auto**，就可以办到垂直居中，不过要特别注意的是，设定绝对定位的子元素，其父元素的position必须要指定为relative喔！而且绝对定位的元素是会互相覆盖的，所以如果内容元素较多，可能就会有些问题。

```
.use-absolute{
    position: relative;
    width:200px;
    height:150px;
    border:1px solid #000;
}
.use-absolute div{
    position: absolute;
    width:100px;
    height:50px;
    top:0;
    right:0;
    bottom:0;
    left:0;
    margin:auto;
    background:#f60;
}
```

#### flex

```
.use-flexbox{
    display:flex;
    align-items:center;
    justify-content:center;
    width:200px;
    height:150px;
    border:1px solid #000;
}
.use-flexbox div{
    width:100px;
    height:50px;
    background:#099;
}
```

### 响应式布局

#### 历史

随着互联网和相关设备的发展，前端的布局大概经历了这几个阶段：**table布局阶段、div+css布局阶段、静态布局阶段、流式布局阶段、自适应布局阶段、响应式布局阶段、弹性布局阶段**。前面两种布局已经基本上看不到了，而且现在的布局也越来越往弹性布局靠近。下面的内容主要是重点介绍一下后面几种布局。

#### 响应式布局介绍

主要目的是一套代码在不同设备上都能呈现。面对不同分辨率设备灵活性强，能够快捷解决多设备显示适应问题。**它可以识别屏幕大小，还是根据屏幕大小调整页面的布局。**

**1. 响应式布局的特点**

- 屏幕大小变化，元素的大小和位置也会发生改变。
- 能**同时适应pc和移动端**，只用开发一套。

2**. 响应式布局的应用场景**

响应式布局的应用场景就是需要同时兼容pc端和移动端的样式的布局一般都采用这种响应式布局，还有一些公司是pc端有一套样式，移动端也有一套样式，比如京东就是这样。像这种的话主要还是看公司业务需要。

#### 方法

响应式布局就是一个网站能够兼容多个终端，可以根据屏幕的大小自动调整页面的的展示方式以及布局，我们不用为每一个终端做一个特定的版本。响应式方案大概有以下几种方案

- CSS3 Media Query（**推荐**）：媒体查询，兼容到IE9+，但可以通过插件兼容IE6-8
- Flex：弹性布局，兼容性较差
- Grid：网格布局，兼容性更差
- Columns：栅格系统，往往需要依赖于某个UI库，如bootstrap

**媒体查询：**

响应式布局最主要的手段便是媒体查询，通过媒体查询设置断点，可以为各种屏幕宽度的设备提供对应样式。断点的设置一般可以设置为三种类型，如手机（<=480px），平板（480-720px），桌面电脑（>=1024px）

**弹性布局：**

响应式布局最常见的就是在pc端使用多栏布局（栅格），因为栅格布局很方便在不同屏幕设备中进行增删或者移动从而实现各种大小屏幕的适配（如小屏幕就一栏，而大屏幕就有三栏），每栏的宽度用流式布局（有时也叫弹性布局，就是`width`使用百分比）进行适应，因为不同屏幕的宽度各异。然后使用浮动进行横排。最外层包裹元素一般加个max-width，防止pc大屏太宽，导致页面内容跨度过大，造成阅读困难。

# 手写JS

 ## Promise

### promise.all

很多人不知道需要返回一个**Promise**对象，

最好判断一下传入的参数是否为数组

有很多人会分别判断数组里面的promise和常量， 但是里面的顺序会乱

```js
Promise.MyAll = function (promisearr) {
  let arr = [];
  let count = 0;
  return new Promise((resolve, reject) => {
    promisearr.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = res
        count += 1
        if (count === promises.length) resolve(arr)
      }).catch(reject)
    })
  })
}
```

### Promise.race

该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态**只能改变一次**, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.

```javascript
Promise.race = function (args) {
  return new Promise((resolve, reject) => {
    for (let i = 0, len = args.length; i < len; i++) {
      args[i].then(resolve, reject)
    }
  })
}
```

### promise红绿灯

利用 Promise 实现一个元素先红色两秒在黄色一秒再绿色三秒，不断循环

两种做法如下

```
function lightChange(duration,color) {
    return new Promise(function(resolve,reject) {
        console.log(color);
        setTimeout(resolve,duration);
    })
}

async function index() {
    while(1) {
        await lightChange(2000,'red');
        await lightChange(1000,'yellow');
        await lightChange(3000,'green');
    }
}

index();
---
let timer = null

const sleep = (time, light) => {
  return new Promise((resolve, reject) => {
    console.log(light)
    clearInterval(timer)
    timer = setInterval(() => {
      console.log(light)
    }, 1000)
    setTimeout(resolve, time)
  })
}

const main = async () => {
  while (true) {
    await sleep(5000, '红灯')
    await sleep(2000, '黄灯')
    await sleep(3000, '绿灯')
    clearInterval(timer)
  }
}

main()
```



## Array

### flat

ES5 实现：递归。

```js
function flatten(arr) {
    var result = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        if (Array.isArray(arr[i])) {
            result = result.concat(flatten(arr[i]))
        } else {
            result.push(arr[i])
        }
    }
    return result;
}
```

ES6 实现：

```js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
```

### forEach

具体实现可以参考map，map是返回一个新数组，forEach是直接改变原数组

### map

map 的实现大体和 forEach 类似，只是返回了一个新数组。

```javascript
Array.prototype._map = function (fn, thisArr) {
      if (this == undefined) {
        throw new TypeError('this is null or not undefined');
    }
     if (Object.prototype.toString.call(fn) !== '[object Function]') {
        throw new TypeError(fn + 'is not a function');
    }
    let res = [] 
    let mapArr = this // [1, 2, 3]
    for (let i = 0; i < mapArr.length; i++) {
        res[i] = fn.call(thisArr, mapArr[i], i, mapArr)
    }
    return res
}
```

### reduce

reduce 稍微麻烦一些，需要根据第二个参数是否存在，使用不同的处理方式。

```javascript
Array.prototype._reduce = function (fn, init) {
      if (this == undefined) {
        throw new TypeError('this is null or not undefined');
    }
     if (Object.prototype.toString.call(fn) !== '[object Function]') {
        throw new TypeError(fn + 'is not a function');
    }
    let reduceArr = this
    let index = arguments.length === 1 ? 1 : 0 // 求索引。如果没有传初始值，那么index就是1，因为没有传初始值，prev就是初始值，下标是0，那么自然curr下标就是1
    let prev = arguments.length === 1 ? reduceArr[0] : init // 求初始值。如果没有传入初始值，那么初始值就是数组的第一项，否则就是传入的初始值init
    for (let i = index; i < reduceArr.length; i++) {
        prev = fn(prev, reduceArr[i], i, reduceArr)  // 迭代累加
    }
    return prev
}
let arr = [1, 2, 3]
let reduceRes = arr._reduce((prev, curr) => {
    return prev + curr
})
console.log('reduceRes', reduceRes)// 6
let reduceResParams = arr._reduce((prev, curr) => {
    return prev + curr
}, 2)
console.log('reduceResParams', reduceResParams)// 8
```

### filter

filter 一般用来筛选。

```javascript
Array.prototype._filter = function (fn, thisArr) {
    if (this == undefined) {
        throw new TypeError('this is null or not undefined');
    }
    if (Object.prototype.toString.call(fn) !== '[object Function]') {
        throw new TypeError(fn + 'is not a function');
    }
    let filterArr = this
    let filterRes = []
    for (let i = 0; i < filterArr.length; i++) {
        if (fn.call(thisArr, filterArr[i], i, filterArr)) {
            filterRes.push(filterArr[i])
        }
    }
    return filterRes
}
let arr = [1, 2, 3]
let filRes = arr._filter((val, index, item) => {
    return val > 1
})
console.log(filRes)// [2,3]
```

### some

不会对空数组进行检测

返回一个新的数组

```js
Array.prototype._some = function (fn, thisArr) {
      if (this == undefined) {
        throw new TypeError('this is null or not undefined');
    }
     if (Object.prototype.toString.call(fn) !== '[object Function]') {
        throw new TypeError(fn + 'is not a function');
    }
    let someArr = this
    for (let i = 0; i < someArr.length; i++) {
        if (fn.call(thisArr, someArr[i], i, someArr)) {
            return true
        }

    }
    return false
}
let arr = [1, 2, 3]
let someRes = arr._some((val, index, item) => {
    return val > 1
})
console.log(someRes)// true
```

### every

every也是筛选数据。只是他返回的是true/false。如果`所有元素都满足条件`，则返回`true` , 只要有一个元素不满足条件，就返回`false`

```js
Array.prototype._every = function (fn, thisArr) {
       if (this == undefined) {
        throw new TypeError('this is null or not undefined');
    }
     if (Object.prototype.toString.call(fn) !== '[object Function]') {
        throw new TypeError(fn + 'is not a function');
    }
    let everyArr = this
    for (let i = 0; i < everyArr.length; i++) {
        if (!fn.call(thisArr, everyArr[i], i, everyArr)) {
            return false
        }
    }
    return true

}
let arr = [1, 2, 3]
let everyRes = arr._every((val, index, item) => {
    return val > 0
})
console.log(everyRes)// true
```



## String

## 节流防抖

防抖（最后一次触发事件后 n 秒后才执行函数）

```js
// 第一个参数是需要进行防抖处理的函数，第二个参数是延迟时间，默认为1秒钟
function debounce(fn, delay = 1000) {
// 实现防抖函数的核心是使用setTimeout
    // time变量用于保存setTimeout返回的Id
    
    let time = null
    
    // 将回调接收的参数保存到args数组中
    function _debounce(...args) {
        // 如果time不为0，也就是说有定时器存在，将该定时器清除
        if (time !== null) {
            clearTimeout(time)
        }
        
        time = setTimeout(() => {
            // 使用apply改变fn的this，同时将参数传递给fn
            fn.apply(this, args)  
        }, delay)
    }
    
    // 防抖函数会返回另一个函数，该函数才是真正被调用的函数
    return _debounce
}
```

节流（多久之内只执行一次）

时间戳版

```
function throttle(fn, wait) {
  let date = Date.now()
  return function () {
    let now = Date.now()
    if (now - date > wait) {
      fn.call(this, arguments)
      date = now
    }
  }
}
```

定时器版

```
function throttle(fn, wait) {
  let timer = null
  return function () {
  	// 若没有定时器，说明上一次设定的定时器已到时销毁
    if (!timer) {
      timer = setTimeout(() => {
        fn.call(this, arguments)
        timer = null
      }, wait)
    }
  }
}
```



## 排序

### 冒泡排序

代码

```js
function bubbleSort(arr){
    const len = arr.length;
    for(let i = 0; i < len; ++i){
        for(let j = 0; j < len - 1; ++j){
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
            }
        }
    }
    return arr;
}
```

优化

因为基本版代码没有考虑到已排序的尾部元素其实无需再次进行比较，所以我们可以在内部循环中重新定义一下范围。

```js
function betterBubbleSort(arr){
    const len = arr.length;
    for(let i = 0; i < len; ++i){
        for(let j = 0; j < len - 1 - i; ++j){
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];                
            }
        }
    }
    return arr;
}
```

冒泡排序的平均复杂度为O(n^2), 面对最好情况的时间复杂度为O(n),但是我们需要使用一个标志位来帮助我们。第一次循环标志位就没有被改变的话说明数组本来就是有序的，直接返回即可，所以时间复杂度为O(n)。

```js
function bestBubbleSort(arr){
    const len = arr.length;
    for(let i = 0; i < len; ++i){
        let flag = false;
        for(let j = 0; j < len - 1 - i; ++j){
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
                flag = true;
            }
        }
        if(flag === false){
            return arr;
        }
    }
}
```



### 选择排序

选择符合顺序的那个值放在当前范围的头部，之后当前范围的序列的左指针右移一位。就这样循环遍历该数组，最终数组将按顺序排列。

选择排序的时间复杂度最好，最差，平均都为O(n^2)。

```js
function selectSort(arr){
    // 首先我们可以缓存数组的长度
    const len = arr.length;
    // 这里非常关键，我们需要定义一个变量来存储最小的索引
    let minIndex;
    // 外层循环， i可以理解为考虑范围的下限
    for(let i = 0; i < len; ++i){
        // 初始化最小索引为当前遍历的i值，之后它会自动地逐一右移，不用去考虑之前已排好序的元素
        minIndex = i;
        // 内层循环， j可以理解为考虑范围的上限，从外层循环的索引处开始
        for(let j = i; j < len; ++j){
            // 一旦发现某个数据比最小索引处的数据还要小，说明需要排序
            if(arr[j] < arr[minIndex]){
                // 先更新当前索引为最小索引，之后继续在遍历中寻找
                // 这样的话，最小的索引一定会被找到并保存
                minIndex = j;
            }
        }
        // 循环结束后，我们只需要判断最小索引是否是初始化的当前下限索引
        // 是的话无需处理，否则需要将头部值arr[i]和最小索引值arr[minIndex]交换位置
        if(minIndex !== i){
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }
    }
    return arr;
}
```



### 插入排序

插入排序的原理是找到当前元素在它前面序列中的正确位置，这就要求当前元素之前的序列必须是有序的。正是因为这个大前提，我们可以在有序序列中从后往前做比较，安置当前元素。

插入排序的时间复杂度最好为O(n)，最差为O(n\^2)，平均为O(n^2)。

```js
function insertSort(arr){
    // 缓存数组长度
    const len = arr.length;
    // 定义一个变量存储当前考虑的元素
    let temp;
    // 外部循环遍历，注意我们应该从索引1除开始，因为第一个元素一定是有序的
    // 可以直接从第二个元素开始考虑
    for(let i = 1; i < len; ++i){
        // 循环中定义一个变量j用于帮助我们获得temp这个当前元素的位置
        // 从当前循环索引处考虑，方向是往前的
        let j = i;
        // 当前元素就是外层循环的当前遍历值
        temp = arr[i];
        // 这里使用while循环帮助我们快速寻找temp的位置
        // j > 0是边界条件，arr[j-1] > 当前值说明需要向后为其留出位置
        while(j > 0 && arr[j-1] > temp){
            // j后移一位，为temp腾出位置
            arr[j] = arr[j-1];
            // 继续往前考虑
            j--;
        }
        //最终我们一定会从while循环中获取到j就是temp的正确索引位置
        // 此时直接插入temp即可 
        arr[j] = temp;
    }
    return arr;
}
```



### 归并排序

归并排序使用的核心策略就是分治思想，也就是把一个大问题分解为若干个小问题，将每个小问题求解后再合并得到大问题的解。归并排序正是基于这种思路而被提出的，它可以被分为以下三个步骤。

- 分解子问题：将需要排序的数组对半分开，然后继续二分，最终我们会得到一系列只有一个元素的子数组。
- 求解子问题：将这些最小粒度的子数组两两合并，这里注意我们每次合并的结果必须是有序的。
- 合并子问题的解：将子问题的解，也就是稍大粒度的有序数组继续合并得到原数组规模的有序数组，从而完成归并排序。

时间复杂度O(nlog(n))。

```js
function mergeSort(arr){
    // 缓存数组长度
    const len = arr.length;
    // 讨论数组为空或者数组只有一个元素的情况，这也是递归的边界条件！
    if(len <= 1){
        return arr;
    }
    // 获得当前数组的中间位置索引，二分法的基础步骤
    const mid = Math.floor(len / 2);
    // 递归调用归并排序来排序左子数组
    const leftArr = mergeSort(arr.slice(0,mid));
    // 递归调用归并排序来排序右子数组，不需要考虑递归内部怎么实现的
    // 只需要知道按照回溯机制，我们会得到合并好的有序序列
    const rightArr = mergeSort(arr.slice(mid,len));
    // 合并两个有序数组并更新arr
    arr = mergeArr(leftArr, rightArr);
    // 一定要返回得到的arr，递归需要用到这个返回的值
    return arr;
}

// 定义一个合并有序数组的辅助函数
function mergeArr(arr1, arr2){
    // 定义两个指针，各自指向数组的首位
    let i = 0, j = 0;
    // 定义一个空数组来存储结果
    const res = [];
    // 缓存数组长度
    const len1 = arr1.length;
    const len2 = arr2.length;
    // 使用while循环判断i和j的当前范围是不是在数组中，一旦有一个超出范围，则跳出循环
    while(i < len1 && j < len2){
        // 比较两个值的大小，将小的那个插入到结果数组中
        if(arr1[i] < arr2[j]){
            res.push(arr1[i]);
            // 该索引右移
            i++;
        }else{
            // 同理
            res.push(arr2[j]);
            j++;
        }
    }
    // 最后要处理数组不等长的情况，有一个数组依然还有为遍历到的数据
    // 对于arr1更长的情况，直接将剩余的arr1数据连接到结果数组尾部即可
    // 反之，操作arr2
    // 这里，我们用到arr.concat方法和arr.slice()方法，非常高效
    if(i < len1){
        return res.concat(arr1.slice(i));
    }else{
        return res.concat(arr2.slice(j));
    }
}
```



### 快速排序

快速排序的时间复杂度由基准值决定，最好是O(nlogn)，最差是O(n^2)，平均复杂度为O(nlogn)。

```js
// 快排递归主逻辑，入参为数组、左指针索引、右指针索引，初始值为首尾索引
function quickSort(arr, left=0, right=arr.length-1){
    // 只有数组非空非单个元素才有必要使用排序算法，否则直接返回该数组
    if(arr.length > 1){
        // 调用partition辅助函数获得基准值
        const datum = partition(arr,left,right);
        // 如果左边子数组的长度不小于1，则递归快排这个子数组
        if(left < datum-1){
            quickSort(arr, left, datum-1);
        }
        // 如果右边子数组的长度不小于1，则递归快排这个子数组
        if(datum < right){
            quickSort(arr,datum,right);
        }
    }
    // 返回结果
    return arr;
}

// 定义辅助函数，寻找最新的基准值，入参也是数组、左右指针索引
function partition(arr,left,right){
    // 选择当前数组中间值作为基准值
    let datumValue = arr[Math.floor(left+(right-left)/2)];
    // 初始化左右指针
    let i = left;
    let j = right;
    // 当左右指针不越界执行循环
    while(i<=j){
        // 左指针指向的元素不大于基准值索引，则右移左指针，否则跳出循环停止移动
        while(arr[i] < datumValue){
            i++;
        }
        // 右指针指向的元素不小于基准值，则左移右指针，否则跳出循环停止移动
        while(arr[j] > datumValue){
            j--;
        }
        // 若i<j，则意味着基准值左边存在较大元素或者右边存在较小的元素
        // 交换两个元素的位置然后移动指针
        if(i<=j){
            swap(arr,i,j);
            i++;
            j--;
        }
    }
    // 返回左指针索引作为下一个基准值的索引
    return i;
}

// 定义交换元素的辅助函数
function swap(arr,i,j){
    [arr[i],arr[j]] = [arr[j],arr[i]];
}
```

## 字符串

```js
function render(template, data) {
    const reg = /\{\{(\w+)\}\}/; // 模板字符串正则
    if (reg.test(template)) { // 判断模板里是否有模板字符串
        const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段
        template = template.replace(reg, data[name]); // 将第一个模板字符串渲染
        return render(template, data); // 递归的渲染并返回渲染后的结构
    }
    return template; // 如果模板没有模板字符串直接返回
}
```

测试：

```js
let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let person = {
    name: '布兰',
    age: 12
}
render(template, person); // 我是布兰，年龄12，性别undefined
```

实战

```js
function parseParam(url) {
    const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来
    const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中
    let paramsObj = {};
    // 将 params 存到对象中
    paramsArr.forEach(param => {
        if (/=/.test(param)) { // 处理有 value 的参数
            let [key, val] = param.split('='); // 分割 key 和 value
            val = decodeURIComponent(val); // 解码
            val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字
    
            if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值
                paramsObj[key] = [].concat(paramsObj[key], val);
            } else { // 如果对象没有这个 key，创建 key 并设置值
                paramsObj[key] = val;
            }
        } else { // 处理没有 value 的参数
            paramsObj[param] = true;
        }
    })
    
   return paramsObj;
}
```



## 其它

### 数据类型判断

typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。

```diff
function mytypeOf(obj) {
-   let res = Object.prototype.toString.call(obj).split(' ')[1]
-   res = res.substring(0, res.length - 1).toLowerCase()
-   return res
// 评论区里提到的更好的写法
+   return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
}
mytypeOf([])        // 'array'
mytypeOf({})        // 'object'
mytypeOf(new Date)  // 'date'
```



# 非JS

### 深拷贝

### 原型链instanceof

```js
function myInstanceof(left, right) {
  let proto = Object.getPrototypeOf(left), // 获取对象的原型
      prototype = right.prototype; // 获取构造函数的 prototype 对象

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    proto = Object.getPrototypeOf(proto);
  }
}
```

### CSS水平和垂直居中

#### 使用line-height属性

```
.div0{
  width:200px;
  height:150px;
  border:1px solid #000;
  line-height:150px;
  text-align:center;
}
.redbox{
  display:inline-block;
  width:30px;
  height:30px;
  background:#c00;
}
```

#### 添加伪元素后用vertical-align

vertical-align这个属性，这个属性虽然是垂直居中，不过却是指在元素内的所有元素垂直位置互相居中，并不是相对于外框的高度垂直居中

所以要让一个**伪元素高为100%，撑开盒子以后来居中**

不过不过不过！div记得要把display设为inline-block，毕竟**vertical-align:middle；是针对行内元素**，div本身是block，所以必须要做更改！

```js
.div0{
  width:200px;
  height:150px;
  border:1px solid #000;
  text-align:center;
}
.redbox{
  width:30px;
  height:30px;
  background:#c00;
  display:inline-block;
  vertical-align:middle;/
}
.div0::before{
  content:'';
  width:0;
  height:100%;
  display:inline-block;
  position:relative;
  vertical-align:middle;
  background:#f00;
}
```

#### calc动态计算

用到CSS特有的calc动态计算的能力，我们只要让要居中的div的top属性，与上方的距离是“50%的外框高度+ 50%的div高度”，就可以做到垂直居中，至于为什么不用margin-top，因为margin相对的是水平宽度，必须要用top才会正确。

```
.div0{
  width:200px;
  height:150px;
  border:1px solid #000;
}
.redbox{
  width:30px;
  height:30px;
  background:#c00;
  float:left;
  top:calc(50% - 15px);
  margin-left:calc(50% - 45px);
}
```

#### transform

transform是CSS3的新属性，主要掌管元素的变形、旋转和位移，利用transform里头的translateY（改变垂直的位移，如果使用百分比为单位，则是以元素本身的长宽为基准），搭配元素本身的top属性，就可以做出垂直居中的效果，比较需要注意的地方是，子元素必须要加上position:relative，不然就会没有效果喔。

```
.use-transform{
    width:200px;
    height:200px;
    border:1px solid #000;
}
.use-transform div{
    position: relative;
    width:100px;
    height:50px;
    top:50%;
    transform:translateY(-50%);
    background:#095;
}
```

#### 绝对定位

绝对定位就是CSS里头的position:absolute，利用绝对位置来指定，但垂直居中的做法又和我们正统的绝对位置不太相同，是要**将上下左右的数值都设为0，再搭配一个margin:auto**，就可以办到垂直居中，不过要特别注意的是，设定绝对定位的子元素，其父元素的position必须要指定为relative喔！而且绝对定位的元素是会互相覆盖的，所以如果内容元素较多，可能就会有些问题。

```
.use-absolute{
    position: relative;
    width:200px;
    height:150px;
    border:1px solid #000;
}
.use-absolute div{
    position: absolute;
    width:100px;
    height:50px;
    top:0;
    right:0;
    bottom:0;
    left:0;
    margin:auto;
    background:#f60;
}
```

#### flex

```
.use-flexbox{
    display:flex;
    align-items:center;
    justify-content:center;
    width:200px;
    height:150px;
    border:1px solid #000;
}
.use-flexbox div{
    width:100px;
    height:50px;
    background:#099;
}
```



