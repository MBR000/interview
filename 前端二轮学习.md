# **清单**

> 网络、三件套、框架

## **一、HTML/CSS3 部分**

前端概念总览、vscode开发工具使用、markdown文档工具使用、浏览器平台环境、标签基础、DTD与META

语义化、选择器、权重与优先级、匹配规则、浮动与清除、BFC、类名组合规则、SEO前端技巧、定位、叠加技巧、

伪类、伪元素、盒子模型、代码规范、性能优化、渲染原理、CSS Sprites 、 iconfont字体图标、布局思路、布局定式

css3动画、 css3选择器、 css3过渡、flex布局、背景渐变、css3实用动效、3D模块、css3变量、em/rem/vw

企业内部多页面项目实战（非仿站）有完整PSD与切图

## **二、JavaScript 部分**

JavaScript概念、基础认知、发展历史、应用范围、优缺点。

### **ECMAScript**

语言概览、语句语法、数据类型、运算符、隐式转换、运算规则、控制流程、作用域、作用域链、作用域解析、js解释引擎、字符串属性方法、for of/for in

数组属性方法、对象、广义对象概念、对象特性、存储机制、深拷贝、对象实际应用、工厂模式、构造函数、原型、原型链、原型指向、封装、

多种继承、包装对象、this、this指向、js数据处理、垃圾GC、闭包原理与应用、[debug方法论](https://www.zhihu.com/search?q=debug方法论&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、浏览器控制台工具应用、面向对象开发、函数式开发、

纯函数、递归函数、[回调函数](https://www.zhihu.com/search?q=回调函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、组合函数、缓存函数、[柯里化函数](https://www.zhihu.com/search?q=柯里化函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、偏函数、函数防抖与节流、高级函数、IIFE函数、模块化、

数学对象、高级数组方法（reduce、filter、map、every、some、forEach、find、findIndex、include）等、

[高级对象方法](https://www.zhihu.com/search?q=高级对象方法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})（entires、defineProperty、freeze、fromEntries、assign、keys、create、hasOwnProperty）等

this通过bind、call、apply指向偏移、同步与异步、[闭包模块化](https://www.zhihu.com/search?q=闭包模块化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、数据形变处理、性能处理

### **DOM/BOM**

DOM对象与方法、节点与遍历树、DOM选择器、DOM节点增删改查、DOM样式操作、DOM位置获取与偏移、DOM对象与标签区别、DOM虚拟化、DOM事件、

Event对象、定时器与监听器、事件委托、事件代理、事件分流、事件冒泡、默认行为、事件捕获、防抖、节流、滚动、键盘行为、事件降频、行为锁机制、

[拖拽模组](https://www.zhihu.com/search?q=拖拽模组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、碰撞检测、距离判断、三角函数、方向判断、运动框架、弹性运动、重力加速度、DOM树、CSSOM树、渲染解析、加载、回流、重绘、浏览器线程与阻塞。

BOM深入、window对象、navigator、history、screen、location、spa概念、本地传参、日期对象使用、日期格式化封装、随机封装、DOM分片容器

### **JS业务应用扩展**

JSON对象、数据解析、JSON方法、模板渲染、缓存懒加载、正则表达式RegExp、元字符、修饰符、正向预查、贪婪模式、[replace方法](https://www.zhihu.com/search?q=replace方法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、分组与不分组、test、match与exec

正则库封装、表单校验、图片预存懒加载、自定义封装滚动组件、多重轮播（循环、视差、旋转木马）、选项卡切换、楼梯导航、吸顶导航、拖拽导航 、

JavaScript编码风格指南、console应用技巧

### **ECMAScript5 --- ECMAScript9扩展**

版本解读、应用环境、let、const、解构赋值、箭头函数、对象解构、reset参数解构、class、set、get、extends、super、static、private实现、symbol、promise、proxy代理拦截、async/await

对象新增API、数组新增API、字符串新增API、原型属性、对象修饰、代理拦截、链式询问、空值合并运算符、泡泡龙面向对象游戏开发



## **三、HTML5 / 移动端开发 部分**

### **HTML5标签与API**

HTML5概念、定义、新增特性、DTD对比、新增H5标签、新增语义化H5标签、H5表单

H5拖拽事件 video、audio、fullScreen、FileReader文件流、Blob对象、sessionStorage、localStorage、

网络状态、页面生命周期、网页状态监听、地理信息与定位、canvas画布、[worker多线程](https://www.zhihu.com/search?q=worker多线程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})、Notifications桌面通知

播放器开发 canvas交互特效开发

移动端适配/事件

移动端适配概念、尺寸与分辨率原理、PPI与DPI计算、DIP与DPR设备像素概念、视口viewport概念、布局视口、视觉视口、理想视口

视口适配方案（Meta viewport）缩放设置 、screen窗口大小API、媒体查询@media、rem适配、vw vh适配

移动端适配方案、flexible rem方案、 vh vw方案 、复合方案、高清适配方案、移动端字体缩放解决、1px边框问题解决、半像素线

图片高清适配、image-set、srcset、js拼接URL技巧、IPhonex刘海屏适配、安全区域、fit与env

Meta权限管理、兼容优化、IOS头部底部闪屏回退输入框问题、输入法空格问题、默认首字母大写问题、滑动卡顿问题等

终端样式美化与访问判断

Touch事件组封装、click延迟处理、FastClick使用、禁用缩放设置理想视口

### **常用类库/工具**

jquery: 元素选择、增删改差、事件处理、位置获取、动画过渡、高级方法、特效应用

zepto：移动端的jquery、DOM操作、移动端事件、click延迟处理、[touch事件组](https://www.zhihu.com/search?q=touch事件组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})

基础UI库: layerUI 、easyUI、bootStrap、UI模块化、UI库使用技巧、文档解读、案例调试、表单系统

iScroll、[touchjs](https://www.zhihu.com/search?q=touchjs&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})等移动端事件库使用

swiper：移动端网站触摸滑动、轮播图插件、模块化应用、源码解读

art-template: 模板引擎 模板语法、渲染方法、原生模板引擎实现

CSS预处理：sass、less使用 stylus深入学习 、预处理语法、css编程、 Minxin 、预处理函数、继承、嵌套

vscode高级插件与配置 liveserver sass 

模板化应用 、预处理应用

### **date-picker移动端原生组件开发**

需求分析、业务规则、技术栈选型、文件输出规则、技术分析

MVC模型概念与设计、业务逻辑分类

view层适配方案 原型布局搭建 模板化生成

[工具函数](https://www.zhihu.com/search?q=工具函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"364494893"})开发、面向对象式业务设计 功能类日期对象开发

交互业务封装 模块对接 优化设计 面向对象高级程序设计 

## **四、Nodejs与工程化开发 部分**

### **Node原生基础**

Node基础概念、NPM命令、V8引擎概念、JavaScript模块化 CMD AMD UMD、EventLoop事件循环、同步异步、 阻塞非阻塞 、任务队列、宏任务、微任务、

原生Node模块、核心模块与require、module、触发器events与path模块、fs模块、Buffer对象、URL模块、HTTP模块 、stream流

Node原生封装HTTP与文件服务器

### **Node框架**

express框架使用、中间件、核心对象、路由配置、模板引擎、数据脚本、Router核心、CORS配置、错误处理、校验封装、PM2管理、nodemoon管理

MORGAN日志处理、查询正则捕获、中间件开发、bodyParse等第三方中间件使用 、文件流上传下载、文件流切分

### **webpack工程化构建**

工程化概念、工程化工具介绍、webpack基础知识、webpack配置与运行、plugin插件、loader使用、入口出口配置、模块modules、依赖处理、dev Server

target 、文件切分、build打包、热处理、package管理、性能优化、测试处理 、第三方插件使用、babel等

### **前后端数据交互**

HTTP通信交互原理、请求响应、MIME、URI地址、报文解析、端口、报文流、测试监听抓包、TCP/IP握手机制、网络业务模型

代理、缓存、网关、隧道等概念、method与请求头分类

基础XMLHTTPRequest对象方法属性、方法、ajax异步交互 、同源策略原理

原生js封装ajax交互、 jquery的ajax封装交互、jsonp跨域处理、cors跨域处理、携带cookie与跨域处理、代理服务器跨域处理、

cookie验证与通信 、axios库的使用 代理、封装、拦截、合并、二次封装

通信加密策略、数据对称加密、数据非对称加密、RSA加密实践、MD5加密实践

登录注册与鉴权机制、Authenticity认证、Token认证、JWT认证、session状态管理、 oauth认证

### **RESTful接口设计**

RESTful设计原则、状态码设计与规范、服务器响应规则与格式、前后端接口协议制定、传统RESTful改进

API设计规范、 资源定位、JSON模式、合约说明、资源标识符、缓存友好API、HTTP头管理、文档定义、松耦合原则、一致性、重用、稳定性原则

### **数据库存储**

MongoDB基础概念、NoSQL与SQL、CAP定理、RDBMS、MongoDB语法、指令、监控与GUI、MongoDb驱动、Mongoose应用

数据库创建、集合增删改查、文档增删改查、数据库查询、高级查询操作、通道查询、多条件查询、反向筛选、索引处理、aggregate聚合管道、

validation验证、population联表、middleware中间件处理、查询ERROR类二次封装

### **博客后台项目实战**

数据库设计、服务端路由搭建、接口设计与API管理、通信交互管道封装、注册登录、路由导航、前端路由管理、权限管理、用户管理、分类管理、标签管理

、文章管理、模块化功能封装、校验库封装、promise链式行为封装、

异步模块处理、SPA单页面应用初级实现、原生集中行为控制器、模板化+模块化+预处理+工程化实现前端页面

### **组件化封装**

组件化基础概念、组件设计原则、组件封装、组件耦合与解耦、工程化+模板化+模块化实现原生组件化功能、

## 五、Vue框架部分

### **vue基础**

vue开发准备、工具与插件、mvc mvp mvvm设计理念、原生js实现MVVM核心框架、vue设计模式、生命周期、命令与属性、组件化

数据驱动与双向绑定、虚拟DOM概念原理、模板语法、条件与列表、数组监测、计算属性、事件处理、修饰与表单、监听器、过滤器、

methods watch computed filter对比、组件化开发、动态组件、组件通信、高级组件通信、插槽、vue动画 、实例对象、set、get、nextTick、vue插件

### **vue工程化**

Babel、webpack配置vue、vue单文件组件、vue-cli、工程平台处理、postCss、animate、core、socket、lodash工具、vue-cli插件、preset、静态资源处理、

环境变量与膜还是切换、工程化部署、工程构建

### **vue Router**

vue路由概念、嵌套路由、路由视图、动态路由、路由匹配、编程式导航、history、hash模式管理、命名视图、重定向与别名、导航守卫、路由元信息、滚动与懒加载、导航故障处理

### **vuex**

vuex核心概念、EventBus对比、状态管理模式、Store、state、getter、mutation、action、moudule

vuex辅助函数与API功能、vuex环境选择、vuex模块化处理规则与技巧、对象风格提交方式、模块重用等

### **vue项目实战**

vue博客项目实战 PC + 移动端、 elementUI、vantUI、websocket聊天室、虚拟人偶、vueScroll、store、qs、nprogress、editor、

文章分类、词云效果、spa单页面应用、移动PC无缝切换、完整注册登录、vue加密鉴权、http封装管理、错误处理封装、vuex核心状态管理、本地存储状态更新、令牌处理、

文章富文本编辑、点赞、收藏、访问、评论、组件封装、组件复用、组件混合、高级组件开发、复合性组件通信、vue中处理原生DOM行为、vue常见错误处理、

重置vue数据响应、个人信息修改、头像上传、通知组件封装、postcss应用、项目打包优化

能够把这些知识点掌握，你就是一名优秀的前端工程师了。

# 学习

## CSS

### 基础知识

CSS——层叠(Cascading)样式表

> 层叠意在解决样式表中声明之间的冲突，根据层叠规则决定谁生效

#### 优先度影响

- 样式表来源

  - 用户代理样式表中的！important
  - 用户样式表中的！important
  - 作者样式表中的！important
  - **作者样式表（developer写的）**
  - 用户样式表（很少有）
  - 用户代理样式（浏览器默认样式）

- 选择器（来自作者样式表）优先级

  > 内联 > id > class pseudo-class(伪类) > type(类型) pseudo-element(伪元素) 

  - #id一一lD选择器。Tagname一一类型选择器或者标签选择器。
  - .class一一类选择器。*一一通用选择器。该选择器匹配所有元素
  - 子组合器(>)一一匹配的目标元素是其他元素的直接后代。如：parent>.child。
  - 相邻兄弟组合器(+)一一匹配的目标元素紧跟在其他元素后面。如：p+h2。
  - 通用兄弟组合器(\~)一一匹配所有跟随在指定元素之后的兄弟元素，如：i.active~i。
  - 类型选择器——约束属性值，如div
  - 伪类选择器——选中处于某个特定状态或相对于其父级或兄弟元素的位置的元素。如：first-child, :hover
  - 伪元素选择器——匹配在文档中没有直接对应HTML元素的特定部分，或插入内容。如h2:first-letter, div:before
  - 伪类函数选择器——is() has() where() not()

- 源码位置

#### 盒模型

实现三角形——border-bottom

实现固定比例矩形——padding（默认基于宽度的百分比）

实现水平居中——margin:auto

实现渐变边框——background-clip background-origin background-image

负margin

### 布局和定位

任意一个盒子都有display-outside，代表它如何与同一格式上下文的其它元素一起显示，以及display-inside，规定盒子内部的布局方式。

比如display:flex，其外部显示是block，参与BFC。display:inline-flex，则外部显示是inline，参与lFC。他们内部的盒子都参与flex弹性盒子布局。

#### Normal Flow常规流

包括块级格式化上下文和内联格式化上下文

常规流的外部显示形式只可能是block（生成BFC）或者inline（生成IFC，但是浏览器给外面自动包了一层匿名的BFC）当中的一种。

> BFC本身是block formatting context的缩写，是一种格式规范。目前常说的BFC是一个盒子是BFC或者有BFC特性，那么表示的是block formatting context root。不管它外部显示类型是什么，但是它的内部显示类型是Iow-root，其实就是这个盒子内部形成了一个新的块级格式化上下文。

**BFC的触发**

display：flow-root 、 inline-block;
position：absolute fixed;
float：不为none;
overflow：不为visible

**BFC清理塌陷**

- 在两个相邻的上下边距之间增加border、padding或者内联元素，使之不相邻

- 在父子元素重叠时，除了上述方法，还可以设置父元素为BFC,使得父子不在同级BFC中

**内联格式化上下文**

linebox，即文字的展示部分，是由文字自己撑起来的，被叫做线条框。有两个高度，一是liline的高度叫line-height，二是content-area的高度。lineheight会减去content-area的高度，这个差叫做leading，然后均分到上下，作为一个间隔。另外，如果是inline-block，那就是margin-box的高度作为这个inline的高度。

vertical-align控制content-area在inline当中的位置。比如vertical-align：middle。当然，也可以直接用lineheight来做调整。

#### Positioning定位流

**relative**

元素相对于自己原来在文档流中的位置进行定位，但是原来文档流的空间还在。

**absolute**

元素被移出正常文档流，且没有预留空间，相对于最近的非 static定位祖先元素的进行定位。

**fixed**

元素被移出正常文档流，且没有预留空间，相对于屏幕视口进行定位，屏幕滚动也不会改变位置

**sticky**

元素相对它的最近滚动祖先（祖先的overflow:是 scroll/hidden/.auto)的视口(scrollport)定位

#### Flex弹性盒子布局

**父元素上的属性**

display:flex justify-contnent align-items

**子元素上的属性**

flex-shrink

### 层叠上下文(The Stacking Context)

即给css增加了三维结构，沿着虚拟的z轴排开。

一个层叠上下文对应浏览器渲染时一个render-layer

**形成层叠上下文**（任一即可)：

position：relative或absolute。并且z-index不是auto
position：fixed sticky
flex或grid的子元素。并且z-index不是auto
opacity的值小于1
transform的值不为none
wil-change的值不为通用值

**层叠规则**：对层叠水平排序

在一个层叠上下文里【根元素和边框——zindex<0——非postioned且不形成新stack content的元素（比如内容）——形成新stack content的元素——zindex>0】

对多个层叠上下文，主要比较这些同一级之间的顺序，它们各自的子元素不能超过父元素的判定规则

### 变形、过渡、动画

**transform变形**

**transition过渡：**

通过指定某些元素属性从一种起始状态，在一段时间内以某种变化节奏，过渡到终止状态

```
transition:<property><duration><timing-function><delay>;
```

其中timing-function一般有三种用法：线性((linear))、贝塞尔曲线(cubic-bezier(0或ease-in等)、阶跃(step)

**animation动画**

transition只有初始终止，但是animation就有更多的中间状态

主要写@keyframes、animation-xxx

**性能相关**

布局——绘制——合成

> transform：3D，会导致硬件加速，就会提升性能

如何写动画性能更好？ 

1.尽量不用触发reflow的属性  

2.在遇到性能问题时可以触发硬件加速，【比如设置will-change属性、设置transform3d等】 

3.尽量使用transform和opacity去写动画【因为只改合成层】

### 响应式设计

优先选用流式布局，如百分比、flex、gid等
使用响应式图片，匹配尺寸，节省带宽
使用媒体查询为不同的设备类型做适配
给移动端设备设置简单、统一的视口
使用相对长度，em、rem、w做为长度度量

#### 媒体查询

媒体查询允许某些样式只在页面满足特定条件时才生效。我们可以将媒体类型（如screen、pit)以及媒体特性（如视口宽度、屏幕比例、设备方向：横向或纵向)做为约束条件。

1.媒体查询同样遵循cascading.层叠覆盖原则，min-和max-选择一个
2.由于设备的多样化逐渐不可枚举，断点的选择尽量根据内容选择
3.由于断点的增加会增加样式处理的复杂度，所以尽量减少断点

#### 移动端的viewport

可以用meta标签中的属性限制

常见的设置：

- 保持scale为1
- 保持scale为1/dpr

#### 相对长度

em：在非font-size上使用，是相对自身的字体大小

rem：是根元素的字体大小。一般通过js进行缩放，做响应式布局

vw和vh：视窗高的1%和宽的1%。不用js维护

### CSS生态相关

预处理器：SCSS、lsss、stylus

后处理器：对css文件进行压缩，处理浏览器兼容性等等。比如postcss-loader、css-loader、style-loader

CSS模块化：解决全局污染的问题。vue：scoped、CSSModules

css in js：

原子化CSS

## JS运行机制最全面的梳理

### 浏览器是多进程的

#### 浏览器都包含哪些进程？

1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有
   - 负责**浏览器界面显示**，与用户交互。如前进，后退、收藏夹等
   - 负责各个页面的管理，创建和销毁其他进程
   - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
2. **浏览器渲染进程（浏览器内核）**（Renderer进程，内部是多线程的）：**每个Tab页面一个进程，在浏览器中打开一个网页相当于新起了一个进程**。主要作用为
   - 页面渲染，脚本执行，事件处理等
3. GPU进程：最多一个，用于3D绘制等

#### 多进程的优势

简单点理解：**如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。**

当然，内存等资源消耗也会更大，有点空间换时间的意思。

#### 重点——浏览器内核渲染进程

对于普通的前端操作来说，最重要的是什么呢？答案是**渲染进程**。可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。**请牢记，浏览器的渲染进程是多线程的**

GUI渲染线程

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
- 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。

JS引擎线程

- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
- JS引擎线程负责解析Javascript脚本，运行代码。
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
- 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

事件触发线程（后续将提到的事件循环机制就基于它）

- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

定时触发器线程

- 传说中的`setInterval`与`setTimeout`所在线程
- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

**网络资源的下载线程**

#### Browser进程和浏览器内核（Renderer进程）的通信过程

Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程

Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染

- GUI渲染线程接收请求，加载网页并渲染网页。这其中可能需要下载进程获取资源和需要GPU进程来帮助渲染
- 其中可能会有JS线程操作DOM（这样可能会造成回流并重绘）
- 最后Render进程将结果传递给Browser进程

Browser进程接收到结果并将结果绘制出来



### 梳理Render中线程之间的关系

#### GUI渲染线程与JS引擎线程互斥

由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

#### JS阻塞页面加载

从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。

譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。

所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

#### WebWorker，JS的多线程？

JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？

所以，后来HTML5中支持了`Web Worker`。

MDN的官方解释是：

>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面


这样理解下：

- 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!



### 浏览器输入url后发生了什么

为了简化理解，前期工作相对省略

```js
- 浏览器输入url，浏览器主进程接管，UI线程会判断输入的是一个URL地址呢，还是一个quey查询条件
- 如果是URL地址，进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容。如果是quey,将输入发送给搜索引擎
- 网络线程接收到HTTP响应后，先检查响应头的媒体类型。如果响应主体是一个HTML文件，浏览器将内容交给渲染进程处理。如果拿到的是其他类型文件，比如Zip、 exe等，则交给下载管理器处理
- 网络线程做完所有检查后，会告知主进程数据已准备完毕。主进程确认后为这个站点寻找一个渲染进程主进程，告知渲染进程去处理。
- 将内容通过RendererHost接口转交给Renderer进程，浏览器渲染流程开始。
```

浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

```
1. 解析html建立dom树
2. 解析css构建cssom树
3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各个图层合成（composite），显示在屏幕上。
```



所有详细步骤都已经略去，渲染完毕后就是`load`事件了，之后就是自己的JS逻辑处理了

#### load事件与DOMContentLoaded事件的先后

- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)
- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）

所以，顺序是：`DOMContentLoaded -> load`

#### css加载是否会阻塞dom树渲染？

- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

#### 普通图层和复合图层

渲染步骤中就提到了`composite`概念，即最后由GPU进行合成。

可以简单的这样理解，浏览器渲染的图层一般包含两大类：`普通图层`以及`复合图层`

首先，普通文档流内可以理解为一个复合图层（这里称为`默认复合层`，里面不管添加多少元素，其实都是在同一个复合图层中。absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于`默认复合层`。

然后，可以通过`硬件加速`的方式，声明一个`新的复合图层`，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响`默认复合层`里的回流重绘）

可以简单理解下：**GPU中，各个复合图层是单独绘制的，所以互不影响**

将元素变成一个复合图层，就是传说中的**硬件加速技术**。一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡

- 最常用的方式：`translate3d`、`translateZ`
- `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
- `<video><iframe><canvas><webgl>`等元素



### 性能优化

**首屏优化**

1.压缩、分包、删除无用代码
2.静态资源分离
3.JS脚本非阻塞加载
4.缓存策略
5.SSR
6.预置loading、骨架屏

**渲染优化**

1.GPU加速
2.减少回流、重绘【多用visibility，永远不要table布局】
3.离屏渲染【canvas需要】
4.懒加载

**JS优化**

1.防止内存泄漏
2.循环尽早break
3.合理使用闭包
4.减少Dom访问
5.防抖、节流
6.Web Workers

### 从Event Loop谈JS的运行机制

- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个`执行栈`
- 主线程之外，**事件触发线程**管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。
- 一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取`任务队列`，将可运行的异步任务添加到可执行栈中，开始执行。

#### 单独说说定时器

事件循环机制的核心是：**JS引擎线程**和**事件触发线程**

但事件上，里面还有一些隐藏细节，当使用`setTimeout`或`setInterval`时，它需要**定时器线程**计时，计时完成后就会将特定的事件推入事件队列中。

### 事件循环进阶：macrotask与microtask

JS中分为两种任务类型：**`macrotask`和`microtask`**

- macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
  - 每一个task会从头到尾将这个任务执行完毕，不会执行其它
  - 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （`task->渲染->task->...`）
- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务
  - 也就是说，在当前task任务后，下一个task之前，在渲染之前
  - 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
  - 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

**补充：在node环境下，process.nextTick的优先级高于Promise**，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。

根据线程来理解下：

- macrotask中的事件都是放在一个事件队列中的，而这个队列由**事件触发线程**维护
- microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由**JS引擎线程维护** （这点由自己理解+推测得出，因为它是在主线程下无缝执行的）

所以，总结下运行机制：

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

## JS

**let const var**

- 变量提升
- 暂时性死区
- 块级作用域
- 重复声明
- 修改声明的变量

**作用域**

——静态作用域【块级、函数、全局】

**变量提升**

JS不是纯解释型语言，变量提升说明了JS也有编译

var有变量提升
let、const没有变量提升，提前访问会报错
function函数可以先调用再定义
赋值给变量的函数无法提前调用

**JS的上下文**

全局执行上下文：代码开始执行时就会创健，将他压缺行栈的栈底，每个生命周期内只有一份

函数执行上下文：当执行一个函数时，这个函数内的代码会被编译，生成变量环境、词法环境等，当函数执行结束的时候该执行环境从栈顶弹出

创建上下文——【绑定this、创建词法环境、创建变量环境】

> 词法环境：func let const
>
> 变量环境：var
>
> Outer：指向外部变量环境的一个指针，用于原型链

执行上下文执行完了会弹出栈，物理上是用覆盖的方式，实现栈上面的回收。用ESP指针指示当前处于哪个执行上下文。

**闭包**

```
function showName (){
	const name ='zq';
	const dep='边缘云'；
	return function (){
		console.log(dep)
		return name
	}
}	
const getName = showName()
console.log(getName())

//边缘云
//zq
```

其实本质就是未被回收的对象

**this**

普通函数

1.this指向windows

函数调用：

1.对象调用指向对象
2.先赋值再调用，看调用的地方

构造函数：

1.创建临时对象
2.将this指向临时对象
3.执行构造函数
4.返回临时对象

**垃圾回收**

栈的回收就是esp指针谈到下一个，上面的就是无效内存，之后被覆盖掉

堆分成新生代空间和老生代空间。

一般新出来的都在新生代空间里，除非特别大。新生代空间被分成对象区域和空闲区域，对象区满了以后做垃圾标记，把活跃的丢给空闲区，然后对象区域和空闲区域反转。再清空新的空闲区。

老生代当中的来源——特别大的，以及新生代两轮过后都不回收掉的。自己有标记标准，把需要清理的给清除掉。之后把碎片做整理变为连续的。

> 注意：清除老生代的时候，js会停顿等待，所以要一点点进行

## TS

### 基础类型

boolean、number、string
枚举enum
any、unknown、void
never
数组类型[]
元组类型tuple

**函数类型**：定义函数类型时要定义输入参数类型和输出类型

**Interface**：为了定义对象类型

**class：**增加了public、private、protected。可以implement interface来做限制

### 高级类型

&交叉类型：产生一个包含所有属性的新类型。 

|联合类型：产生一个包含所有类型的选择集类型。

类型断言：让 TypeScript 编译器将变量当做指定的类型，而不管它实际的类型

> 有尖括号、as两种方式

**类型别名（type vs interface）**

相同点：
1.都可以定义对象或函数
2.都允许继承

差异点：
1.interface:是TS用来定义对象，type是用来定义别名方便使用；
2.type可以定义基本类型，interface不行；
3.interface可以合并重复声明，type不行；

### 泛型

1.泛型的语法是<>里面写类型参数，一般用T表示；

2.使用时有两种方法指定类型：定义要使用的类型；通过TS类型推断，自动推导类型

3.泛型的作用是临时占位，之后通过传来的类型进行推导；

## Canvas

### 基础操作

### 绘图

普通渲染的语法：

```js
drawImage(image, dx, dy, dw, dh)
```

- `image`: 要渲染的图片对象。
- `dx`: 图片左上角的横坐标位置。
- `dy`: 图片左上角的纵坐标位置。
- `dw` 用来定义图片的宽
- `dh` 定义图片的高度。

截图图片同样使用`drawImage()` 方法，只不过传入的参数数量比之前都多，而且顺序也有点不一样了。

```js
drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)
```

- `image`: 图片对象
- `sx`: 开始截取的横坐标
- `sy`: 开始截取的纵坐标
- `sw`: 截取的宽度
- `sh`: 截取的高度
- `dx`: 图片左上角的横坐标位置
- `dy`: 图片左上角的纵坐标位置
- `dw`: 图片宽度
- `dh`: 图片高度

### 下载保存

一般的解决方案：保存成blob然后用a标签的download下载

```js
mycanvas.toBlob(blob => {
    // 获取当前时间并转成字符串，用来当做文件名
    const date = Date.now().toString()
    // 创建一个 a 标签
    const a = document.createElement('a')
    // 设置 a 标签的下载文件名
    a.download = `${date}.png`
    // 设置 a 标签的跳转路径为 文件流地址
    a.href = URL.createObjectURL(blob)
    // 手动触发 a 标签的点击事件
    a.click()
    // 移除 a 标签
    a.remove()
})
```

canvas提供了两个2D转换为图片的方法：`canvas.toDataURL()`和canvas.toBlob()

##### canvas.toDataURL()方法

`canvas.toDataURL(mimeType, qualityArgument)`
 可以把图片转换成`base64`格式信息，纯字符的图片表示法。
 `mimeType`表示canvas导出来的`base64`图片的类型，默认是`png`格式，也即是默认值是`'image/png'`，我们也可以指定为`jpg`格式`'image/jpeg'`或者`webp`等格式。`file`对象中的`file.type`就是文件的`mimeType`类型，在转换时候正好可以直接拿来用（如果有file对象）。

##### canvas.toBlob()方法

`canvas.toBlob(callback, mimeType, qualityArgument)`
 这个方法相比之前的方法的好处是`异步`，所以有一个`callback`回调。这个`callback`回调方法默认的第一个参数就是转换好的blob文件信息

### Blob和转换

#### 介绍

**ArrayBuffer**

- 固定长度
- 二进制数据
- 不可以直接操作，而是要通过 TypeArray 或 DataView 来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。

TypedArray中的Uint8Array。可以把Uint8Array想象成一个数组,但是里面的每个元素只占一个字节。Uint16Array里的每个元素占两个字节

你可以像创建ArrayBuffer一样创建一个Uint8Array

```js
const uint8Array= new Uint8Array(length);
```

**blob(binary large object)**

- 不可变、原始数据的类文件对象
- 二进制的容器
- 和冗长的Base64格式的Data URL相比，Blob URL的长度显然不能够存储足够的信息，这也就意味着它只是类似于一个浏览器内部的“引用“。

```javascript
const blob = new Blob( array, options );
```

**Blob实现下载文件**

我们可以通过window.URL.createObjectURL，接收一个Blob（File）对象，将其转化为Blob URL,然后赋给 a.download属性，然后在页面上点击这个链接就可以实现下载了

```
var blob = new Blob(["Hello World"]);
var url = window.URL.createObjectURL(blob);
var a = document.getElementById("h");
a.download = "helloworld.txt";
a.href = url;
```

##### Blob实现图片本地显示

window.URL.createObjectURL生成的Blob URL还可以赋给img.src，从而实现图片的显示

对比发现，ArrayBuffer的数据，是可以按照字节去操作的，而Blob的只能作为一个整的对象去处理。所以说，ArrayBuffer相比Blob更接近真实的二进制，更底层。

##### Blob实现文件分片上传

通过Blob.slice(start,end)可以分割大Blob为多个小Blob

xhr.send是可以直接发送Blob对象的

```
//前端
function upload(blob) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/ajax', true);
    xhr.setRequestHeader('Content-Type', 'text/plain')
    xhr.send(blob);
}

document.getElementById('f').addEventListener('change', function (e) {
    var blob = this.files[0];
    const CHUNK_SIZE = 20; .
    const SIZE = blob.size;
    var start = 0;
    var end = CHUNK_SIZE;
    while (start < SIZE) {
        upload(blob.slice(start, end));
        start = end;
        end = start + CHUNK_SIZE;
    }
}, false);

//koa后端
app.use(async (ctx, next) => {
    await next();
    if (ctx.path === '/ajax') {
        const req = ctx.req;
        const body = await parse(req);
        ctx.status = 200;
        console.log(body);
        console.log('---------------');
    }
});
```



## 跨端、适配

### 数据大屏

> 设备长宽比不同

对于数据大屏适配，常见的方案无外乎一下 3 种，优缺点呢也比较明显

| 方案            | 实现方式                                                     | 优点                                                         | 缺点                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **vw， vh**     | 按照设计稿的尺寸，将`px`按比例计算转为`vw`和`vh`             | 1.可以动态计算图表的宽高，字体等，灵活性较高  2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况 | 1.需要编写公共转换函数，为每个图表都单独做字体、间距、位移的适配，比较麻烦 |
| **scale**       | 通过 `scale` 属性，根据屏幕大小，对图表进行整体的等比缩放    | 1.代码量少，适配简单  2.一次处理后不需要在各个图表中再去单独适配 | 1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况   2.当缩放比例过大时候，字体和图片会有一点点失真. 3.当缩放比例过大时候，事件热区会偏移。 |
| **rem + vw vh** | 1.获得 rem 的基准值 2.动态的计算`html根元素的font-size`  3.图表中通过 vw vh 动态计算字体、间距、位移等 | 1.布局的自适应代码量少，适配简单                             | 1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.图表需要单个做字体、间距、位移的适配 |

这 3 种方案中，最简单的也最容易抽离的当属 `scale` 方案了。

它优点是：

1. 代码量少，编写公共组件，套用即可，可以做到一次编写，任何地方可用，无需重复编写。
2. 使用 `flex` `grid` **百分比** 还有 `position` 定位或者完全按照设计稿的 `px` 单位进行布局，都可以，不需要考虑单位使用失误导致适配不完全。实现数据大屏在任何分辨率的电脑上均可安然运作。

至于说缺点：

1. 比例不一样的时候，会存在留白，开发大屏基本上都是为对应分辨率专门开发，我觉得这个缺点可以基本忽略，因为我们可以将背景色设置为大屏的基础色，这样留白部分不是太大基本没影响啦

> 关于**失真**，**失真** 是在你设置的 **分辨率比例** 与 **屏幕分辨率比例** 不同的情况下，依然采用 **铺满全屏** 出现 **拉伸** 的时候，才会出现，正常是不会出现的。

`scale` 方案是通过 css 的 transform 的 scale 属性来进行一个 **等比例缩放** 来实现屏幕适配的。

设设计稿的 **宽高比** 为 **1**，则在任意显示屏中，只要展示内容的容器的 **宽高比** 也是 **1**，则二者为 **1：1** 只要 **等比缩放/放大** 就可以做到完美展示并且没有任何白边。如果宽高比大于 1，此时宽度过长，计算时基准值采用高度，计算出维持 1 宽高比的宽度。宽高比小于 1，此时高度过长，计算时基准值采用宽度，计算出维持 1 宽高比的高度。

```js
const el = document.querySelector('#xxx')
// * 需保持的比例
const baseProportion = parseFloat((width / height).toFixed(5))
// * 当前屏幕宽高比
const currentRate = parseFloat((window.innerWidth / window.innerHeight).toFixed(5))

const scale = {
  widthRatio: 1,
  heightRatio: 1,
}

// 宽高比大，宽度过长
if(currentRate > baseProportion) {
  // 求出维持比例需要的宽度，进行计算得出宽度对应比例
  scale.widthRatio = parseFloat(((window.innerHeight * baseProportion) / baseWidth).toFixed(5))
  // 得出高度对应比例
  scale.heightRatio = parseFloat((window.innerHeight / baseHeight).toFixed(5))
}
// 宽高比小，高度过长
else {
  // 求出维持比例需要的高度，进行计算得出高度对应比例
  scale.heightRatio = parseFloat(((window.innerWidth / baseProportion) / baseHeight).toFixed(5))
  // 得出宽度比例
  scale.widthRatio = parseFloat((window.innerWidth / baseWidth).toFixed(5))
}

// 设置等比缩放或者放大
el.style.transform = `scale(${scale.widthRatio}, ${scale.heightRatio})`
```

如果涉及到地图点击 好像会产生偏移

### 移动设备

> 屏幕宽度过低、宽度不同

#### rem

现在比较成熟和流行的方案有淘宝的flexible.js

rem是根据根元素（也就是html标签）上的font-size来决定的。放弃px单位，使用rem作为单位，这样在不同尺寸的设备上，通过修改根节点的`font-size`大小，实现缩放。当然，由于限制了元素的最大最小宽度，所以布局在极端情况下并不是成百分比比例的。这种对极端情况的感知需要动态修改，比如媒体查询、js动态修改。

动态修改第一种方法是通过媒体查询来修改：

```
@media screen and (min-width: 750px) {
  html {
    font-size: 50px;
  }
```

动态修改第二种方法是通过js来动态修改：

```
var deviceWidth = document.documentElement.clientWidth || window.innerWidth; //兼容多浏览器

  //限制宽度
  if(deviceWidth >= 750){
    deviceWidth = 750
  }
  if(deviceWidth <= 320){
    deviceWidth = 320
  }
```

#### vw/vh

有了vw我们完全可以绕过rem这个中介了，两种方案是等价的，可以看到vw比rem更简单，毕竟rem是为了实现vw么。

vw —— 视口宽度的 1/100；vh —— 视口高度的 1/100

#### 最好的弹性布局方案

rem+js方案

### 跨端容器

**通用原理**

1.UI组件
2.渲染引擎
3.逻辑控制引擎
4.通信桥梁
5.底层API抹平表现差异

![image-20230424125730660](../AppData/Roaming/Typora/typora-user-images/image-20230424125730660.png)

**webview**

1.一次开发，处处使用，学习成本低
2.随时发布，即时更新，不用下载安装包
3.移动设备性能不断提升，性能有保障
4.通过JSBridge和原生系统交互，实现复杂功能

**小程序**

内置的webview【渲染层和逻辑层分开，多webview架构，数据通信通过native转发】

**React Native/WeeX**

1.原生组件渲染
2.React/Vue框架
3.virtual dom
4.JSBridge



## 计算机网络

### http状态码

#### 基本

1信息

2成功

3重定向

4客户端错误

5服务器错误

#### 常用

101 切换协议。一般用websocket的时候见到

200 OK
请求成功。一般用于GET与POST请求

301 Moved Permanently
永久性重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替

302 Found
临时性重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

304 Not Modified
未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

401 Unauthorized
请求要求用户的身份认证，通过HTTP认证（BASIC认证，DIGEST认证）的认证信息，若之前已进行过一次请求，则表示用户认证失败

403 Forbidden
服务器理解请求客户端的请求，但是拒绝执行此请求

404 Not Found
服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面。也可以在服务器拒绝请求且不想说明理由时使用

503 Service Unavailable
由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

### http1、2、3

`HTTP 1.0` 

- 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个`TCP`连接。服务器完成请求处理后立即断开`TCP`连接，服务器不跟踪每个客户也不记录过去的请求【TCP连接-TLS连接-HTTP交易，是一个漫长的4RTT。如果要下载资源，又是4RTT】

`HTTP1.1`——解决tcp重连

- **默认长连接**（`Connection: keep-alive`），即在一个TCP连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟

>队头阻塞：单个包传输掉了，或者花费的时间很大，阻止后续的包传输
>
>http1.1的办法是建立多个tcp连接。这就是在多个域名上“分片”（sharding）资源的实践和 CDN 的由来

`http2`——解决队头堵塞

- **二进制分帧——http2的基石**。HTTP/2 有了帧，处理协议的程序就能预先知道会收到什么，并且 HTTP/2 有表示帧长度的字段。而 HTTP/1.1 是以文本分隔的，不会进一步区分单个（大块）资源与其他资源，完成之前不能停止解析，并且无法预判解析需要多少内存。
- **多路复用，解决队头阻塞。**客户端和服务器把 HTTP 消息分解成多个帧，然后乱序发送，最后在另一端再根据流 ID 重新组合起来。HEADERS 帧会启动新的流。HTTP/2 中有“优先级（prioritization）”系统，决定各个流的快慢。
- **首部压缩**。在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送
- **服务器推送**。服务器会主动把一些客户端可能需要的资源，比如静态资源，随同请求的其它资源一起推送到客户端

`HTTP3`——解决https太慢

形成了 IP / UDP / QUIC / HTTP 的创新架构。**QUIC 协议**具有类似 TCP 的特性，还完全集成了TLS。它具有 0-RTT 连接建立特性。

页面的整体加载时间 = TLS 1.3连接时间 + HTTP交易时间 = 1RTT + 1RTT = 2 RTT 

重连页面的加载时间 = HTTP交易时间 = 1 RTT 

### https

**HTTP 的缺点**——明文

【窃听、身份、完整】

为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上即是https

> TLS = 身份验证 + 加解密

**SSL三次握手**

- 首先客户端通过URL访问服务器建立SSL连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书是公钥的载体）传送一份给客户端
- 接到证书的客户端可利用CA机构的公钥对数字签名（其中包括摘要算法）进行验证【证书的有效期、颁发机构、域名匹配】。
- 客户端的浏览器建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给服务器
- 服务器利用自己的私钥解密出会话密钥
- 之后，服务器利用会话密钥加密与客户端之间的通信【对称加密】

Https采用混合加密机制（**对称加密** + **非对称加密**），如果密钥能够保证安全交换，那么全程有可能仅使用对称密钥加密来进行通信，如果不能保证密钥安全交换，可在密钥交换环节使用非对称加密方式，之后使用对称加密方式。这样做的目的是因为对称密钥加密相较非对称秘钥加密处理速度更快。



### CDN

具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。

**CDN过程：**

①、当用户点击APP上的内容，APP会根据URL地址去**本地DNS**（域名解析系统）寻求IP地址解析。

②、本地DNS系统会将域名的解析权交给**CDN专用DNS服务器**。

③、CDN专用DNS服务器，将CDN的全局负载均衡设备IP地址返回用户。

④、用户向**CDN的负载均衡设备**发起内容URL访问请求。

⑤、CDN负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的**缓存服务器**。

⑥、负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求。

⑦、用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。

⑧、如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的**源服务器**请求内容。

⑨、源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。

CDN相对主服务器，有推、拉两种文件储存策略

### DNS

**解析域名的过程如下：**

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

### （扩展）websocket

它是在http协议的基础上使用websocket通信，相当于是升级而来。http的请求头用`connection:upgrade`和`upgrade:websocket`。响应头的状态码是101。后续就可以用websocket发送消息了。	

建立后相当于是一个持久连接的有状态信道，服务端可以主动推送ws消息

**WebSocket的优点：**

- 较少的控制开销：在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小；
- 更强的实时性：由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少；
- 保持状态：与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息；

### 请求头

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |

### 响应头

- **Cache-Control** 对应请求中的Cache-Control

- **Content-Type：text/html;charset=UTF-8** 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

- **Date: Tue, 03 Apr 2018 03:52:28 GMT** 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

- **Expires:Sun, 1 Jan 2000 01:00:00 GMT** 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

- **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT** 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

- **Connection：keep-alive** 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

- **ETag: "737060cd8c284d8af7ad3082f209582d"** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

- **Access-Control-Allow-Origin: \***  *号代表所有网站可以跨域资源共享



## 浏览器缓存

**协商缓存**是利用的是`【If-Modified-Since，Last-Modified】`和`【If-None-Match，ETag】`这两对**请求头响应头**来管理的

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而**强制缓存**不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

## 二进制存储

### arraybuffer

它接受一个整数作为参数，表示这段二进制数据占用多少个字节。

```
var buffer = new ArrayBuffer(8);
buffer.byteLength // 8
```

ArrayBuffer 对象有实例方法`slice()`，用来复制一部分内存。它接受两个整数参数，分别表示复制的开始位置（从0开始）和结束位置（复制时不包括结束位置），如果省略第二个参数，则表示一直复制到结束。

```
var buf1 = new ArrayBuffer(8);
var buf2 = buf1.slice(0);
```

### blob

Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。

```
myBlob = new Blob(array [, options])
```

`Blob`构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的`Blob`实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性`type`，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。

```
myBlob.size // 32
myBlob.type // "text/html"
myBlob.slice(start, end, contentType)
```

slice方法有三个参数，都是可选的。它们依次是起始的字节位置（默认为0）、结束的字节位置（默认为size属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。



AJAX 请求时，如果指定`responseType`属性为`blob`，下载下来的就是一个 Blob 对象。

## 判断值的类型

### typeof

```
typeof(a) == 'undefined'
```

typeof的结果——返回结果为string

Undefined	"undefined"
**Null	"object"**
Boolean	"boolean"
Number	"number"
BigInt	"bigint"
String	"string"
Symbol	"symbol"
**Function	"function"**
其他任何对象	"object"

### 用!的非空判断

实际开发中我们可能不需要区分地这么细，而是只要简单地进行非空判断（如果变量为 **undefined** 或者为 **null** 都表示空），那么可以使用下面方法：

```
if(!a) {
  console.log('a 为空');
}else{
  console.log('a 不为空');
}
```

### instanceof

用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

> 原型链、作用域链

返回值——ture/false

```js
object instanceof constructor

function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);

console.log(auto instanceof Car);
// Expected output: true
```

### Object.prototype.toString.call()

它会返回一个形如 `"[object XXX]"` 的字符串，可以精准判断所传入参数的数据类型。

如果对象的 `toString()` 方法未被重写，就会返回如上面形式的字符串。但是，大多数对象，`toString()` 方法都是重写了的，比如string，所以才会造成我们印象当中把这个东西打印出来的感觉。

所以，需要用object没有重写的tostring方法，call到需要的位置，就可以展示 `"[object XXX]"` 的字符串了

```js
console.log(Object.prototype.toString.call("jerry"));//[object String]
console.log(Object.prototype.toString.call(12));//[object Number]
console.log(Object.prototype.toString.call(true));//[object Boolean]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
```

### isArray

返回值为true/false

```js
//Array.isArray(obj)
var fruits = ["Banana", "Orange", "Apple", "Mango"];
var ans = Array.isArray(fruits);
```

## 不那么重要的es6模块

### 遍历属性

ES6 一共有 5 种方法可以遍历对象的属性。

- for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
- Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名
- Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名
- Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名
- Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举

上述遍历，都遵守同样的属性遍历的次序规则：

- 首先遍历所有数值键，按照数值升序排列
- 其次遍历所有字符串键，按照加入时间升序排列
- 最后遍历所有 Symbol 键，按照加入时间升序排

### 箭头函数

### generator

## Vue3

### Vue3对比Vue2

- 重写了虚拟`Dom`实现【在`diff`算法中相比`vue2`增加了静态标记；对不参与更新的元素，会做静态提升】
- compositon Api【相关的代码放在同一个函数了】

- 通过`webpack`的`tree-shaking`功能仅打包需要的模块【ESM，有点类似rollup的方法】
- Vue2数据监听是通过`Object.defineProperty`，这个 API 有一些缺陷，【检测不到对象属性的添加和删除、数组`API`方法无法监听到、嵌套对象要深层监听有性能问题】。`vue3`是通过`proxy`监听整个对象，那么对于删除还是监听当然也能监听到，同时`Proxy` 并不能监听到内部深层次的对象变化，而 `Vue3` 的处理方式是**在`getter` 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式**，而不是无脑递归。

### Vite

#### 为什么vite比webpack快

“使用原生ESM导入方式，实现闪电式的更新”。用的rollup

- 本地开发环境webpack也是需要先打包，然后服务器运行的是打包后的文件，不管模块是否会被执行，都要被编译和打包到bundle里，所以启动很慢。Vite快速冷启动：只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理（基于es新特性 Dynamic imports对ESM的支持），所以节省了webpack 那一套打包转化封装的逻辑。
- 热更新：Webpack 的热更新会以当前修改的文件为入口重新 build 打包，所有涉及到的依赖也都会被重新加载一次。vite的缓存更好，对浏览器缓存用强缓存，对预构建的依赖缓存有更好的判断决定是否需要重新运行

#### 为什么生产环境仍需打包，为啥不直接将 entry.js 文件使用 标签引用

1. 尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）
2. 从 entry.js 到所有依赖的模块代码，全部采用 ES Module 方案实现。我们的依赖管理是采用 npm 的，而 npm 包大部分是采用 CommonJS 标准而未兼容 ES 标准的。

### Pinia

“可以理解为Vuex5。与Vuex相比，Pinia不仅提供了一个更简单的API，也提供了符合组合式API风格的API，最重要的是，搭配TypeScript一起使用时有非常可靠的类型推断支持。”

- pinia最重要的是，搭配TypeScript一起使用时有非常可靠的类型推断支持
- pinia没有mutations。而actions的使用不同，在actions中可以处理同步也可以处理异步。getters的使用一致。state与vue2中data是相似的
- pinia没有总出口，全是模块化，需要定义模块名称，当多个模块需要协作的时候需要引入多个模块。Vuex是有总入口的，在使用模块化的时候不需要引入多个模块
- pinia在修改状态的时候不需要通过其他api。vuex需要通过commit,dispatch去修改。所以在语法上比vuex更容易理解和使用，灵活

## 基础Vue

### 自定义指令

```vue
<template>
	<div class="hello">
		<input type="text">
		<input type="text" v-focus>
	</div>
</template>

<script>
export default{
	name:"HelloWorld",
	data(){
		return{}
	},
	directives:{//自定义指令，不需要写v,使用的时侯舞圆
		focus:{
			inserted:function(el){
            //表示被绑定的元素插入父节点的时候调用
			//el:表示指令所绑定的元素
			//binding:对象，属性name:指令名，value:指令绑定值
				e1.focus()/获取焦点
			},
        }
	}
}    
```

### 双向数据绑定

mvvm

modelview层有【监听器observer：对所有数据的属性进行监听；解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数；Watcher：将来对应数据变化时会调用更新函数】



### $nextTick

是将回调函数延迟在下一次dom更新时再执行。比如这一次要更新，所以必须nextTick后才能拿到。

- created钩子里的操作一定要nexttick
- 在数据变化后要执行某个操作，而这个操作需要使用随数据变化而变化的dom节点时，这个操作要放到nextTick中

### Vdom

vdom和真实dom的优势

diff算法（两头往中间比）

## axios

### 封装

baseURL

封装成一个函数，以后就可以直接调用。不需要再写url的路由等东西。只需要传参数就行

### 拦截器

```js
axios.interceptors.request.use(
  config => {
    // 每次发送请求之前判断是否存在token
    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的
    token && (config.headers.Authorization = token)
    return config
  },
  error => {
    return Promise.error(error)
  })

axios.interceptors.response.use
```

## React

特点：声明式、组件化、跨平台

React是用JavaScript构建快速响应的大型Web应用程序的首选方式之一。它在Facebook和Instagram上表现优秀。等待资源加载【react.lazy——react.suspense——errorboundary】

### react更新流程

scheduler

- 维护时间切片
- 与浏览器任务调度
- 优先级调度

reconciler

- 将JSX转化为Fiber
- Fiber树对比（双缓存）
- 确定本次更新的Fiber

renderer

- 渲染器用于管理一颗react树，使其根据底层平台进行不同的调用

![image-20230501160936938](../AppData/Roaming/Typora/typora-user-images/image-20230501160936938.png)

#### 优势

快速响应：Fiber
组件化：复用性强
声明式编程
跨平台：只需修改渲染器

#### 缺点

大型应用需要配套学习状态管理、路由工具
不适合小型应用，需要用babel处理

### 基本使用

#### 组件

> 数据——通信——ui——性能

Class组件

- 继承+构造函数
- this
- 生命周期
- render 方法 return JSX

函数式组件

- 没有生命周期
- 借助hook
- 直接return JSX

函数式相较Class式的优势——【没有复杂的生命周期、组件简洁清爽、支持hook使得复用方便】

将UI拆成多个独立单元，这些单元组合可以构成多种视图展示，这些独立单元就是组件。组件相当于原子。 hook贴近组件内部运行的各种概念逻辑，比如effect、 state、context等，更贴切于电子。

**hook原则**

只能在最顶层使用Hook

只能在React函数中调用Hook

**常见的React API**

**常见的React Hook**

组件的拆分粒度——有ui的当然可以拆，但有的东西没有ui，或许也可以拆

#### 通信

父传子。知道子组件的表现，直接通过props传递即可。不知道具体子组件表现呢？props.children

子传父。传信息用callback。传递方法的话加ref

组件之间互传信息。context、reducer、react-redux

#### 组件性能优化

使用react.memo

#### 组件挂载

createPotral

### 状态管理

react数据流是单向的

react的数据管理工具非常多，不像vue只有vuex和pinia

父子界面之间可以用prop

跨度太大的通信，可以用context。context只能存单一值，多个值会形成塔形结构，不好控制渲染粒度。

#### Redux

### 路由

**过程：解析url【history接口】——匹配路由【router】——render【route】**

history接口允许操作浏览器曾经访问的会话历史记录

分为：memory history——brower history——hash router

> Memory history记录了内存中的当前位置。它设计用于有状态的非浏览器环境，比如测试和React Native。
>
> Browser history将位置存储在常规URL中。这是大多数Web应用程序的标准，但需要在服务器上进行一些配置，以确保在多个URL上提供相同的应用程序。
>
> Hash history将位置存储在window.location.hash中。这使得它非常适合某些情况，例如您不想出于某种原因将位置发送到服务器，无论是因为您无法进行配置，还是因为URL空间专门用于其他用途。



![image-20230501204616753](../AppData/Roaming/Typora/typora-user-images/image-20230501204616753.png)

兼容history和hash模式：后端路由定义通配符，优先返回，使得交给前端解析

# 面试问了，但我不会的

## CSS

### 布局100px、自适应、100px

1.**flex布局**

2.利用浮动，或者绝对定位的方式使左右元素脱离常规文档流，让父元素padding:0 100px，左侧元素 margin-left:-100px, width:100px，右侧同理，最后中央**块元素的宽度会自动默认充满剩下的屏幕**，不要设置宽度，所以就实现了自适应的效果了

3.绝对定位{width: 100%; position: absolute; top: 0 ; left: 100px; right: 100px;}

4.利用BFC的区域不会与float box重叠。float:left,width:100px，右边div设置overflow:auto/hidden触发BFC

5.calc实时计算、**竖着浮动布局**——vh（注意父级div的height默认为0）

6.grid布局

## JS

### 原型链

```js
var checkIfInstanceOf = function(obj, classFunction) {
    if(obj === undefined || obj === null)
        return false
    while(obj !== null){
        if(obj.constructor === classFunction)
            return true
        obj = Object.getPrototypeOf(obj)
    }
};
```

对象——构造函数——原型对象

原型对象 === Object.getPrototypeOf(对象) 【这就是原型链，重点是object的原型null】

原型对象 === 对象.`__proto__`

构造函数 === 原型对象.constructor

原型对象 === 构造函数.prototype

### 两等于

当进行双等号比较时候： 先检查两个操作数数据类型，如果相同，则进行\=\==比较

相等操作符对于不同类型的值：

1.是否有**NaN**
首先判断双等号两边是否有NaN，如果有的话，则一律返回false。

2.是否有**boolean**值
如果有的话则将true转化为1，false转化为0。

3.**null和undefined**
遇到null或者undefined，它们相互的比较返回true，于其它比较false。

4.有一边是**字符串**
分四种情况：

1） 同样是字符串，则直接进行字符串值的比较

2） 是数字，则需要将字符串转化为数字，然后进行比较

3） 有布尔类型，则要将布尔类型转化为0或则1，然后进行比较

4） 对象或者数组类型，则需要调用**toString()或者valueOf()**【都属于ToPrimitive()】方法转化成简单类型，然后进行比较

一般是优先调用valueOf方法，如果无法与简单值进行比较，则会再调用toString方法

但是Date对象默认会调用toString方法。

**valueOf**

- String => 返回字符串值
- Number => 返回数字值
- Date => 返回一个数字，即时间值,字符串中内容是依赖于具体实现的
- Boolean => 返回Boolean的this值
- Object => 返回this



### !(逻辑非):

将其后变量或表达式转为布尔值

> “假值”总共只有6个：
> **false，undefined，null，0，""（空字符串），NaN**
> 除此之外的所有值，都是“真值”，即在逻辑判断中可以当true来使

## Promise

**需要传入一个函数作为参数**

**new了就产生了并处于pending，之后需要手动resolve或者reject**

基本使用

```js
const p = new Promise((resolve,reject)=>{
	setTimeout(()=>{
 		resolve('123')
 	},1000)
}).then(res=>{
 	console.log(res) //1秒后打印123
}).catch(err=>{
  console.log('err',err)//1秒后打印 error message
})
```

一个题目——按序执行异步

```js
function generatePromiseFunc(index) {
    return function () {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log(index)
                resolve(index)
            }, 1000)
        })
    }
}
const list = []
for(let i = 0; i < 3; i++) {
    list.push(generatePromiseFunc(i))
}

//answer 0
list[0]().then(()=>{
    return list[1]()
}).then(()=>{
    return list[2]()
}).then(()=>{
    console.log('done')
})

//answer 1
async function promise_queue(list) {
    let index = 0
    while (index >= 0 && index < list.length) {
        await list[index]()
        index++
    }
}
promise_queue(list)

//answer 2
function promise_queue(list, index) {
    if (index >= 0 && index < list.length) {
        list[index]().then(() => {
            promise_queue(list, index + 1)
        })
    }
}
promise_queue(list, 0)
```

`then`方法

但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？

```
// 写法一
f1().then(function () {
  return f2();
});

// 写法二
f1().then(function () {
  f2();
});

// 写法三
f1().then(f2());

// 写法四
f1().then(f2);
```

为了便于讲解，下面这四种写法都再用`then`方法接一个回调函数`f3`。写法一的`f3`回调函数的参数，是`f2`函数的运行结果。

```
f1().then(function () {
  return f2();
}).then(f3);
```

写法二的`f3`回调函数的参数是`undefined`。

```
f1().then(function () {
  f2();
  return;
}).then(f3);
```

写法三的`f3`回调函数的参数，是`f2`函数返回的函数的运行结果。

```
f1().then(f2())
  .then(f3);
```

写法四与写法一只有一个差别，那就是`f2`会接收到`f1()`返回的结果。

```
f1().then(f2)
  .then(f3);
```





## 设计模式

设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力

设计模式有：

- 单例模式——在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象。一般情况我们不认为全局变量是一个单例模式，原因是：全局命名污染；不易维护，容易被重写覆盖
- 工厂模式——不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。只需要我们传入正确的参数，就能生产类似的产品。
- 策略模式——定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来
- 代理模式——为一个对象提供一个代用品或占位符，以便控制对它的访问。当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象
- 发布订阅模式——消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者），而是将发布的消息分为不同的类别。订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。
- 观察者模式——定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新

发布订阅、观察者两者区别如下图：

![img](https://files.mdnice.com/user/155/9141682c-7386-4f12-8412-fb17a1cd4bf6.png)

- 在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。
- 观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）

## 跨域

### 什么是同源，什么是跨域

源（origin），由 协议、ip地址、端口 组成。

容易受到攻击，有安全性问题，所以做出限制。

跨域限制：**浏览器**限制了以下三种行为——DOM无法操作、Cookie无法操作、**Ajax（xhr）**请求无效

### 服务器有跨域吗

没有。跨域限制必须符合两个条件——浏览器、ajax

三种方法

不用http、不在浏览器、官方支持的

#### jsonp

script标签可以跨域。需要服务端的支持，可以得到其他域动态产生的 JSON 数据。

##### 过程

1. 浏览器端创建一个 script 标签，并设置该标签的 src 属性。src 属性是类似于 get 请求的 url 地址。并在请求中向服务器端传递一个 callback 参数。
2. 服务器接收请求会将callback传过来的参数连同要的数据转换成json数据传回客户端。
3. 返回成功后，浏览器端会根据调用 callback，此时 callback 中的参数就是服务器端返回的数据。callback 中可以添加对返回数据的处理

**整个过程类似于服务器端调用前端传递的 callback 函数，并将服务器端需要返回的数据放在 callback 的参数中。**

#### websocket

不用http就行了，也是一种越过ajax的思路

#### cors 

需要预先在服务器端配置好cors支持。服务器根据请求头附加的值，决定是否同意此次请求。

CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。请求头不能太复杂，才是简单请求，只是为了避免别人用简单的表单。

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。“预检”请求用的请求方法是`OPTIONS`。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求

#### 代理

有正向代理和反向代理。简单概括下就是，服务器代理被称为反向代理，比如负载均衡；客户端代理被称为正向代理。

代理与前端页面同源，由他返回的数据就不存在跨域的问题。代理服务器与服务器之间是非同源，但不存在跨域问题。



### 其它方法

**一级域名相同，只是次级域名不同**

如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置`document.domain`共享 Cookie、iframe

**片段标识符（fragment identifier）**

改变URL 的`#`号后面的部分，比如`http://example.com/x.html#fragment`的`#fragment`。如果只是改变片段标识符，页面不会重新刷新。

父窗口可以把信息，写入子窗口的片段标识符。子窗口通过监听`hashchange`事件得到通知。

**postMessage()**

这个 API 为`window`对象新增了一个`window.postMessage`方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口`aaa.com`向子窗口`bbb.com`发消息，调用`postMessage`方法就可以了。

父窗口和子窗口都可以通过监听`message`事件，获得对方的消息。

## 前端网络安全

### Cookie挟持

`HTTP`是无状态的协议，为了维持和跟踪用户的状态，引入了`Cookie`和`Session`。 `Cookie`包含了浏览器客户端的用户凭证，相对较小。`Session`则维护在服务器，用于维护相对较大的用户信息。可以把`Cookie`当成密码，而`Session`是保险柜。由于`HTTP`是明文传输，`Cookie`很容易被盗取，如果被盗取，别人就可以冒充你的身份，打开你的保险柜，获取你的信息，动用你的资金，这是很危险的。

**1.危害**

盗取`cookie`信息，冒充他人身份，盗取信息。

**2.防御**

- 给`cookie`添加`HttpOnly`属性，该属性设置后，只能在`http`请求中传递，在脚本中，`document.cookie`无法获取到该`cookie`值，对XSS攻击有防御作用，但对网络拦截还是会泄露。
- 在`cookie`中添加校验信息，这个校验信息和当前用户外置环境有些关系，比如`ip`、`user agent`等有关.这样当`cookie`被人劫持冒用时，在服务器端校验的时候，发现校验值发生了变化，因此会要求用户重新登录，可以规避`cookie`劫持。
- `cookie`中`session id`的定时更换，让`session id`按一定频率变换，同时对用户而言，该操作是透明的，这样保证了服务体验的一致性。

### XSS跨站脚本攻击

攻击者在`web`页面恶意插入`HTML`或`script`标签，当用户浏览该页面时，恶意代码就会被执行，从而达到攻击的目的。`XSS`利用的是**用户对指定网站的信任**。

**1.类型**

- 反射型(非持久)：攻击者事先制作好攻击链接,需要欺骗用户自己去点击链接才能触发`XSS`代码，所谓反射型`XSS`就是将恶意用户输入的`js`脚本，反射到浏览器执行。
- 储存型(持久型)：会把攻击者的数据储存到服务端，攻击行为将伴随攻击数据一直存在，每当用户访问该页面就会触发代码执行。
- DOM型：基于文档对象模型的漏洞。 最经典的存储型`XSS`漏洞是留言板，当用户A在留言板留言一段`JS`代码`<script>alert("run javascript");</script>`,后端未经过滤直接存储到数据库，当正常用户浏览到他的留言后，这段`JS`代码就会被执行，可以借此来盗取`cookie`。

**2.危害**

- 盗取网页浏览中的`cookie`值，盗用`cookie`实现无密码登录，盗取用户信息。
- 劫持访问，实现恶意跳转。
- 配合CSRF攻击完成恶意请求。

**3.防御方法**

- 标签过滤，如`<script>`、`<img>`、`<a>`标签等
- 编码，对字符`<` 、`>`、`&`、`"` 、`'` 、`+`、`/`等进行转义。
- `cookie`防盗，将`cookie`设置为`http-only`,`js`脚本将无法读取到`cookie`信息。
- 纯前端渲染，明确`innerText`、`setAttribute`、`style`，将代码与数据分隔开。
- 避免不可信的数据拼接到字符串中传递给这些`API`，如`DOM`中的内联事件监听器，`location`、`onclick`、`onload`、`onmouseover`等，`<a>`标签的`href`属性，`JavaScript`的`eval()`、`setTimeout()`、`setInterval()`等，都能把字符串作为代码运行。

### CSRF跨站点请求伪造

顾名思义就是通过伪造连接请求，在用户不知情的情况下，让用户以自己的身份来完成非本意操作的攻击方法。`CSRF`利用的是**网站对浏览器的信任**。

> 虽然 Cookie 不能跨域共享，但是如果存在漏洞或者错误配置，攻击者可能通过其他方式获取到目标网站的 Cookie 或其他敏感信息，例如 XSS 攻击、文件包含漏洞、DNS 劫持等手段。此外，某些浏览器也可能存在漏洞，导致同源策略被绕过，从而使得攻击者能够跨域访问敏感资源。

**1.原理**

1. 用户`C`浏览并登录信任网站`A`,产生`cookie`
2. 用户`C`未退出网站`A`，在同一个浏览器危险访问网站`B`
3. 网站`B`的页面存有一些攻击性的代码，会发出访问`A`的请求
4. 浏览器收到请求后，在用户不知情的情况下携带`cookie`访问网站`A`
5. `A`不知道请求是谁发的，浏览器会带上用户的`cookie`，所以`A`会根据用户的权限处理`B`发出的请求。这样就达到了攻击的目的。

**2.防御**

- 验证码：对敏感操作加入验证码，强制用户与网站进行交互
- 对`Cookie`设置`SameSite`属性。该属性表示`Cookie`不随着跨域请求发送，可以很大程度减少`CSRF`的攻击，但是该属性目前并不是所有浏览器都兼容。
- 使用`POST`请求，避免使用`GET`，降低攻击风险，`post`请求攻击方需要构造一个`form`表单才可以发起请求，比`get`请求（`img`的`src`，`a`标签的`href`等等）的攻击方式复杂了一些，相对来说能降低风险，但不能阻止。
- 检查`HTTP`中的`referer`字段，该字段记录了`HTTP`请求的来源地址
- 在请求头中加入`token`验证字段，浏览器并不会自动携带`Token`去请求，且`Token`可以携带一段加密的`jwt`用作身份认证，这样进行`CSRF`的时候仅传递了`cookie`，并不能表明用户身份，网站即拒绝攻击请求。



## Vue

### MVVM

**两个常考部分——【监听、更新】**

vue是采用数据劫持实现数据绑定的。当把一个普通的javascript对象传给Vue实例来作为它的data选项时，Vue将遍历它的属性，用Object.defineProperty将它们转为getter/setter，实现响应式。用户看不到getter/setter，但是在内部它们让Vue追踪依赖。在属性被访问和修改时通知变化。

**Observer 数据监听器**

能够对数据对象的所有属性进行监听，如有变动可拿到最新的值并通知订阅者，内部采用的Obiect.defineProperty的getter和setter来实现。

可以利用Obeject.defineProperty（）来监听属性变动，这时将需要observer数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。

在get中收集依赖，在set中通知依赖更新，给dep

**Complie 指令解析器**

主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

感觉就是render的事情

**Dep 消息订阅器**

内部维护了一个数组，用来收集watcher的数据变动和触发notify函数，再调用watcher的update方法。

感觉dep和watch是一对一的，分别是功能操作和状态储存

**Watcher 订阅者**

作为**连接Observer和Complie的桥梁**，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。

- 在自身实例化时往属性订阅器(dep)里面添加自己
- 自身必须有一个update()方法
- 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退

![vue响应式.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6099ca33a9f3454daf973ef19485f4eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)



### vdom更新

`VNode`说明：

- 所有对象的 `context` 选项都指向了 `Vue` 实例
- `elm` 属性则指向了其相对应的真实 `DOM` 节点

`vue`是通过`createElement`生成`VNode`。`createElement` 创建 `VNode` 之后，每个 `VNode` 有 `children`，`children` 每个元素也是一个`VNode`，这样就形成了一个虚拟树结构，用于描述真实的`DOM`树结构

#### 异步更新：

vdom 将多次态变更合并到一起进行批量更新，以避免频繁的 DOM 操作。

当一个组件中的响应式属性发生变化时，Vue 会通过**数据劫持机制监听**这个变化，并调用queueWatcher函数，把更新Watch对象push进**异步更新队列**中。

Vue 为异步更新提供了一个 API nextTick，它接收一个回调函数作为参数，并存入微任务队列，其执行时调用这个回调函数。此时这些Watch对象才会被遍历取出，更新视图。

**DOM渲染在微任务后触发、宏任务前触发**

`$nextTick`会在DOM更新之后被触发，以获取最新DOM节点。

#### 分离计算

vdom 采用分离计算和渲染的策略，即先计算出需要更新的部分，再将其与旧的虚拟 DOM 进行比较，最后只对变化的部分进行真实 DOM 操作，从而提高性能

其中比较的步骤有

- patch——判断是否为同一节点【key值、tag、data】等相同
- patchVnode——处理text更新、更新子节点
- updateChildren——都有子节点时调用

#### Diff 算法：

updateChildren用了diff算法——双端往中间靠，边靠边找

**为什么v-for需要:key**

> 如果为组件引入了key值，就可以在diff算法对比之前先做一个校验，判断该组件是否需要进行diff对比，也可以判断该组件是直接更新、销毁还是新建等操作，从而提高diff算法的效率

### route 的实现

`vue-router`的核心原理就是监听路由的变化，然后修改当前`route`的值，而`router-view`组件中会收集`route`属性，所以当`route`不同时会渲染相应的组件，然后渲染到`router-view`中去。

**实现 hash 路由的基本思路：**

- 通过 `hashchange` 事件监听 hash 路由的变化；
- 通过 [xhr](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FXHR_(XMLHttpRequest)) 对象获取服务器的资源；
- 将资源渲染到页面上；

有时候有产生404问题。本质是因为我们的路由是通过JS来执行视图切换的，当我们进入到子路由时刷新页面，`web`容器没有相对应的页面此时会出现404

同样的，前端router的改变也是通过js控制的

### keep-alive

`keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM`

`keep-alive` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

## 网络

从点击到你的歌曲播放的网络过程