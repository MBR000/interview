前端学习冲冲

目录

- HTML（HTML5.3）
- CSS（模块）
- **JS（ES6）**
- VUE
- React
- 手写算法、实现
- 计算机网络
- 操作系统
- 浏览器
- 工具/插件
- 构建工具和工程化
- 进阶技能



## 基础

### 遍历

ES6将空位当做undefined

#### **遍历对象方法**

**1.for(item in obj)**

遍历输出的是**对象自身的可枚举属性以及原型链上可枚举的属性(不含Symbol属性)**,原型链上的属性最后输出说明先遍历的是自身的可枚举属性,后遍历原型链上的

> 注意：object的setpropert默认不可枚举

for...in的特性会导致一个问题，其继承的属性会被遍历到，所以当我们不想要遍历被继承的属性，那么我们就可以使用Object.keys()

**2.Object.keys(obj)**

`Object.keys()`方法可以遍历到所有对象本身的**可枚举属性**，其返回值为数组

**3.Object.values(obj)**

`Object.values()`与`Object.keys()`遍历对象的特性是相同的，但是其返回的结构是以遍历的属性值构成的数组

**4.Object.entries(obj)**

`Object.entries()`的返回值为`Object.values()`与`Object.keys()`的结合，也就是说它会返回一个嵌套数组，数组内包括了属性名与属性值

**5.Object.getOwnPropertyNames()**

输出对象**自身的可枚举和不可枚举属性的数组，不输出原型链上的属性**

**6.Reflect.ownKeys()**

`Reflect.ownKeys()`返回的是一个大杂烩数组，即包含了对象的所有属性，**无论是否可枚举还是属性是symbol，还是继承，将所有的属性返回**

| 遍历目标                                                     | 方法                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------ |
| 遍历对象本身的**可枚举**属性不包含**继承**来的属性（不包括`Symbol()`） | `Object.keys()`，`Object.values()`，`Object.entries()` |
| 遍历对象本身的**可枚举**属性包括**继承**来的属性（不包括`Symbol()`） | `for...in`                                             |
| 遍历对象本身的所有属性（不包括`Symbol()`）                   | `Object.getOwnPropertyNames()`                         |
| 遍历对象的`Symbol()`属性                                     | `Object.getOwnPropertySymbols()`                       |
| 遍历对象的所有属性                                           | `Reflect.ownKeys()`                                    |



#### 遍历数组方法

**1.arr.forEach()**

**2.arr.map()**

3.for(let i = 0; i < arr.length; i++)

4.for(var i in arr)

5.for(var value of arr)

只要数据结构具有iterator 接口，就可以使用 for of 遍历它的成员。

### 数组中是否存在某个元素

**法一：indexOf**

不存在返回-1，存在返回第一次出现的索引

**法二：find**

它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。

**法三：findIndex**

返回第一个符合条件的数组元素的位置，如果所有的元素都不符合条件，则返回-1.

**法三：some**

some方法同样用于检测是否有满足条件的元素，如果有，则不继续检索后面的元素，直接返回true，如果都不符合，则返回一个false。

用法与find相似，只是find是返回满足条件的元素，some返回的是一个Boolean值，从语义化来说，是否包含返回布尔值更贴切。

**法四：includes** 

ES6新增的数组方法，用于检测数组是否包含某个元素，如果包含返回true，否则返回false，比较厉害的是，**能直接检测NaN**

优点 就不用说了，最简单的做法没有之一，不用回调，不用复杂的写法，一个方法直接搞定。

缺点 低版本浏览器支持不是很友好

**法五：for循环和if判断**



### 正则（RegExp）

#### 创建

把一些字母和符号写在 `//` 中间的东西, 叫做正则表达式, 比如 `/abcdefg/`。创建正则表达式有两个方式 **字面量** 和 **构造函数创建**

字面量创建

```js
// 字面量创建一个正则表达式
var reg = /abcdefg/g
```

构造函数创建

```js
var reg = new RegExp('abcdefg')
```

#### **匹配**

**表义符号**

- `[]`: 字符集合, 表示写在 `[]` 里面的任意一个都行
- `[^]`: 反字符集合, 表示写在 `[^]` 里面之外的任意一个都行
- `-`: 范围, 比如 `a-z` 表示从字母 a 到字母 z 都可以
- `.`：表示一个任意字符

**重复符号**

- `*`: 前一个内容重复至少 0 次, 也就是可以出现 **0~正无穷** 次
- `+`: 前一个内容重复至少 1 次, 也就是可以出现 **1~正无穷** 次
- `?`: 前一个内容重复 0 或者 1 次, 也就是可以出现 **0~1** 次
- `{n, m}`: 前一个内容至少出现 n 次至多出现 m 次, 也就是出现 **n~m** 次。`{n, }` 和 `{n}` 是特殊的

**特殊符号**

- `()` ：**制造一个分组，可以用 `\1` 来引用分组1**
- `(?: )`: 制造一个非捕获分组，`\1` 等不能引用它
- `|` : 和在字符层面上运作的字符集 [abc] 不同，分支在表达式层面上运作

**转义字符**

- 要匹配 `.` `*` `$` 等字符，需要添加反斜线才能匹配到
-  `^` : 匹配字符串的开始
- `$` :  匹配字符串的结束
- `\d`就是`[0-9]`。表示是一位数字。记忆方式：其英文是digit（数字）。
- `\D`就是`[^0-9]`。表示除数字外的任意字符。
- `\w`就是`[0-9a-zA-Z_]`。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符
- `\W`是`[^0-9a-zA-Z_]`。非单词字符。
- `\s`是`[ \t\v\n\r\f]`。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。
- `\S`是`[^ \t\v\n\r\f]`。 非空白符。
- `\b` 匹配的是单词的边界

**断言字符**

- `(?=)` : 规定了段的后面必须紧跟什么才符合要求
- `(?!)` : 规定了段的后面必须不是什么才符合要求
- (?<=)：段的前面为xx才符合要求
- (?<!)：段的前面没有xx才符合要求

**场外因素**

- 全局标志最后为`/abc/g`。使表达式选中所有匹配项，如果不启用全局标志，那么表达式只会匹配第一个匹配项。
- 多行标志为`m`。正则表达式将所有文本视作一行。但如果我们使用了多行标志，它就会单独处理每一行。
- `i` 对大小写不敏感
- **默认贪婪匹配，如`.*r`匹配最后那个以r结尾**
- 可以开启懒惰匹配 `*`之后添加`?`即可，如`.*?r`匹配第一个以r结尾就停

#### 后续使用

reg.exec(str)	一个在字符串中执行查找匹配的RegExp方法，它**返回一个数组**（未匹配到则返回null）。
reg.test(str)	一个在字符串中测试是否匹配的RegExp方法，它返回true或false。
str.match(reg)	一个在字符串中执行查找匹配的String方法，它返回一个数组（所有符合要求的结果）或者在未匹配到时返回null。
str.search(reg)	一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
str.replace(reg,newstr)	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
str.split(sign)	一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。

```
方法一 string.replace(/[^0-9]/ig, ‘’)
这种方法是直接得到字符串数字
var string = 'func56t9i10on'
var number = string.replace(/[^0-9]/ig, '')
number 结果 "56910"

方法二 string.match(reg)
这种得到字符串数组, 不过数字有没有分开都是字符串数组
var reg = /[1-9][0-9]*/g
var string = 'func56t9i10on'
var number = string.match(reg)
number  结果 ["56", "9", "10"]
var string2 = 'func5678tion'
string2.match(reg) 结果 ["5678"]
```

#### 实战

可以使用 JavaScript 正则表达式和字符串的 replace() 方法来模糊化电话号码和邮箱地址。

以下是实现方法：

```javascript
// 匹配电话号码的正则表达式
const phoneReg = /(\d{3})\d{4}(\d{4})/g;

// 匹配邮箱地址的正则表达式
const emailReg = /(\w)(\w+)(\w)@(\w+\.\w+(\.\w+)?)/g;

// 需要模糊化的原始文本
const text = '电话是18702869102，邮箱是meiaho@bupt.edu.cn';

// 替换电话号码中间四位为 * 号
const blurPhone = text.replace(phoneReg, '$1****$2');

// 替换邮箱地址除第一个和最后一个字符以外的字符为 * 号
const blurEmail = blurPhone.replace(emailReg, '$1**$3@$4');

console.log(blurEmail); // 输出：电话是187****9102，邮箱是m**o@bupt.edu.cn
```

在上面的代码中，首先定义了匹配电话号码和邮箱地址的正则表达式。然后使用字符串的 replace() 方法对原始文本进行替换操作，将电话号码中间的四位和邮箱地址中除第一个和最后一个字符以外的字符替换为 * 号。最终输出模糊化后的结果。

需要注意的是，上面的正则表达式只适用于国内常见的电话号码和邮箱地址格式，如果有特殊格式的电话号码和邮箱地址，需要根据具体情况进行调整。



### JS数组方法哪些改变原数组

#### 改变

`push` 方法往数组里面添加元素，返回数组的长度。

`unshift` 方法会在数组的开头添加一个元素，它会返回数组新的长度。

`pop()` 方法从数组中删除最后一个元素，并返回该元素的值。

`shift()` 方法从数组中删除第一个元素，并返回该元素的值。

`sort()` 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 `UTF-16` 代码单元值序列时构建的。它返回的就是排序后的数组。

`splice()` 方法用于添加或删除数组中的元素，如果删除一个元素，则返回一个元素的数组。 如果未删除任何元素，则返回空数组。

> **splice(a,b,c,d)，a是开始删的下标，b是删几个，c、d等等是删完再插入那些val**

```
let arr6 = ['张三', '小猪课堂', 23];
let item1 = arr6.splice(0,1); // 返回被删除元素的数组
console.log(item1); // ['张三']
console.log(arr6); // ['小猪课堂', 23]
```

`reverse()` 方法用于颠倒数组中元素的顺序。

#### 不改变

`concat()` 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。

`join()` 方法用于把数组中的所有元素转换一个字符串，元素是通过指定的分隔符进行分隔的。

`reduce()` 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。`reduce` 方法的使用情况稍微复杂

> ```js
> arr.reduce((prev,cur,index,arr)=>{
> 
> },init)
> ```
>
> - arr: 表示原数组
> - prev:表示上一次调用回调时的返回值，或者初始值init
> - cur:表示当前正在处理的数组元素
> - index:表示正在处理的数组元素的索引
> - init: 表示初始值
>
> 注意：如果没有初始值，那么第一轮执行就会把arr[0]当作prev、index为1；而不是认为prev为null、index为0

`map()` 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

`forEach()` 方法用于调用数组的每个元素，并将元素传递给回调函数。`forEach` 方法没有返回值，而且它也不会改变原数组，

`filter()` 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

`slice()` 方法可从已有的数组中返回选定的元素。`slice()` 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。

```
let arr16 = [1, 2, 3, 4, 5, 6];
let item8 = arr15.slice(0, 3);
console.log(item8); // [1, 2, 3]
console.log(arr16); // [1, 2, 3, 4, 5, 6]
```

### 声明、提升、覆盖

#### var

可以使用var定义变量，变量如果没有赋值，那变量的初始值为`undefined`。

变量作用域指变量起作用的范围。变量分为全局变量和局部变量。**全局变量在全局都拥有定义**；而局部变量只能在函数内有效。

在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。

所有不使用var定义的变量都视为全局变量

JavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说**变量在声明之前已经可用**，所有这特性称为`声明提前（hoisting）`，即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。

> 注意：if里面不会额外造一个作用域，所以其中的var也要提前到作用域最开始执行，即使最后不会用到这个var的东西

#### 函数

- 函数声明——直接function foo(){}

- 函数表达式——var foo = function(){}

函数声明有一个非常重要的特征：`函数声明提升`，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。

**函数会首先被提升，然后才是变量**

后定义的同名函数覆盖之前的，与参数无关

#### 全局变量

1. 使用var关键字+变量名在函数外部声明就是全局变量
2. 没有使用var关键字声明，直接给变量名赋值，不管是在函数内部还是外部都是全局变量

当全局变量跟局部变量重名时，局部变量的scope会覆盖掉全局变量的scope，当离开局部变量的scope后，又重回到全局变量的scope。

### typeof 的可能值    

| 数据类型                           | Type                     |
| ---------------------------------- | ------------------------ |
| Undefined                          | “undefined”              |
| **Null**                           | **“object”**             |
| 布尔值                             | “boolean”                |
| 数值                               | “number”                 |
| 字符串                             | “string”                 |
| Symbol (ECMAScript 6 新增)         | “symbol”                 |
| 宿主对象(JS环境提供的，比如浏览器) | Implementation-dependent |
| 函数对象                           | “function”               |
| 任何其他对象                       | “object”                 |

### 错误类型

ECMS中定义了以下八种错误类型,并在错误发生时抛出不同的错误对象。

1. **Error**
2. **InternalError **底层`JavaScript`引擎抛出异常时由浏览器抛出.例如,递归过多导致了栈溢出
3. **EvalError **在使用eval()函数发生异常时抛出
4. **RangeError **数值越界时抛出
5. **ReferenceError **找不到对象时发生，**大部分都是它**
6. **SyntaxError** 给eval()传入的字符串包含`JavaScript`语法错误时发生
7. **TypeError **变量不是预期类型,或者访问不存在的方法 **大部分都是它**
8. **URIError**

#### Error

>  `Error`是基类型,其他错误类型都是继承该类型,因此,所有错误类型都是共享相同的属性(所有错误对象上的方法都是这个默认类型定义的方法).**浏览器很少会抛出`Error`类型的错误**,该类型主要用于开发者抛出**自定义错误**. 例如拦截器/导航守卫中经常会使用到.

#### InternalError

> `InternalError`类型的错误会在底层`JavaScript`引擎抛出异常时由浏览器抛出.例如,递归过多导致了栈溢出.这类型并不是代码中通常要处理的错误,**如果真的发生了这种错误,很可能代码哪里弄错了或者有危险.**

#### EvalError

> `EvalError`类型错误会在使用eval()函数发生异常时抛出.ECMA-262规定,'如果`eval`属性没有被直接调用(就是没有将其名称作为一个`Identifier`(标识符),也就是`CallExpression`中的`MemberExpression`). 基本上,只要不把`eval()`当成函数调用就会报错. **不同浏览器抛出的错误会有差异,但很少会这么使用,所以平时不常见**

`eval()` 函数会将传入的字符串当做 JavaScript 代码进行执行，如果传入的字符串是表达式则返回表达式求值结果，否则返回 `undefined` 。

如果传入 `eval()` 的参数不是字符串，则会直接返回该参数。

#### RangeError

> `RangeError`会在数值越界时抛出.例如,定义数组时如果设置了不支持的长度,如-20.又或者没有给递归设置停止条件时触发. **该类型在`JavaScript`发生不多**

####  ReferenceError

> `ReferenceError`会在找不到对象时发生.(就是著名的"object expected"浏览器错误的原因).这种错误经常是由访问不存在的变量而导致.

#### SyntaxError

> 经常在给eval()传入的字符串包含`JavaScript`语法错误时发生,在eval()外部**很少会用到**该类型错误.这是因为JavaScript代码中的语法错误会导致代码无法执行.

#### TypeError

> **`TypeError`在`JavaScript`中很常见**,主要发生变量不是预期类型,或者访问不存在的方法时等原因导致,尤其是在使用类型特定的操作而变量类型不对时. **在给函数传参前没有验证的情况下,错误频繁发生**

#### URIError

> `URIError`只会在使用encodeURL()或decodeURL()但传入了格式错误的URL时发生,但非常罕见,因为上面两个函数非常稳健.

### 执行上下文

当 `JS` 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 **“准备工作”**，就叫做 **"执行上下文(execution context 简称 `EC`)"** 或者也可以叫做**执行环境**。

> **执行上下文** 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。

#### 类型

`javascript` 中有三种执行上下文类型，分别是：

- **全局执行上下文**——这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，它在整个 `javascript` 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 `window`），并且将 `this` 值绑定到这个全局对象上。
- **函数执行上下文**——每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的）
- **Eval 函数执行上下文**—— 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，但由于并不经常使用 `eval`，所以在这里不做分析。

#### 内容

> 执行上下文是一个抽象的概念，我们可以将它理解为一个 `object` ，一个执行上下文里包括以下内容：变量对象、活动对象、作用域链、调用者信息

**变量对象**：每个执行环境文都有一个表示变量的对象。全局执行环境的变量对象始终存在，而函数这样局部环境的变量，只会在函数执行的过程中存在，在函数被调用时且在具体的函数代码运行之前，JS 引擎会用当前函数的**参数列表**（`arguments`）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 **变量** 和 **函数** 将作为属性添加到这个变量对象上。

**活动对象：**函数进入执行阶段时，原本不能访问的变量对象被激活成为一个活动对象，自此，我们可以访问到其中的各种属性。

**作用域链**：作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 **作用域链**。

**当前可执行代码块的调用者（this）**：如果当前函数被作为对象方法调用或使用 `bind` `call` `apply` 等 `API` 进行委托调用，则将当前代码块的调用者信息（`this value`）存入当前执行上下文，否则默认为全局对象调用。

> 在 `ES6` 中，变量对象、活动对象变成了词法环境和变量环境。
>
> **词法环境**组件和 **变量环境** 的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定。

#### 生命周期

执行上下文的生命周期有三个阶段

- 创建阶段

  函数执行上下文的创建阶段，发生在函数调用时且在执行函数体内的具体代码之前，在创建阶段，JS 引擎会做如下操作：

  - 用当前函数的**参数列表**（`arguments`）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 **变量** 和 **函数** 将作为属性添加到这个变量对象上。**在这一阶段，会进行变量和函数的初始化声明，变量统一定义为 `undefined` 需要等到赋值时才会有确值，而函数则会直接定义**。（变量提升）

    > 函数提升优先级高于变量提升，且不会被同名变量声明覆盖，但是会被变量赋值后覆盖。而且存在同名函数与同名变量时，优先执行函数。

  - 构建作用域链

  - 确定 `this` 的值

- 执行阶段

  JS 引擎开始对定义的变量赋值、开始顺着作用域链访问变量、如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出……

- 销毁阶段

  一般来讲当函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权被重新交给执行栈上一层的执行上下文。

  但是闭包不一样。当闭包的父包裹函数执行完成后，父函数本身执行环境的作用域链会被销毁，但是由于闭包的作用域链仍然在引用父函数的变量对象，导致了父函数的变量对象会一直驻存于内存，无法销毁，除非闭包的引用被销毁，闭包不再引用父函数的变量对象，这块内存才能被释放掉。

#### 程序执行的过程

1. 程序启动，全局上下文被创建

   1. 创建全局上下文的 

      词法环境

      1. 创建 **对象环境记录器** ，它用来定义出现在 **全局上下文** 中的变量和函数的关系（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **外部环境引用**，值为 **`null`**

   2. 创建全局上下文的 

      变量环境

      1. 创建 **对象环境记录器**，它持有 **变量声明语句** 在执行上下文中创建的绑定关系（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建 **外部环境引用**，值为 **`null`**

   3. 确定 `this` 值为全局对象（以浏览器为例，就是 `window` ）

2. 函数被调用，函数上下文被创建

   1. 创建函数上下文的 

      词法环境

      1. 创建  **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）

   2. 创建函数上下文的 

      变量环境

      1. 创建  **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）

   3. 确定 `this` 值

3. 进入函数执行上下文的执行阶段：

   1. 在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。



### this指向

首先，我们必须先知道，每个函数都会有自身的this，但是this并不是在函数声明完就绑定到某个对象上的，只有**在函数调用时，this才会被绑定**，

也就是说，this的绑定和函数定义的位置没有关系，和函数的调用方式有关系。

#### 判断口诀

先念口诀：**箭头函数、new、bind、apply 和 call、欧比届点（obj.）、直接调用、不在函数里。**

只要满足前面某个场景，就可以确定 this 指向了。

#### 常见的this指向

- 全局作用域中或者普通函数中this指向全局对象window
- **立即执行函数（闭包）this必定指向window**——匿名函数的执行环节具有全局性
- 定时器this指向window
- 事件中this指向事件源对象
- 方法中谁调用就指向谁
- 构造函数中this指向对象实例
- **箭头函数中没有自身的`this`，所用到的`this`都是其最近父级上下文中的this**

#### **call()、apply()、bind() 方法**

**call和apply的作用一致，区别仅仅在函数实参参数传递的方式上；**这个两个方法的最大作用基本就是用来强制指定函数调用时this的指向

call

>  函数名称.call(obj,arg1,arg2...argN);
> 参数说明:
> obj:函数内this要指向的对象,
> arg1,arg2...argN :参数列表，参数与参数之间使用一个逗号隔开

apply

> 函数名称.apply(obj,[arg1,arg2...,argN])
> 参数说明:
> obj :this要指向的对象
> [arg1,arg2...argN] : 参数列表，要求格式为数组

bind

> bind(this要指向对象) 不会立即执行，并且返回一个改变this指向的函数

**bind后函数不会执行，而只是返回一个改变了上下文的另一个函数，而call和apply是直接执行函数。若无参数，apply与call基本没什么区别**



### 原型链

最基础的说白了就是 构造函数——实例——原型 三者之间的关系

原型链，简单理解就是原型组成的链。当访问一个对象（实例）的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的\_\_proto\_\_隐式原型上查找，即它的原型对象，如果还没有找到就会再在这个原型对象的\_\_proto\_\_中向上查找。



总结

- `__proto__` 存在于所有对象上，**`prototype` 只存在于函数上**
- `__proto__` 用来表示当前对象的原型对象是什么，在检索属性时方便在原型链上递归向上去查找，实现了 `obj.__proto__.__proto__...` 原型链
- `prototype` 用来表示使用此构造函数初始化的对象继承自哪个原型对象
- `__proto__` 并不是 ECMAScript 语法规范的标准，只是浏览器厂商实现的一种便于访问或修改对象内部 `[[Prototype]]` 的访问器属性，建议使用 `Object.getPrototypeOf` 替代
- `prototype` 是 ECMAScript 语法规范的标准

顺带总结一波原型

- 每个对象内部都有一个用来存放该对象原型的内部属性 `[[Prototype]]`，可以通过 `obj.__proto__` 或 `Object.getPrototypeOf / Object.setPrototypeOf` 来读写。
- 原型的本质是对象，每个原型对象自身也可能存在原型，以此类推形成原型链。
- 原型链的长度是有限的，且最终一定指向 `null`。
- 所有原型对象的根原型对象是 `Object 原型对象`, 它被内置在 `Object.prototype` 属性上。
- 每个函数自身都会有一个 `prototype` 属性，用来给其创建的对象赋予原型（即设置其创建的对象的内部属性 `[[Prototype]]`）。
- 函数 `prototype` 属性值的 `constructor` 属性指向自身。
- 构造函数 `Function` 的 `prototype` 属性和其原型（`__proto__`）都指向 `Function 原型对象`。
- `Function 原型对象` 比较特殊，是一个匿名函数，它可以先于/独立于 `Function` 产生，其原型依然是 `Object 原型对象`



`Object.prototype`有些特殊，它虽然是对象，但是并不是Object自己的实例， `Object.prototype.__proto__`指向`null`，作为原型链的终点

```
原型对象.constructor===构造函数
实例对象.__proto__===原型对象
构造函数.prototype===原型对象
```



区分指向原型的更新，以及原型内部的更新。例子：

```
let A = function() {}
A.prototype.a = 1; 
//此时 A.prototype = { a: 1 }


let B = new A(); //此时 B = {}
//在创建B时，已将B._proto_ = A.prototype = { a: 1 }
//即使后面A.prototype重新赋值，将A.prototype开辟了新的空间指向别的对象
//B._proto_并没有改，还是指向{a:1}这个对象


A.prototype = { //此时 A.prototype = { b: 2, c: 3 }
  b: 2,
  c: 3
}
let C = new A(); //C = {}
A.prototype.d = 4;//此时A.prototype = { b: 2, c: 3, d: 4 }

console.log(B.a); //1
console.log(B.b); //undefined
console.log(C.c); //3
console.log(C.d); //4

//C.d
//着重区分： A.prototype.d = 4 和 A.prototype 重新赋值 不是一个概念 
//A.prototype重新赋值时，A.prototype已经指向另一个对象了   
//A.prototype.d = 4时，访问的还是同一个A.prototype 对象 
```



### 继承

继承是面向对象编程的三大特征之一（封装、继承、多态）

#### 直接利用原型链特征实现的继承

让构造函数的`prototype`指向另一个构造函数的实例。

#### 盗用构造函数

也叫作“对象伪装”或者“经典继承”，原理就是通过在子类中call方式调用父类构造函数实现上下文的绑定。

#### 组合继承

综合了前两者的优点，取其精华去其糟粕，得到一种可以将方法定义在原型上以实现重用又可以让每个实例拥有自己的属性的继承方案。

组合继承的原理就是先通过盗用构造函数实现上下文绑定和传参，然后再使用原型链继承的手段将子构造函数的`prototype`指向父构造函数的实例，

#### 原型式继承

```js
const object = function (o) {
  function F() { }
  F.prototype = o
  return new F()
}
```

其实不难看出，这个函数将原型链继承的核心代码封装成了一个函数，但这个函数有了不同的适用场景：如果你有一个已知的对象，想在它的基础上再创建一个新对象，那么你只需要把已知对象传给`object`函数即可。

`ES5`新增了一个方法`Object.create()`将原型式继承规范化了。相比于上述的`object()`方法，`Object.create()`可以接受两个参数，第一个参数是作为新对象原型的对象，第二个参数也是个对象，里面放入需要给新对象增加的属性（可选）

#### 寄生式继承

寄生式继承与原型式继承很接近，它的思想就是在原型式继承的基础上以某种方式增强对象，然后返回这个对象。

寄生式继承的核心逻辑：

```
function inherit(Son, Father) {
  const prototype = Object.create(Father.prototype) // 获取父类原型对象副本
  prototype.constructor = Son // 将获取的副本的constructor指向子类，以此增强副本原型对象
  Son.prototype = prototype // 将子类的原型对象指向副本原型对象
}
```



#### 寄生式组合继承

通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路就是使用寄生式继承来继承父类的原型对象，然后将返回的新对象赋值给子类的原型对象。

如图，寄生组合式继承与组合式继承中的原型链关系是一样的



#### 判断构造函数与实例关系

原型与实例的关系可以用两种方式来确定：`instanceof`操作符和`isPrototypeOf()`方法。

**以`o instanceof Foo`为例，`instanceof`关键字做的事情是：判断`o`的原型链上是否有`Foo.prototype`指向的对象。**

根据`instanceof`的特性，我们可以实现一个自己`instanceof`，思路就是递归获取左侧对象的原型，判断其是否和右侧的原型对象相等，这里使用`Object.getPrototypeOf()`获取原型

`isPrototypeOf()`不关心构造函数，它只需要一个可以用来判断的对象就行。以`Foo.prototype.isPrototypeOf(o)`为例，`isPrototypeOf()`做的事情是：判断在`o`的原型链中是否出现过`Foo.prototype`。

#### new方法

**机理**

1. 创建一个新的`javaScript`对象（即 {} ）
2. 为步骤1新创建的对象添加属性`proto` ，将该属性链接至构造函数的原型对象
3. 将`this`指向这个新对象
4. 执行构造函数内部的代码（例如给新对象添加属性）
5. 如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。

如果函数创建之初就是为了结合new操作符使用，那么该函数就是一个构造函数，构造函数按照约定应首字母大写



**返回值**

当一个函数内部有return语句，且调用时加了new前缀时，两种情况：

1、return后面返回的是基本数据类型的值或者不返回，该函数返回的是new操作符创建的新的对象

**2、return后面返回的是引用数据类型的值，该函数返回的是return语句后面的内容**



### Object方法

`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。

**（1）`Object`对象本身的方法**

所谓”本身的方法“就是直接定义在`Object`对象的方法。

**（2）`Object`的实例方法**

所谓实例方法就是定义在`Object`原型对象`Object.prototype`上的方法。它可以被`Object`实例直接使用。凡是定义在`Object.prototype`对象上面的属性和方法，将被所有实例对象共享。

#### `Object`作为工具函数

`Object`本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。

```
var obj = Object();
// 等同于
var obj = Object(undefined);
var obj = Object(null);

obj instanceof Object // true
```

如果参数是原始类型的值，`Object`方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。

```
var obj = Object(1);
obj instanceof Object // true
obj instanceof Number // true
```

如果`Object`方法的参数是一个对象，它总是返回该对象，即不用转换。

```
var arr = [];
var obj = Object(arr); // 返回原数组
obj === arr // true
```

#### Object 作为构造函数

`Object`前面可以使用`new`命令当作构造函数使用，首要用途是直接通过它来生成新对象。

```
var obj = new Object();
```

`Object`构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。

```
var o1 = {a: 1};
var o2 = new Object(o1);
o1 === o2 // true

var obj = new Object(123);
obj instanceof Number // true
```

#### `Object`对象的原生方法——静态方法

##### Object.keys()

```
var obj = {
  p1: 123,
  p2: 456
};

Object.keys(obj) // ["p1", "p2"]
```

一般情况下，几乎总是使用`Object.keys`方法遍历数组的属性。

##### Object.getOwnPropertyNames()

```
var a = ['Hello', 'World'];

Object.getOwnPropertyNames(a) // ["0", "1", "length"]
```

对于一般的对象来说，`Object.keys()`和`Object.getOwnPropertyNames()`返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。**`Object.keys`方法只返回可枚举的属性，`Object.getOwnPropertyNames`方法还返回不可枚举的属性名。**



#### `Object`对象的原生方法——实例方法

- `Object.prototype.valueOf()`：返回当前对象对应的值。作用是返回一个对象的“值”，默认情况下返回对象本身。

  ```
  var obj = new Object();
  obj.valueOf() === obj // true
  ```

  `valueOf`方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。所以，如果自定义`valueOf`方法，就可以得到想要的结果。

- `Object.prototype.toString()`：返回当前对象对应的字符串形式。默认情况下返回类型字符串，可以用来判断一个值的类型

  ```
  var o1 = new Object();
  o1.toString() // "[object Object]"
  
  var o2 = {a:1};
  o2.toString() // "[object Object]"
  //其中第二个Object表示该值的构造函数。这是一个十分有用的判断数据类型的方法。
  ```

  **不同数据类型的`Object.prototype.toString`方法返回值如下。利用这个特性，可以写出一个比`typeof`运算符更准确的类型判断函数。**

  - 数值：返回`[object Number]`。
  - 字符串：返回`[object String]`。
  - 布尔值：返回`[object Boolean]`。
  - undefined：返回`[object Undefined]`。
  - null：返回`[object Null]`。
  - **数组：返回`[object Array]`。**
  - arguments 对象：返回`[object Arguments]`。
  - 函数：返回`[object Function]`。
  - Error 对象：返回`[object Error]`。
  - Date 对象：返回`[object Date]`。
  - RegExp 对象：返回`[object RegExp]`。
  - 其他对象：返回`[object Object]`。

- `Object.prototype.hasOwnProperty()`：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。

  接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。

- `Object.prototype.isPrototypeOf()`：**判断当前对象是否为另一个对象的原型**。

- `Object.prototype.propertyIsEnumerable()`：判断某个属性是否可枚举。

- `Object.prototype.toLocaleString()`：返回当前对象对应的本地字符串形式。

### array自带的函数

#### concat()

描述：连接两个或更多的数组，并返回结果。

语法：arrayObject.concat(arrayX,arrayX,……,arrayX)

参数：必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。

注意：该方法**不会改变现有的数组**，而仅仅会**返回被连接数组的一个副本**。

```
var a = [1,2,3], b=[2,3,4];
console.log(a.concat(4,5));//1,2,3,4,5
console.log(a.concat(b));//1,2,3,2,3,4
```

#### slice()

描述：从已有的数组中返回选定的元素。

语法：array.slice(start, end)

参数：

start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。

end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。

注意：该方法**不会改变现有的数组**，而仅仅会**返回一个新的数组**。

```
var a = [1,2,3,4];
console.log(a.slice(0,2));//[1, 2]
```

#### join()

描述：将所有的数组元素连接成一个字符串。元素是通过指定的分隔符进行分隔的。

语法：arrayObject.join(separator)

参数：可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。

注意：该方法**不会改变现有的数组**，而仅仅会**返回一个字符串**。

```
var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"
console.log(arr.join());//George,John,Thomas
console.log(arr.join("_"));//George_John_Thomas
```

#### pop()

描述：删除并返回数组的**最后一个**元素。

语法：arrayObject.pop()

参数：无

注意：**该方法会修改原数组**。但是如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。

#### shift()

描述：删除并返回数组的**第一个**元素。

语法：arrayObject.shift()

参数：无

注意：**该方法会修改原数组**。但是如果数组已经为空，则 shift()不改变数组，并返回 undefined 值。

#### push()

描述：可向数组的**末尾添加**一个或多个元素，并返回新的长度。

语法：arrayObject.push(arr1,arr2,….,arrx)

参数：至少要有一个元素

注意：**该方法会修改原数组，并返回新数组的长度，而不是新的数组。**

#### unshift()

描述：可向数组的开头添加一个或多个元素，并返回新的长度。

语法：arrayObject.unshift(arr1,arr2,….,arrx)

参数：至少要有一个元素

注意：该方法会修改原数组。并返回新数组的长度，而不是新的数组。

#### splice()

描述：向数组中添加/删除项目，然后返回被删除的项目。

语法：arrayObject.splice(index,howmany,item1,…..,itemX)

参数：
index：必需。整数，规定**添加/删除项目的位置**，使用负数可从数组结尾处规定位置。
howmany：必需。**要删除的项目数量**。如果设置为 0，则不会删除项目。
item1, …, itemX：可选。**向数组添加的新项目**。

注意：该方法**会改变原始数组**。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。

```
var arr = ["A","B","C","D"];
//在位置2插入“新元素1”
arr.splice(2,0,"新元素1")
console.log(arr);//"A", "B", "新元素1", "C", "D"
```

#### sort()

描述：用于对数组的元素进行排序，该方法没有返回值。

语法：arrayObject.sort(sortby)

参数：可选。规定排序顺序。**必须是函数**。

> 比较函数应该具有两个参数 a 和 b，其返回值如下：
> 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
> 若 a 等于 b，则返回 0。
> 若 a 大于 b，则返回一个大于 0 的值。

注意：**该方法会改变原始数组。没参数时，sort()方法默认将所有的数组元素**转化成字符串来进行比较排序，即按照字符编码的顺序进行排序！

#### reverse()

描述：颠倒数组中元素的顺序。

语法：arrayObject.reverse()

#### find()

描述：返回传入一个测试条件（函数）符合条件的数组第一个元素。

语法：array.find(function(currentValue, index, arr),thisValue)

#### findIndex()

描述：返回传入一个测试条件（函数）符合条件的数组第一个元素位置。如果没有符合条件的元素返回 -1。

语法：array.findIndex(function(currentValue, index, arr),thisValue)

#### indexOf()

描述：返回某个指定元素在数组中首次出现的位置。如果没有符合条件的元素返回 -1。

语法：array.indexOf(item,start)

#### lastIndexOf()

描述：返回某个指定元素在数组中首次出现的位置。如果没有符合条件的元素返回 -1。

语法：array.lastIndexOf(item,start)

#### every()

描述：检测数组所有元素是否都符合指定条件（通过函数提供），如果所有元素都通过检测返回 true，否则返回 false。

语法：array.every(function(currentValue,index,arr), thisValue)

#### some()

描述：检测数组中的元素是否满足指定条件（函数提供），如果有元素通过检测返回 true（并停止检测），否则返回 false。

语法：array.some(function(currentValue,index,arr), thisValue)

#### filter()

描述：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。**如果没有符合条件的元素则返回空数组。**

语法：array.every(function(currentValue,index,arr), thisValue)

#### map()

描述：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

语法：array.map(function(currentValue,index,arr), thisValue)

#### reduce()

描述：按序执行一个由您提供的 **reducer** 函数，每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值

语法：arr.reduce(function(prev,cur,index,arr), init)

```
//数组求和
var arr = [1,2,3,4];
var sum = arr.reduce((prev,cur)=>{
   return prev + cur;
}) // 10
```

#### array.from

允许在 `JavaScript` 集合(如: 数组、类数组对象、或者是字符串、`map` 、`set` 等可迭代对象) 上进行有用的转换。

### string自带的函数

#### length

用来获取字符串的长度

```javascript
const str = 'hello';
str.length   // 输出结果：5
```

#### charAt()

可以返回指定位置的字符。

```javascript
const str = 'hello';
str.charAt(1)  // 输出结果：e 
```

当index的取值不在str的长度范围内时，str[index]会返回undefined，而charAt(index)会返回空字符串

#### charCodeAt()

该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 **NaN**：

```
let str = "abcdefg";
console.log(str.charCodeAt(1)); // "b" --> 98
```

#### indexOf()

该方法有两个参数：

- searchvalue：必需，规定需检索的字符串值；
- fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。

```javascript
let str = "abcdefgabc";
console.log(str.indexOf("a"));   // 输出结果：0
console.log(str.indexOf("z"));   // 输出结果：-1
console.log(str.indexOf("c", 4)) // 输出结果：9
```

#### lastIndexOf()

查找某个字符，有则返回最后一次匹配到的位置，否则返回-1

#### includes()

该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false

```
let str = 'Hello world!';
str.includes('o')  // 输出结果：true
```

#### startsWith()

该方法用于检测字符串**是否以指定的子字符串开始**。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。

#### endsWith()

该方法用来判断当前字符串**是否是以指定的子字符串结尾**。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。

#### concat() 

concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。

其中参数 string1, string2, ..., stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。

```javascript
let str = "abc";
console.log(str.concat("efg"));          //输出结果："abcefg"
console.log(str.concat("efg","hijk")); //输出结果："abcefghijk"
```

虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。

#### split() 

用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：

```javascript
string.split(separator,limit)
```

该方法有两个参数：

- separator：必需。字符串或正则表达式，从该参数指定的地方分割 string。
- limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。

```javascript
let str = "abcdef";
str.split("c");    // 输出结果：["ab", "def"]
str.split("", 4)   // 输出结果：['a', 'b', 'c', 'd'] 
```

#### slice()

slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：

```javascript
string.slice(start,end)
```

该方法有两个参数：

- start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。
- end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。

#### substr()

substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：

```javascript
string.substr(start,length)
```

该方法有两个参数：

- start	必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。
- length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。

#### substring()

substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：

```javascript
string.substring(from, to)
```

#### replace()

该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：

```javascript
string.replace(searchvalue, newvalue)
```

#### match()

该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。

#### trim()

trim() 方法用于移除字符串首尾空白符，该方法**不会改变原始字符串**

#### toString()

返回字符串对象本身

#### repeat() 

返回一个新字符串，表示将原字符串重复n次：

```javascript
'x'.repeat(3)     // 输出结果："xxx"
'hello'.repeat(2) // 输出结果："hellohello"
'na'.repeat(0)    // 输出结果：""
```

如果参数是小数，会向下取整

#### padStart()

`padStart()`用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 

如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：

```javascript
'x'.padStart(1, 'ab') // 'x'
```

如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：

```javascript
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'
```

如果省略第二个参数，默认使用空格补全长度：

```javascript
'x'.padStart(4) // '   x'
```

padStart()的常见用途是为数值补全指定位数，比如第1页就显示为001，就可以使用该方法来操作



### web的事件循环

#### 缘起

js是单线程的，一般是自上而下按照顺序执行。但js中包含诸多创建异步的函数如:seTimeout，setInterval，dom事件，ajax，Promise，process.nextTick等函数，导致代码输出顺序被打乱

1. 因为单线程，所以代码自上而下执行，所有代码被放到`执行栈`中执行；

2. 遇到异步函数将回调函数添加到一个`任务队列（分为宏任务和微任务）`里面；
3. 当`执行栈`中的代码执行完以后，会去循环`任务队列`里的函数;
4. 将`任务队列`里的函数放到`执行栈`中执行;
5. 如此往复，称为`事件循环`;

#### 异步

**写在Promise中的代码是被当做同步任务立即执行的**。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。

await是一个让出线程的标志，await这一句的表达式会直接执行，而await这一句的后面那些行的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。

#### 微队列、宏队列

异步任务被分为两种，`宏队列`与`微队列`。它们负责将任务放入`执行栈`中执行

**宏队列**，macrotask，也叫tasks。异步任务的回调会依次进入macro task queue，等待后续被调用

宏任务的例子包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。重新渲染页面的UI或执行垃圾回收。

- **setTimeout**
- setInterval
- setImmediate (Node独有)
- requestAnimationFrame (浏览器独有)
- **I/O**
- **UI rendering (浏览器独有)**



**微队列**，microtask，也叫jobs。异步任务的回调会依次进入micro task queue，等待后续被调用

微任务的案例包括promise回调函数、DOM发生变化等。

- **process.nextTick (Node独有)**
- **Promise**
- Object.observe
- MutationObserver

#### 事件循环（非常重要）

1执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；

2全局Script代码执行完毕后，`执行栈`Stack会清空；

3从`微队列`中取出位于队首的回调任务，放入`执行栈`Stack中执行，执行完后`微队列`长度减1；

4继续循环取出位于`微队列`的任务，放入`执行栈`Stack中执行，以此类推，直到直到把`微任务`执行完毕。注意，如果在执行`微任务`的过程中，又产生了`微任务`，那么会加入到`微队列`的末尾，也会在这个周期被调用执行；

5`微队列`中的所有`微任务`都执行完毕，此时`微队列`为空队列，`执行栈`Stack也为空；

6取出`宏队列`中的一个任务，放入`执行栈`Stack中执行

7执行完毕后，`执行栈`Stack为空；每个宏任务执行完毕，都会去判断微任务队列是否有新任务，不为空。若不为空就回到3，执行微任务，否则按序执行宏任务。

> 先微任务后宏任务，及时保证清空微任务

#### 事件循环与DOM

执行 JS 同步代码（异步函数分别放在 macroTaskQueue 和 microTaskQueue ）

DOM 结构渲染（此时还没有在页面显示，但可以获取 DOM 内容了）

执行 microTaskQueue 函数（异步中还可能嵌套异步...）

显示 DOM 到页面

执行 macroTaskQueue 函数（异步中还可能嵌套异步...）

……

#### nodejs的事件循环

跟浏览器的有所不同，见nodejs相关章节

### 闭包

#### 概念

**1、外部函数执行中，外部函数的自由变量被内部函数引用了，形成不销毁的栈内存**

**2、内部函数的定义域和执行域不一样**

#### 用途

- 让这些变量的值始终保持在内存中。不会在f1调用后被自动清除。

- **方便调用上下文的局部变量。**利于代码封装，防止变量污染全局，防止取到意外的值

举例：f1是f2的父函数，f2被赋给了一个全局变量，f2始终存在内存中，f2的存在依赖f1，因此f1也始终存在内存中，不会在调用结束后，被垃圾回收机制回收。

> 闭包你实际中使用最多不是保存变量这些忽悠人的。是防抖和节流





#### 缺点

闭包容易产生内存泄漏——**当内存中产生了不能被回收的变量，就叫内存泄漏**（只要页面不关闭，这个变量就一直在，导致存在内存泄漏的问题）

### 垃圾回收机制

当内存不再需要使用时，需要将其释放，这里最艰难的任务是**找到“哪些被分配的内存确实已经不再需要了”**。这就需要垃圾回收机制来判定了。

#### 引用计数垃圾收集

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。

but，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

#### 标记-清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

**所有现代浏览器都使用了标记-清除垃圾回收算法**。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

### 深拷贝浅拷贝

`JavaScript`中存在两大数据类型：

- **基本类型，保存在在栈内存中**
- **引用类型，保存在堆内存中**，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中

浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。即**浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址**

深拷贝：开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

### 不同类型间的比较

#### ===

三等号必须完全相同才是true

> +0 和 -0 认为是全等的

#### !(逻辑非):

将其后变量或表达式转为布尔值

> “假值”总共只有6个：
> **false，undefined，null，0，""（空字符串），NaN**
> 除此之外的所有值，都是“真值”，即在逻辑判断中可以当true来使

#### ==

当进行双等号比较时候： 先检查两个操作数数据类型，如果相同，则进行\=\==比较

相等操作符对于不同类型的值，进行的比较如下图所示：

|           | Undefined | Null    | Number                | String                        | Boolean                         | Object                          |
| --------- | --------- | ------- | --------------------- | ----------------------------- | ------------------------------- | ------------------------------- |
| Undefined | `true`    | `true`  | `false`               | `false`                       | `false`                         | `IsFalsy(B)`                    |
| Null      | `true`    | `true`  | `false`               | `false`                       | `false`                         | `IsFalsy(B)`                    |
| Number    | `false`   | `false` | `A === B`             | `A === ToNumber(B)`           | `A=== ToNumber(B)`              | `A== ToPrimitive(B)`            |
| String    | `false`   | `false` | `ToNumber(A) === B`   | `A === B`                     | `ToNumber(A) === ToNumber(B)`   | `ToPrimitive(B) == A`           |
| Boolean   | `false`   | `false` | `ToNumber(A) === B`   | `ToNumber(A) === ToNumber(B)` | `A === B`                       | `ToNumber(A) == ToPrimitive(B)` |
| Object    | `false`   | `false` | `ToPrimitive(A) == B` | `ToPrimitive(A) == B`         | `ToPrimitive(A) == ToNumber(B)` | `A === B`                       |

注1：ToNumber()：

| 输入类型  | 结果                                                         |
| --------- | ------------------------------------------------------------ |
| Undefined | NaN                                                          |
| Null      | +0                                                           |
| Boolean   | 如果参数是true，结果为1 如果参数是false，此结果为+0          |
| Number    | 结果等于输入的参数（不转换）                                 |
| String    | 情况比较多，参考规范                                         |
| Object    | 依次调用 1.先获取原始值调用ToPrimitive（输入参数type为number） 2.再将原始类型调用ToNumber（原始值） |

注2：NaN和其他任何类型比较永远返回false

注3：当均为 `object`时，若`a、b` 指向同一个对象，返回 **true**；若 `a、b`都为 `null` 返回 **true**，否则返回 **false**；

注4：ToPrimitive引起了一些令人意想不到的情况，也是考题经常考的



#### object.is

 `Object.is`并不比双等更宽松，也并不比三等更严格，当然也不是在他们中间。从下表中可以看出，这是由于 [`Object.is`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 处理 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 的不同。

| x     | y     | `==`    | `===`   | `Object.is` |
| :---- | :---- | :------ | :------ | :---------- |
| `+0`  | `-0`  | `true`  | `true`  | `false`     |
| `NaN` | `NaN` | `false` | `false` | `true`      |



### 不同类型间的转化

#### ToPrimitive()

当JS需要将尝试将对象数据类型转换为基本数据类型的时候，就会优先度最高地调用这个方法。

type参数可以为空，这时候type的默认值会按照下面的规则设置：

- 该对象为Date，则type被设置为String；
- 否则，type被设置为Number

内置运行tostring和valueof函数

如果是基本数据类型，就不操作，直接返回。否则按照type决定先用tostring还是valueof转为基本数据类型。都不能转为基本数据类型的话，就报错

```js
true == [] // false，[] 被转化成'' => 0
true == ![] // false, 转化成 true == !true；
true == !![] // true, 转化成 true == !!true；
// 同理
false == [] // true
false == ![] // true
false == !![] // false
[] == ![] // true 本质上是[] == false; 转换为 '' == false  =>  0 == 0  =>  true
```

**这是因为在js中，引用数据类型转化为`boolean`会被转为true，因此`[]`加上 `!` 之后 会先将`[]`转为 true，再进行取反，结果就为 false 。**



#### valueOf()

valueOf 方法返回当前对象所对应的基本数据类型值。如果当前对象无法获取到对应的基本数据类型，那么会将对象本身原封不动的返回

当调用valueOf方法时，步骤如下：

1. 调用ToObject方法得到一个对象
2. 原始数据类型转换为对应的内置对象，引用类型（Object）则不变
3. 调用该对象内置的valueOf方法（继承自Object.prototype对象） 不同内置对象的valueOf实现：

- String => 返回字符串值
- Number => 返回数字值
- Date => 返回一个数字，即时间值,字符串中内容是依赖于具体实现的
- Boolean => 返回Boolean的this值
- Object => 返回this



#### toString 、**String()**

- toString() 可以将所有的数据都转换为字符串，但要排除 null 和 undefined，null 和 undefined 调用 toString() 方法会报错。若当前数据为数字类型，则 toString() 括号中可以写一个数字代表进制，可以将数字转化为对应进制字符串

- String() 可以将 null 和 undefined 转换为字符串，但是没法转进制字符串

```js
{}.toString()    // [object Object] 
//返回对象类型 "[object type]"。type 指的是对象本身的类型识别，例如 Math 对象是返回 "[object Math]" 字符串
[].toString() // ''
```

#### Boolean

除了以下六个值，其他都是自动转为true：

- undefined
- null
- -0
- +0
- NaN
- ‘’（空字符串）

#### 实操隐式转化

主要是很多时候都是隐式转化，不知道用的那条路，这样就会形成考题。常考的主要有`[]` `{}`

做两道题

##### +运算

```js
1+'2'+false // '12false'
// 我们来拆解一下运算过程：
// 按执行顺序从左到右执行，先计算1+'2'
// 1. 左右两边同事进行ToPrimitive()操作，左边为原始类型，依旧是Number，右边为String
// 2. 因为返回的原始值当中包含String，于是对所有原始值进行toString处理，变为 '1'+'2'，得到结果'12'
// 3. 然后重复第一步操作，计算'12'+false
// 4. 左右两边都为原始值，但是'12'为String类型，则布尔值也转为'false'
// 5. '12'+'false' 进行拼接得到最后结果 '12false'
```



##### 引用类型进行计算

```js
var obj1 = {
    valueOf:function(){
        return 1
    }
}
var obj2 = {
    toString:function(){
        return 'a'
    }
}
// 下面我们还是拆解一下运算过程
1+obj1 // 2
// 1. 左右两边同时进行ToPrimitive()操作，左边为原始类型，依旧是Number，右边为引用类型，按照type为number进行转换
// 2. 先调用obj1.valueOf方法，我们知道引用类型不会进行包装，于是直接调用obj1内部的valueOf方法，返回1
// 3. 得到两边都是number类型，于是直接进行相加1 + 1，输出2
1+obj2 // 1a
// 1. 左右两边同时进行ToPrimitive()操作，左边为原始类型，依旧是Number，右边为引用类型，按照type为number进行转换
// 2. 先调用obj2.valueOf方法，我们知道引用类型不会进行包装，于是直接调用obj2内部的valueOf方法，因为valueOf方法没有重写，于是调用的是Object.prototype.valueOf返回的是obj2的this，发现得到的不是一个原始值，于是继续调用toString方法，返回 'a'
// 3. 得到2个原始类型后发现，其中包含String类型，于是调用toString全部转为string类型，得到'1'+'a'
// 4. 最终拼接出结果 '1a'
obj1+obj2
// 1.左右两边同时进行ToPrimitive()操作，根据上边的运算，我们知道obj1返回数值类型1，obj2返回是字符类型'a'
// 2.得到2个原始类型后发现，其中包含String类型，于是调用toString全部转为string类型，得到'1'+'a'
// 3. 最终拼接出结果 '1a'
```



##### 为什么{} + [] = 0 而 [] + {} = '[object Object]'

`{} + []` 当语句开始为`{`时，会被JS解释器认为是代码块，所以实质上运算的是`+[]`，将空数组转为Number，得0

`[] + {}`使用 ToPrimitive 方法，`[]`转为`''`，而`{}`转为`[object Object]`，最终相加得`[object Object]`





### 判断数据类型

1.typeof

`typeof` 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 `undefined`、 `boolean`、`string`、 `number`、`Symbol` 和引用数据类型 `function` 都可以正确判断，但是对 null、数组、对象则统一返回 “object”。

> Undefined"undefined"
>String"string"
> Symbol"symbol"
>其他任何对象"object"
> Null"object"
>Number"number"
> Boolean"boolean"
>BigInt"bigint"
> Function"function"

2.instanceof

obj instanceof Object，**左边操作数obj为对象**（如果不小心写成基本类型 比如数字啥的，就会返回false），**右边操作数Object为函数对象或者是函数构造器**，否则抛出TypeError。

```
var x = [1, 2, 3];
var y = {};
x instanceof Array // true
y instanceof Object // true

var s = 'hello';
s instanceof String // false，因为s不是对象
```



3.Object.prototype.toString.call()

toString是**最精确的类型判断方式**之一

不同数据类型的`Object.prototype.toString`方法返回值如下

> undefined：返回[object Undefined]。
> 字符串：返回[object String]。
> 其他对象：返回[object Object]。
> 数值：返回[object Number]。
> null：返回[object Null]。
> 布尔值：返回[object Boolean]。
>
> 数组：返回[object Array]。
> arguments 对象：返回[object Arguments]。
> 函数：返回[object Function]。
> Error 对象：返回[object Error]。
> Date 对象：返回[object Date]。
> RegExp 对象：返回[object RegExp]。



### JS全局函数

个人记忆方法：6（编码相关）+ 2（数据处理）+ 4（数字相关）+ 1（特殊） 

编码相关： 

​    escape()、unescape()、encodeURI()、decodeURI()、 

​    encodeURIComponent()、decodeURIComponent() 

数据处理： 

​    Number()、String() 

数字相关： 

​    isFinite()、isNaN()、parseFloat()、parseInt() 

特殊： 

​    eval()



## ES6

### let、const 关键字

在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量

在相同的作用域或块级作用域中，不能使用 var 关键字来重置 let 关键字声明的变量

#### let

1. 不允许重复声明

2. 不存在变量提升
   `var`命令会发生“变量提升”现象，即变量可以在声明之前使用，值为`undefined`。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用

3. 暂时性死区
   只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

   ```
   var tmp = 123;
   if (true) {
     tmp = 'abc'; // ReferenceError
     let tmp;
   }
   ```

   上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对`tmp`赋值会报错。

   **“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。**

4. 块级作用域（局部变量）

   **var只有全局作用域和函数作用域，没有块级作用域，**这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量；第二种场景，用来计数的循环变量泄露为全局变量。

   块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

#### const

基本与let一致

1.  声明必须赋初始值
4.  值不允许修改

**const 仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。**

#### ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：`var`命令和`function`命令。

ES6 除了添加`let`和`const`命令，

另外两种声明变量的方法：`import`命令和`class`命令。

#### 顶层对象和全局变量脱钩

`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性

**另一方面，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。**

```
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

ES6引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。



### 解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值

#### 数组的解构

本质上，解构属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

```
let [a, b, c] = [1, 2, 3];
let [foo, [[bar], baz]] = [1, [[2], 3]];
let [x, , y] = [1, 2, 3];
```

如果解构不成功，变量的值就等于undefined。

```
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。


```\
let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

**对于 Set 结构，或者某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。如果等号的右边不是可遍历的结构，那么将会报错。**



默认值：

```
let [foo = true] = [];
foo // true
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

注意，**ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值**。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。

```
let [x = 1] = [undefined];
x // 1
let [x = 1] = [null];
x // null
```



#### 对象的解构

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果解构失败，变量的值等于`undefined`。

对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'

let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

解构也可以用于嵌套结构的对象，但要注意模式和变量的区别

```
const node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

let { loc, loc: { start }, loc: { start: { line }} } = node;
line // 1
loc  // Object {start: Object}
start // Object {line: 1, column: 5}
```

默认值生效的条件是，对象的属性值严格等于`undefined`，跟array一样的。

```
var {x = 3} = {x: undefined};
x // 3
var {x = 3} = {x: null};
x // null
```



#### 函数参数的解构

```
[[1, 2], [3, 4]].map(([a, b]) => a + b); // [ 3, 7 ]

function move({x = 0, y = 0} = {}) {
  return [x, y];
}
```



#### 用途

1. 交换变量 `[x, y] = [y, x];`

2. 从函数返回多个值

   函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。

   ```
   function example() {
     return [1, 2, 3];
   }
   let [a, b, c] = example();
   ```

3. 函数参数的定义

4. **提取 JSON 对象中的数据，尤其有用**

5. 函数参数的默认值

6. **遍历 Map 结构**

   任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

   ```
   const map = new Map();
   map.set('first', 'hello');
   map.set('second', 'world');
   for (let [key, value] of map) {
     console.log(key + " is " + value);
   }
   // first is hello
   // second is world
   ```

   

### 字符串的扩展

#### 字符的unicode

允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。只要将码点放入大括号，就能正确解读该字符

```javascript
"\uD842\uDFB7"
// "𠮷"
"\u{41}\u{42}\u{43}"
// "ABC"
```

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

```javascript
'\z' === 'z'  // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

#### 字符串的遍历器接口

ES6 为字符串添加了遍历器接口，使得字符串可以被`for...of`循环遍历。**这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。**

#### 模板字符串

模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。

模板字符串中嵌入变量，需要将变量名写在`${}`之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。

```javascript
$('#result').append(`
  There are <b>${basket.count}</b> items
   in your basket, <em>${basket.onSale}</em>
  are on sale!
`);

`${x} + ${y * 2} = ${x + y * 2}`
```

### 字符串的新增方法

#### String.fromCodePoint()

可以识别大于`0xFFFF`的字符，弥补了`String.fromCharCode()`方法的不足

```
String.fromCodePoint(0x20BB7)
// "𠮷"
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
```

#### String.raw()

#### 实例对象codePointAt()

ES6 提供了`codePointAt()`方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

```
let s = '𠮷a';
s.codePointAt(0) // 134071
s.codePointAt(1) // 57271
s.codePointAt(2) // 97
```

`codePointAt()`方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的`20BB7`）。

但是a被视为第3个字母，解决这个问题的一个办法是使用`for...of`循环，因为它会正确识别 32 位的 UTF-16 字符。

#### 实例对象normalize()

#### 实例对象includes(), startsWith(), endsWith(), startsWith(), endsWith()

传统上，JavaScript 只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。

- includes()：返回布尔值，表示是否找到了参数字符串。
- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

```
let s = 'Hello world!';

s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true
```

这三个方法都支持第二个参数，表示开始搜索的位置。`endsWith`的行为与其他两个方法有所不同。它针对前`n`个字符，而其他两个方法针对从第`n`个位置直到字符串结束。

#### 实例对象repeat()

`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。如果`repeat`的参数是字符串，则会先转换成数字。参数`NaN`等同于 0。

#### 实例对象padStart()，padEnd()

如果某个字符串不够指定长度，会在头部或尾部补全。`padStart()`用于头部补全，`padEnd()`用于尾部补全。`padStart()`和`padEnd()`一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。

如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。

如果省略第二个参数，默认使用空格补全长度。

```
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
'x'.padEnd(4, 'ab') // 'xaba'
```

#### 实例对象trimStart()，trimEnd()

行为与`trim()`一致，`trimStart()`消除字符串头部的空格，`trimEnd()`消除尾部的空格。它们**返回的都是新字符串，不会修改原始字符串。**

`trimLeft()`是`trimStart()`的别名，`trimRight()`是`trimEnd()`的别名。

#### 实例对象matchAll()

#### 实例对象replaceAll()

历史上，字符串的实例方法`replace()`只能替换第一个匹配。`replaceAll()`方法，可以一次性替换所有匹配。

```
'aabbcc'.replace('b', '_')
// 'aa_bcc'
'aabbcc'.replaceAll('b', '_')
// 'aa__cc'
```

它的用法与`replace()`相同，返回一个新字符串，不会改变原字符串。

`replaceAll()`的第二个参数`replacement`是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。

- `$&`：匹配的字符串。
- $` ：匹配结果前面的文本。
- `$'`：匹配结果后面的文本。
- `$n`：匹配成功的第`n`组内容，`n`是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。
- `$$`：指代美元符号`$`。

`replaceAll()`的第二个参数`replacement`除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数`searchValue`匹配的文本。

#### 实例对象at()

`at()`方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。如果参数位置超出了字符串范围，`at()`返回`undefined`。



### 字符串原有方法



### 数值的扩展

#### 二进制和八进制表示法

ES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。

如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`Number`方法。

```
Number('0b111')  // 7
Number('0o10')  // 8
```

#### 数值分隔符

欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，`1000`可以写作`1,000`。

ES2021允许 JavaScript 的数值使用下划线（`_`）作为分隔符。

```
let budget = 1_000_000_000_000;
budget === 10 ** 12 // true
```

数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。除了十进制，其他进制的数值也可以使用分隔符。

但是内部存储和输出的时候，都不会有数值分隔符。

下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是语言的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。Number() parseInt() parseFloat()

```
Number('123_456') // NaN
parseInt('123_456') // 123
```

#### Number.isFinite(), Number.isNaN()

ES6 在`Number`对象上，新提供了`Number.isFinite()`和`Number.isNaN()`两个方法。

`Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是`Infinity`。注意，如果参数类型不是数值，`Number.isFinite`一律返回`false`。

`Number.isNaN()`用来检查一个值是否为`NaN`。如果参数类型不是`NaN`，`Number.isNaN`一律返回`false`。

**它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，**

#### Number.parseInt(), Number.parseFloat()

ES6 将全局方法`parseInt()`和`parseFloat()`，移植到`Number`对象上面，行为完全保持不变。

#### Number.isInteger()

`Number.isInteger()`用来判断一个数值是否为整数。

注意：由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，`Number.isInteger`可能会误判。

**如果对数据精度的要求较高，不建议使用`Number.isInteger()`判断一个数值是否为整数。**

#### Number.EPSILON

实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了

```
Number.EPSILON === Math.pow(2, -52)
// true
Number.EPSILON
// 2.220446049250313e-16
```

#### 安全整数和 Number.isSafeInteger()

JavaScript 能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`这两个常量，用来表示这个范围的上下限。

```
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true
```

`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内。实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。

#### Math 对象的扩展

ES6 在 Math 对象上新增了 17 个与数学相关的方法。

#### BigInt

ES2020引入了一种新的数据类型 BigInt（大整数），来解决所有数字都保存成 64 位浮点数的问题，**这是 ECMAScript 的第八种数据类型**。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。

为了与 Number 类型区别，BigInt 类型的数据必须添加后缀`n`。BigInt 同样可以使用各种进制表示，都要加上后缀`n`。BigInt 与普通整数是两种值，它们之间并不相等。

JavaScript 原生提供`BigInt`函数，可以用它生成 BigInt 类型的数值。转换规则基本与`Number()`一致，将其他类型的值转为 BigInt。



### 函数的扩展

#### 函数参数默认值

ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。参数变量是默认声明的，所以不能用`let`或`const`再次声明。使用参数默认值时，函数不能有同名参数。

```
function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

const p = new Point();
p // { x: 0, y: 0 }
```

另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

##### 结合解构赋值的默认值

```
function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
  console.log(method);
}

fetch('http://example.com')
// "GET"
```

上面代码中，函数`fetch`没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量`method`才会取到默认值`GET`。

**注意，函数参数的默认值生效以后，参数解构赋值依然会进行。**

#### rest参数

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

函数的`length`属性，不包括 rest 参数。

#### 箭头函数

ES6允许使用箭头（=>）定义函数，箭头函数提供了一种更加简洁的函数书写方式，箭头函数多用于匿名函数的定义

```
// 普通函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);
```

特点:

3. **箭头函数 this 指向声明时所在作用域下 this 的值**
4. 不可以当作构造函数，也就是说，不可以对箭头函数使用`new`命令，否则会抛出一个错误。
3. 没有prototype属性
4. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数

除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`。

另外，由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。

##### 不适用场合

由于箭头函数使得`this`从“动态”变成“静态”，下面两个场合不应该使用箭头函数。

（1）定义对象的方法，且该方法内部包括`this`。

```
例1
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```
this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。
```
例二
globalThis.s = 21;

const obj = {
  s: 42,
  m: () => console.log(this.s)
};

obj.m() // 21
```

**JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给`obj.m`，这导致箭头函数内部的`this`指向全局对象，**所以`obj.m()`输出的是全局空间的`21`，而不是对象内部的`42`。

由于上面这个原因，**对象的属性建议使用传统的写法定义，不要用箭头函数定义。**

（2）需要动态`this`的时候，也不应使用箭头函数。

#### 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。

```
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时

function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

这样写的斐波那契的缺点就是不太直观，第一眼很难看出来，为什么计算`5`的阶乘，需要传入两个参数`5`和`1`？

函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。另外，也可以采用 ES6 的函数默认值。

```javascript
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
```

#### Function.prototype.toString()

ES2019对函数实例的`toString()`方法做出了修改。

`toString()`方法返回函数代码本身，以前会省略注释和空格。修改后的`toString()`方法，明确要求返回一模一样的原始代码。

### 数组的扩展

#### 扩展运算符

扩展运算符好比 rest 参数的逆运算，该运算符将一个数组，变为参数序列。

**任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组**。如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错

```
const args = [0, 1];
f(-1, ...args, 2, ...[3]);

const arr = [
  ...(x > 0 ? ['a'] : []),
  'b',
];
```

扩展运算符与正常的函数参数可以结合使用，非常灵活。扩展运算符后面还可以放置表达式。

#### 应用场景

(1)替代函数的 apply() 方法

由于扩展运算符可以展开数组，所以不再需要`apply()`方法将数组转为函数的参数了。

```
// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
```

(2)数组的合并

也可以直接用arr1.push(...arr2)

```
// const arr3 = arr1.concat(arr2);
const arr3 = [...arr1, ...arr2];
```

(3)数组的克隆

数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。

(4)与解构赋值结合

```
 // ES5
   a = list[0], rest = list.slice(1)

   // ES6
   [a, ...rest] = list
```

(5)扩展运算符还可以将字符串转为真正的数组。有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。

```
   'x\uD83D\uDE80y'.length // 4
   [...'x\uD83D\uDE80y'].length // 3
```

#### Array.from()

**`Array.from()`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。**

所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from()`方法转为数组，而此时扩展运算符就无法转换。

如果参数是一个真正的数组，`Array.from()`会返回一个一模一样的新数组。

```
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5 的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6 的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```




#### Array.of()

`Array.of()`方法用于将一组值，转换为数组。主要目的，是弥补数组构造函数`Array()`的不足，因为参数个数的不同，会导致`Array()`的行为有差异。`Array.of()`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。

   ```
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
   ```

#### 实例方法：copyWithin()

在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。

也就是说，**使用这个方法，会修改当前数组。**

它接受三个参数。

- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

#### 实例方法：find()，findIndex()，findLast()，findLastIndex()

数组实例的`find()`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。

数组实例的`findIndex()`方法的用法与`find()`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。

另外，这两个方法都可以发现`NaN`，弥补了数组的`indexOf()`方法的不足。

```
[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

ES2022新增了两个方法`findLast()`和`findLastIndex()`，从数组的最后一个成员开始，依次向前检查，其他都保持不变。

#### 实例方法：fill()

`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。

`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

#### 实例方法：entries()，keys() 和 values()

ES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

```
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

如果不使用`for...of`循环，可以手动调用遍历器对象的`next`方法，进行遍历。

#### 实例方法：includes()

`Array.prototype.includes`方法返回一个布尔值，**表示某个数组是否包含给定的值，与字符串的`includes`方法类似。**ES2016 引入了该方法。

该方法的第二个参数表示搜索的起始位置，默认为`0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为`-4`，但数组长度为`3`），则会重置为从`0`开始。

`includes`使用的是不同于`indexOf`的判断算法，就**没有NaN的问题**

#### 实例方法：flat()，flatMap()

数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。

```
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
```

`flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1。

`flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组。

```
[2, 3, 4].flatMap((x) => [x, x * 2])
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
// [2, 4, 3, 6, 4, 8]
```

#### 实例方法：at()

长久以来，JavaScript 不支持数组的负索引，如果要引用数组的最后一个成员，不能写成`arr[-1]`，只能使用`arr[arr.length - 1]`。

这是**因为方括号运算符`[]`在 JavaScript 语言里面，不仅用于数组，还用于对象。对于对象来说，方括号里面就是键名，比如`obj[1]`引用的是键名为字符串`1`的键，同理`obj[-1]`引用的是键名为字符串`-1`的键。**由于 JavaScript 的数组是特殊的对象，所以方括号里面的负数无法再有其他语义了，也就是说，不可能添加新语法来支持负索引。

为了解决这个问题，ES2022为数组实例增加了`at()`方法，接受一个整数作为参数，返回对应位置的成员，并支持负索引。这个方法不仅可用于数组，也可用于字符串和类型数组（TypedArray）。

#### 实例方法：toReversed()，toSorted()，toSpliced()，with()

很多数组的传统方法会改变原数组，比如**`push()`、`pop()`、`shift()`、`unshift()`等等。数组只要调用了这些方法，它的值就变了。**

现在有一个提案，允许**对数组进行操作时，不改变原数组，而返回一个原数组的拷贝**。

这样的方法一共有四个。

- `toReversed()`对应`reverse()`，用来颠倒数组成员的位置。
- `toSorted()`对应`sort()`，用来对数组成员排序。
- `toSpliced()`对应`splice()`，用来在指定位置，删除指定数量的成员，并插入新成员。
- `with(index, value)`对应`splice(index, 1, value)`，用来将指定位置的成员替换为新的值。

#### 实例方法：group()，groupToMap()

`group()`的参数是一个分组函数，原数组的每个成员都会依次执行这个函数，确定自己是哪一个组。

```
const array = [1, 2, 3, 4, 5];

array.group((num, index, array) => {
  return num % 2 === 0 ? 'even': 'odd';
});
// { odd: [1, 3, 5], even: [2, 4] }
```

`group()`的分组函数可以接受三个参数，依次是数组的当前成员、该成员的位置序号、原数组（上例是`num`、`index`和`array`）。分组函数的返回值应该是字符串（或者可以自动转为字符串），以作为分组后的组名。

**`groupToMap()`的作用和用法与`group()`完全一致，唯一的区别是返回值是一个 Map 结构，而不是对象。**Map 结构的键名可以是各种值，所以不管分组函数返回什么值，都会直接作为组名（Map 结构的键名），不会强制转为字符串。这对于分组函数返回值是对象的情况，尤其有用。

**总之，按照字符串分组就使用`group()`，按照对象分组就使用`groupToMap()`。**

#### Array.prototype.sort() 的排序稳定性

ES2019明确规定，`Array.prototype.sort()`的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。



### 对象的扩展

#### 方法的name属性

函数的`name`属性，返回函数名。对象方法也是函数，因此也有`name`属性。

如果对象的方法使用了取值函数（`getter`）和存值函数（`setter`），则`name`属性不是在该方法上面，而是该方法的属性的描述对象的`get`和`set`属性上面，返回值是方法名前加上`get`和`set`。

有两种特殊情况：`bind`方法创造的函数，`name`属性返回`bound`加上原函数的名字；`Function`构造函数创造的函数，`name`属性返回`anonymous`。

#### 属性的可枚举性

`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。

```
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
```

描述对象的`enumerable`属性，称为“可枚举性”，如果该属性为`false`，就表示某些操作会忽略当前属性。

实际上，引入“可枚举”（`enumerable`）这个概念的最初目的，就是让某些属性可以规避掉`for...in`操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的`toString`方法，以及数组的`length`属性，就通过“可枚举性”，从而避免被`for...in`遍历到。

目前，有四个操作会忽略`enumerable`为`false`的属性。

- **`for...in`循环：只遍历对象自身的和继承的可枚举的属性。**
- **`Object.keys()`：返回对象自身的所有可枚举的属性的键名。**
- **`JSON.stringify()`：只串行化对象自身的可枚举的属性。**
- **`Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。**

操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用`for...in`循环，而用`Object.keys()`代替。

#### 属性的遍历

ES6 一共有 5 种方法可以遍历对象的属性。

**（1）for...in**

`for...in`循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

**（2）Object.keys(obj)**

`Object.keys`返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

**（3）Object.getOwnPropertyNames(obj)**

`Object.getOwnPropertyNames`返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

**（4）Object.getOwnPropertySymbols(obj)**

`Object.getOwnPropertySymbols`返回一个数组，包含对象自身的所有 Symbol 属性的键名。

**（5）Reflect.ownKeys(obj)**

`Reflect.ownKeys`返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

- 首先遍历所有数值键，按照数值升序排列。
- 其次遍历所有字符串键，按照加入时间升序排列。
- 最后遍历所有 Symbol 键，按照加入时间升序排列。

#### 对象的扩展运算符

ES2018 将扩展运算符（`...`）引入了对象。

##### 解构赋值

对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。

由于解构赋值要求等号右边是一个对象，所以如果等号右边是`undefined`或`null`，就会报错，因为它们无法转为对象。**解构赋值必须是最后一个参数，否则会报错。**

解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。

解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。

```
function baseFunction({ a, b }) {
  // ...
}
function wrapperFunction({ x, y, ...restConfig }) {
  // 使用 x 和 y 参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
}
```

##### 扩展运算符

对象的扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

```
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
```

由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。

#### Object.definedProperty

defineProperty为对象设置属性后，该属性的描述符writable、configurable以及enumberable默认为false。

- writable：表示能否修改属性的值，也就是说该属性是可写的还是只读的，默认为true（可写）
- enumerable：表示改属性是否可遍历，默认为true（可遍历）
- configurable：表示能否通过 delete 删除属性、能否修改属性的特性，或者将属性修改为访问器属性，默认为true（可配置）

### 对象的新增方法

#### Object.is()

ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。

**ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法,它用来比较两个值是否严格相等**

#### Object.assign()

`Object.assign()`方法用于对象的合并，将源对象（source）的所有**可枚举属性**，复制到目标对象（target）。

```
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```

注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

如果只有一个参数，`Object.assign()`会直接返回该参数。

注意：

- `Object.assign()`方法实行的是浅拷贝，而不是深拷贝。

- 对于嵌套的对象，一旦遇到同名属性，`Object.assign()`的处理方法是替换，而不是添加。

- `Object.assign()`可以用来处理数组，但是会把数组视为对象。

  ```javascript
  Object.assign([1, 2, 3], [4, 5])
  // [4, 5, 3]
  ```

#### Object.getOwnPropertyDescriptors()

#### \__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()

##### \__proto__属性

`__proto__`属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。

标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的`Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。

##### Object.setPrototypeOf()

`Object.setPrototypeOf`方法的作用与`__proto__`相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。

```
let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
```

如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。由于`undefined`和`null`无法转为对象，所以如果第一个参数是`undefined`或`null`，就会报错。

##### Object.getPrototypeOf()

该方法与`Object.setPrototypeOf`方法配套，用于读取一个对象的原型对象。

```
function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
```

#### Object.keys()，Object.values()，Object.entries()

ES5 引入了`Object.keys`方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。

ES2017 引入了跟`Object.keys`配套的`Object.values`和`Object.entries`，作为遍历一个对象的补充手段，供`for...of`循环使用。

```
let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```

`Object.entries()`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。

除了返回值不一样，该方法的行为与`Object.values`基本一致。

```
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
```

#### Object.fromEntries()

`Object.fromEntries()`方法是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。

```
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```

#### Object.hasOwn()

JavaScript 对象的属性分成两种：自身的属性和继承的属性。对象实例有一个`hasOwnProperty()`方法，可以判断某个属性是否为原生属性。ES2022 在`Object`对象上面新增了一个静态方法`Object.hasOwn()`，也可以判断是否为自身的属性。

`Object.hasOwn()`可以接受两个参数，第一个是所要判断的对象，第二个是属性名。

```
const foo = Object.create({ a: 123 });
foo.b = 456;

Object.hasOwn(foo, 'a') // false
Object.hasOwn(foo, 'b') // true
```

`Object.hasOwn()`的一个好处是，对于不继承`Object.prototype`的对象不会报错，而`hasOwnProperty()`是会报错的。对象`obj`没有原型，不继承任何属性，这导致调用`obj.hasOwnProperty()`会报错，但是`Object.hasOwn()`就能正确处理这种情况。

### 运算符的扩展

#### 指数运算符

ES2016 新增了一个指数运算符（`**`）。这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。

```
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

指数运算符可以与等号结合，形成一个新的赋值运算符（`**=`）。

#### 链判断运算符

 ES2020 引入了“链判断运算符”（optional chaining operator）`?.`，简化层层判断属性的上层对象是否存在的写法。

```
const firstName = message?.body?.user?.firstName || 'default';
```

注意

（1）短路机制

本质上，`?.`运算符相当于一种短路机制，只要不满足条件，就不再往下执行。

（2）括号的影响

如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。一般来说，使用`?.`运算符的场合，不应该使用圆括号。

（4）右侧不得为十进制数值

#### Null判断运算符

读取对象属性的时候，如果某个属性的值是`null`或`undefined`，有时候需要为它们指定默认值。常见做法是通过`||`运算符指定默认值。但是属性的值如果为空字符串或`false`或`0`，默认值也会生效。

为了避免这种情况，ES2020引入了一个新的 Null 判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

```
const headerText = response.settings.headerText ?? 'Hello, world!';
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
```

#### 逻辑赋值运算符

ES2021 引入了三个新的[逻辑赋值运算符](https://github.com/tc39/proposal-logical-assignment)（logical assignment operators），将逻辑运算符与赋值运算符进行结合。

```
// 或赋值运算符
x ||= y
// 等同于
x || (x = y)

// 与赋值运算符
x &&= y
// 等同于
x && (x = y)

// Null 赋值运算符
x ??= y
// 等同于
x ?? (x = y)
```

相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。它们的一个用途是，为变量或属性设置默认值。

### Symbol

**适合改用 Symbol 值的场所：这里等于哪个值并不重要，只要确保不会跟其他属性的值冲突即可**

#### 八种数据类型

```
USONB you are so niubility
// u undefined
// s string symbol
// o object
// n null number
// b boolean bigint
```

#### 特点

1. Symbol 的值是唯一的，用来解决命名冲突的问题
2. Symbol 值不能与其他数据进行运算
3. Symbol 定义的对象属性不能使用for…in循环遍历 ，但是可以使用Reflect.ownKeys 来获取对象的所有键名；

#### 创建

创建一个 symbol 的值需要使用 Symbol() 函数，而不能使用 new 命令。

```
let s1 = Symbol('sym');
```

由于生成的 symbol 是一个值而不是对象，所以不能为其添加属性。

Symbol() 函数可以接受一个字符串作为参数，表示对该值的描述，因此即使定义 symbol 使用相同的参数互相之间也不是相同的：

```
let s2 = Symbol('尚硅谷')
let s3 = Symbol('尚硅谷');
console.log(s2==s3); // false
```

**如果我们要重复使用一个 symbol 时，可以用到 Symbol.for() 方法**。Symbol.for() 方法接受一个字符串参数，会在全局中搜索有没有以该参数命名的 symbol 的值，如果查找到就返回这个值。如果没有查到则重新生成一个值，并将该值以参数名称注册到全局。

```
let s4 = Symbol.for('尚硅谷');
let s5 = Symbol.for('尚硅谷');
console.log(s4==s5); // true
```

Symbol.for() 和 Symbol() 方法都会生成新的 symbol 类型的值，不同的是 Symbol.for() 方法会查找命名参数是否在全局中注册过，如果注册过的就不会创建新的值，而是会直接返回，所以我们可以使用到相同的 symbol 值。但使用 Symbol() 方法每次都会创建一个新的值，且不会注册到全局。

**Symbol.keyFor() 方法表示获取一个 symbol 的值在全局中注册的命名参数 key**，只有使用 Symbol.for() 创建的值才会有注册的命名参数，使用 Symbol() 生成的值则没有：

```
let s4 = Symbol('sym');
let s5 = Symbol.for('sym');
Symbol.keyFor(s4); // undefined
Symbol.keyFor(s5); // sym
```

注意使用 Symbol.for() 注册的全局命名参数是真正意义上的全局，而不管是否运行在全局环境。

#### 用于属性名

由于每一个 Symbol 值都是不相等的，这意味着只要 Symbol 值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

**注意，Symbol 值作为对象属性名时，不能用点运算符，必须放在方括号之中。Symbol 用点运算符会导致属性名实际上是一个字符串，而不是一个 Symbol 值**

```
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
[mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

#### 属性名的遍历

Symbol 值作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。

但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

#### 内置的symbol值



### Set和Map

#### set

##### 介绍

`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。

向 Set 加入值的时候，不会发生类型转换，所以`5`和`"5"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），主要的区别是向 Set 加入值时认为`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。

##### Set 结构的实例的属性

- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
- `Set.prototype.size`：返回`Set`实例的成员总数。

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

- `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身。
- `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `Set.prototype.clear()`：清除所有成员，没有返回值。

##### 遍历操作

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
  由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys`方法和`values`方法的行为完全一致。
- `Set.prototype.entries()`：返回键值对的遍历器
  `entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。
- `Set.prototype.forEach()`：使用回调函数遍历每个成员
- 扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构

需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。

#### map

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

##### 实例的属性和操作方法

Map 结构的实例有以下属性和操作方法。

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

#### weak map

WeakMap是ES6中新增的一种集合类型，叫做'弱映射'。它和Map是兄弟关系，与Map的区别在于这个弱字，API还是Map那套API

##### 区别

- Map 对象的键可以是任何类型，但 WeakMap 对象中的键只能是对象引用；
- WeakMap 不能包含无引用的对象，否则会被自动清除出集合（垃圾回收机制）；
- WeakMap 对象是不可枚举的，无法获取集合的大小。

##### 弱引用

WeakMap的键名引用的对象是弱引用。首先我们需要知道什么是强引用什么是弱引用

> 弱引用定义：
>
> 在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。
>
> 相反，强引用比如 `var obj = new Object();`只有当我们手动设置 obj = null 的时候，才有可能回收 obj 所引用的对象。

总的来说，WeakMap保持了对键名所引用对象的弱引用，即垃圾回收机制不将该引用考虑在内。**只要所引用的对象的其它引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap里面的键名对象和所对应的键值对会自动消失，不需要手动删除引用。**

正因为WeakMap对键名引用的对象是弱引用关系 ，因此WeakMap内部成员是会取决于垃圾回收机制有没有执行，运行前后成员个数很可能是不一样的，而垃圾回收机制的执行又是不可预测的，因此不可遍历。

### Proxy

#### 概述

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

```
var proxy = new Proxy(target, handler);
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。其中，`new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。

为构造函数，`Proxy`接受两个参数。第一个参数是所要代理的目标对象，即如果没有`Proxy`的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。

注意，要使得`Proxy`起作用，必须针对`Proxy`实例进行操作，而不是针对目标对象进行操作。如果`handler`没有设置任何拦截，那就等同于直接通向原对象。Proxy 实例也可以作为其他对象的原型对象。

同一个拦截器函数，可以设置拦截多个操作。

#### Proxy 实例的方法

- **get(target, propKey, receiver)**：拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。
- **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。
- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。
- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。
- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。
- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。
- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。
- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。
- **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

#### Proxy.revocable()

`Proxy.revocable()`的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。

```
let target = {};
let handler = {};

let {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
```

#### this 问题

在 Proxy 代理的情况下，目标对象内部的`this`关键字会指向 Proxy 代理。

```
const target = {
  m: function () {
    console.log(this === proxy);
  }
};
const handler = {};

const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true
```

上面代码中，一旦`proxy`代理`target`，`target.m()`内部的`this`就是指向`proxy`，而不是`target`。所以，虽然`proxy`没有做任何拦截，`target.m()`和`proxy.m()`返回不一样的结果。

另外，Proxy 拦截函数内部的`this`，指向的是`handler`对象。

#### 实例：Web 服务的客户端

Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。

### Reflect

#### 概述

有了`Reflect`对象以后，很多操作会更易读。

（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。

（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。

（3） 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。

（4）`Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。

#### 静态方法

这些方法的作用，**大部分与`Object`对象的同名方法的作用都是相同的**，而且它与`Proxy`对象的方法是一一对应的。

- Reflect.apply(target, thisArg, args)
- Reflect.construct(target, args)
- Reflect.get(target, name, receiver)
- Reflect.set(target, name, value, receiver)
- Reflect.defineProperty(target, name, desc)
- Reflect.deleteProperty(target, name)
- Reflect.has(target, name)
- Reflect.ownKeys(target)
- Reflect.isExtensible(target)
- Reflect.preventExtensions(target)
- Reflect.getOwnPropertyDescriptor(target, name)
- Reflect.getPrototypeOf(target)
- Reflect.setPrototypeOf(target, prototype)

#### 实例：使用 Proxy 实现观察者模式

观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。

```
const queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn);
const observable = obj => new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer());
  return result;
}
```

上面代码中，先定义了一个`Set`集合，所有观察者函数都放进这个集合。然后，`observable`函数返回原始对象的代理，拦截赋值操作。拦截函数`set`之中，会自动执行所有观察者。

### Promise对象

本质是同步表异步，其实就是异步模式的语法糖，比如回调地狱就可以用then来解决

aysnc是promise的语法糖

#### Promise 的含义

所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

`Promise`对象有以下两个特点。

（1）**对象的状态不受外界影响**。`Promise`对象代表一个异步操作，**有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）**。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。

（2）**一旦状态改变，就不会再变，任何时候都可以得到这个结果**。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

#### 基本用法

ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

```
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
```

**Promise 新建后就会立即执行。**代码中，Promise 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。

> promiseall如果一共被catch出去了，其它的还是会执行。因为promise在实例化时，就执行了，.then()只是用来看它的结果。

```
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

一般来说，调用`resolve`或`reject`以后，Promise 的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。

#### Promise.prototype.then()

`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函数，它们都是可选的。

`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。

> **注意**
>
> 可以连续使用多次p.then()，比如p.then()、p.then()，是两个同一级的promise。它们都会按次序执行，并且都在p.then().then()前面，不存在覆盖的问题

#### Promise.prototype.catch()

`Promise.prototype.catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。

```
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```

上面代码中，`getJSON()`方法返回一个 Promise 对象，如果该对象状态变为`resolved`，则会调用`then()`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch()`方法指定的回调函数，处理这个错误。

另外，`then()`方法指定的回调函数，如果运行中抛出错误，也会被`catch()`方法捕获。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。

Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”，不会退出进程、终止脚本执行。一般总是建议，Promise 对象后面要跟`catch()`方法，这样可以处理 Promise 内部发生的错误。`catch()`方法返回的还是一个 Promise 对象，因此后面还可以接着调用`then()`方法。

#### Promise.prototype.finally()

`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。

#### Promise.all()

`Promise.all()`方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

```
const p = Promise.all([p1, p2, p3]);
```

`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。

（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。

（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。

#### Promise.race()

`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

```javascript
const p = Promise.race([p1, p2, p3]);
```



上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

#### Promise.allSettled()

ES2020 引入了`Promise.allSettled()`方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。

该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是`fulfilled`，不会变成`rejected`。状态变成`fulfilled`后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。

#### Promise.any()

ES2021 引入了`Promise.any()`方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。

只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。

#### Promise.resolve()

**将现有对象转为 Promise 对象**，`Promise.resolve()`方法就起到这个作用。

`Promise.resolve()`等价于下面的写法。

```javascript
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

**（1）参数是一个 Promise 实例**

如果参数是 Promise 实例，那么`Promise.resolve`将不做任何修改、原封不动地返回这个实例。

**（2）参数是一个`thenable`对象**

`thenable`对象指的是具有`then`方法的对象。`Promise.resolve()`方法会将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法。

```
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};
```

**（3）参数不是具有`then()`方法的对象，或根本就不是对象**

如果参数是一个原始值，或者是一个不具有`then()`方法的对象，则`Promise.resolve()`方法返回一个新的 Promise 对象，状态为`resolved`。

**（4）不带有任何参数**

`Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 Promise 对象。

#### Promise.reject()

`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。

#### 应用

##### 加载图片

我们可以将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化。

```javascript
const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

### Iterator 和 for...of 循环

#### Iterator（遍历器）的概念

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；**三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。**

其实就是不断调用`next`方法，返回数据结构的当前成员的信息。具体来说，就是返回一个包含`value`和`done`两个属性的对象。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。

由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。

#### 默认 Iterator 接口

ES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）

对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，`for...of`循环会自动遍历它们。对象（Object）没有默认部署 Iterator 接口，不过严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。

#### 调用 Iterator 接口的场合

有一些场合会默认调用 Iterator 接口（即`Symbol.iterator`方法），除了下文会介绍的`for...of`循环，还有几个别的场合。

**（1）解构赋值**

对数组和 Set 结构进行解构赋值时，会默认调用`Symbol.iterator`方法。

**（2）扩展运算符**

扩展运算符（...）也会调用默认的 Iterator 接口。这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。

**（3）yield\***

`yield*`后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。

```
let generator = function* () {
  yield 1;
  yield* [2,3,4];
  yield 5;
};

var iterator = generator();

iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
```

**（4）其他场合**

由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。

- for...of
- Array.from()
- Map(), Set(), WeakMap(), WeakSet()（比如`new Map([['a',1],['b',2]])`）
- Promise.all()
- Promise.race()

#### 字符串的 Iterator 接口
#### Iterator 接口与 Generator 函数
#### 遍历器对象的 return()，throw()

遍历器对象除了具有`next()`方法，还可以具有`return()`方法和`throw()`方法。如果你自己写遍历器对象生成函数，那么`next()`方法是必须部署的，`return()`方法和`throw()`方法是否部署是可选的。

`return()`方法的使用场合是，如果`for...of`循环提前退出（通常是因为出错，或者有`break`语句），就会调用`return()`方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署`return()`方法。

#### for...of 循环

##### array

一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有 iterator 接口，就可以用`for...of`循环遍历它的成员。也就是说，`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。

```
const arr = ['red', 'green', 'blue'];

for(let v of arr) {
  console.log(v); // red green blue
}

const obj = {};
obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);

for(let v of obj) {
  console.log(v); // red green blue
}
```



`for...of`循环可以代替数组实例的`forEach`方法。JavaScript 原有的`for...in`循环，只能获得对象的键名，不能直接获取键值。ES6 提供`for...of`循环，允许遍历获得键值。

**`for...in`循环读取键名，`for...of`循环读取键值。如果要通过`for...of`循环，获取数组的索引，可以借助数组实例的`entries`方法和`keys`方法**

`for...of`循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟`for...in`循环也不一样。

##### set map

值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。

##### 类似数组的对象

对于字符串来说，`for...of`循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。

并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用`Array.from`方法将其转为数组。



#### 与其他遍历语法的比较

以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是`for`循环。

```javascript
for (var index = 0; index < myArray.length; index++) {
  console.log(myArray[index]);
}
```

这种写法比较麻烦，因此数组提供内置的`forEach`方法。

```javascript
myArray.forEach(function (value) {
  console.log(value);
});
```

这种写法的问题在于，无法中途跳出`forEach`循环，`break`命令或`return`命令都不能奏效。

`for...in`循环可以遍历数组的键名。

```javascript
for (var index in myArray) {
  console.log(myArray[index]);
}
```

`for...in`循环有几个缺点。

- **数组的键名是数字，但是`for...in`循环是以字符串作为键名“0”、“1”、“2”等等。**
- **`for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。**
- 某些情况下，`for...in`循环会以任意顺序遍历键名。

总之，`for...in`循环主要是为遍历对象而设计的，不适用于遍历数组。



`for...of`循环相比上面几种做法，有一些显著的优点。

```javascript
for (let value of myArray) {
  console.log(value);
}
```

- 有着同`for...in`一样的简洁语法，但是没有`for...in`那些缺点。
- 不同于`forEach`方法，它可以与`break`、`continue`和`return`配合使用。
- 提供了遍历所有数据结构的统一操作接口。

下面是一个使用 break 语句，跳出`for...of`循环的例子。

```javascript
for (var n of fibonacci) {
  if (n > 1000)
    break;
  console.log(n);
}
```

上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用`break`语句跳出`for...of`循环。

### Generator 函数的语法

#### 简介

Generator 函数有多种理解角度。语法上，首先可以把它理解成，**Generator 函数是一个状态机，封装了多个内部状态。**

执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。**返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。**

形式上，Generator 函数是一个普通函数，但是有两个特征。

- **`function`关键字与函数名之间有一个星号；**
- **函数体内部使用`yield`表达式，定义不同的内部状态（`yield`在英语里的意思就是“产出”）。**



Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。**不同的是，调用 Generator 函数后，该函数并不执行**，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。必须调用遍历器对象的`next`方法，使得指针移向下一个状态。

换言之，Generator 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。

#### yield 方法

遍历器对象的`next`方法的运行逻辑如下。

（1）遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。

（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。

（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。

（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

需要注意的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。

**Generator 函数可以返回一系列的值，因为可以有任意多个`yield`。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。**

Generator 函数可以不用`yield`表达式，这时就变成了一个单纯的暂缓执行函数。

另外需要注意，`yield`表达式只能用在 Generator 函数里面，用在其他地方都会报错。

#### next 方法的参数

`yield`表达式本身没有返回值，或者说总是返回`undefined`。**`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。**

```javascript
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```

上面代码中，第二次运行`next`方法的时候不带参数，导致 y 的值等于`2 * undefined`（即`NaN`），除以 3 以后还是`NaN`，因此返回对象的`value`属性也等于`NaN`。第三次运行`Next`方法的时候不带参数，所以`z`等于`undefined`，返回对象的`value`属性等于`5 + NaN + undefined`，即`NaN`。

如果向`next`方法提供参数，返回结果就完全不一样了。上面代码第一次调用`b`的`next`方法时，返回`x+1`的值`6`；第二次调用`next`方法，将上一次`yield`表达式的值设为`12`，因此`y`等于`24`，返回`y / 3`的值`8`；第三次调用`next`方法，将上一次`yield`表达式的值设为`13`，因此`z`等于`13`，这时`x`等于`5`，`y`等于`24`，所以`return`语句的值等于`42`。

#### for...of 循环

`for...of`循环可以自动遍历 Generator 函数运行时生成的`Iterator`对象，且此时不再需要调用`next`方法。

原生的 JavaScript 对象没有遍历接口，无法使用`for...of`循环，通过 Generator 函数为它加上这个接口，就可以用了。

```javascript
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

上面代码中，对象`jane`原生不具备 Iterator 接口，无法用`for...of`遍历。这时，我们通过 Generator 函数`objectEntries`为它加上遍历器接口，就可以用`for...of`遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的`Symbol.iterator`属性上面。

```javascript
function* objectEntries() {
  let propKeys = Object.keys(this);

  for (let propKey of propKeys) {
    yield [propKey, this[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

jane[Symbol.iterator] = objectEntries;

for (let [key, value] of jane) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```



#### Generator.prototype.throw()

Generator 函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。

`throw`方法被捕获以后，会附带执行下一条`yield`表达式。也就是说，会附带执行一次`next`方法。

```javascript
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log('内部捕获', e);
  }
};

var i = g();
i.next();

try {
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b
```

上面代码中，遍历器对象`i`连续抛出两个错误。第一个错误被 Generator 函数体内的`catch`语句捕获。`i`第二次抛出错误，由于 Generator 函数内部的`catch`语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的`catch`语句捕获。

这种函数体内捕获错误的机制，大大方便了对错误的处理。多个`yield`表达式，可以只用一个`try...catch`代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次`catch`语句就可以了。

#### Generator.prototype.return()
#### next()、throw()、return() 的共同点

`next()`、`throw()`、`return()`这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换`yield`表达式。

- `next()`是将`yield`表达式替换成一个值。
- `throw()`是将`yield`表达式替换成一个`throw`语句。
- `return()`是将`yield`表达式替换成一个`return`语句。

```
const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;

gen.throw(new Error('出错了')); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));

gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
```



#### yield* 表达式

如果有多个 Generator 函数嵌套，写起来就非常麻烦。

ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。从语法角度看，如果`yield`表达式后面跟的是一个遍历器对象，需要在`yield`表达式后面加上星号，表明它返回的是一个遍历器对象。

`yield*`后面的 Generator 函数（没有`return`语句时），不过是`for...of`的一种简写形式，完全可以用后者替代前者。反之，在有`return`语句时，则需要用`var value = yield* iterator`的形式获取`return`语句的值。

如果`yield*`后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。

#### 作为对象属性的 Generator 函数

如果一个对象的属性是 Generator 函数，可以简写成下面的形式。

```javascript
let obj = {
  * myGeneratorMethod() {
    ···
  }
};
```

上面代码中，`myGeneratorMethod`属性前面有一个星号，表示这个属性是一个 Generator 函数。

#### Generator 函数的this

Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的`prototype`对象上的方法。

```javascript
function* g() {}

g.prototype.hello = function () {
  return 'hi!';
};

let obj = g();

obj instanceof g // true
obj.hello() // 'hi!'
```

上面代码表明，**Generator 函数`g`返回的遍历器`obj`，是`g`的实例，**而且继承了`g.prototype`。但是，如果把`g`当作普通的构造函数，并不会生效，因为`g`返回的总是遍历器对象，而不是`this`对象。

```javascript
function* g() {
  this.a = 11;
}

let obj = g();
obj.next();
obj.a // undefined
```

上面代码中，Generator 函数`g`在`this`对象上面添加了一个属性`a`，但是`obj`对象拿不到这个属性。

#### 含义

(1) Generator 实现状态机

(2) Generator 与协程

协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。

多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。**这种可以并行执行、交换执行权的线程（或函数），就称为协程**。

协程是以多占用内存为代价，实现多任务的并行。由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。

如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用`yield`表达式交换控制权。

Generator 函数执行产生的上下文环境，一旦遇到`yield`命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行`next`命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。与js的“后进先出”的上下文环境数据结构不同。

#### 应用

##### 异步操作的同步化表达

Generator 函数的暂停执行的效果，意味着可以把异步操作写在`yield`表达式里面，等到调用`next`方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在`yield`表达式下面，反正要等到调用`next`方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。

Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。

##### 控制流管理

##### 部署 Iterator 接口

##### 提供类似数组的接口



### Generator 函数的异步应用

JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。

#### 传统方法

ES6 诞生以前，异步编程的方法，大概有下面四种。

- 回调函数
- 事件监听
- 发布/订阅
- Promise 对象

Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。

#### 基本概念

**异步**

所谓"异步"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

##### 回调函数

JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字`callback`，直译过来就是"重新调用"。

##### Promise

回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。

代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为"回调函数地狱"（callback hell）。

Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。

可以看到，Promise 的写法只是回调函数的改进，使用`then`方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。

Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆`then`，原来的语义变得很不清楚。

#### Generator 函数

**比promise更好的写法，使用协程**

整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用`yield`语句注明。Generator 函数的执行方法如下。

```javascript
function* gen(x) {
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
```

上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）`g`。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。

**Generator 函数可以暂停执行和恢复执行**，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。`next`返回值的 value 属性，是 Generator 函数向外输出数据；`next`方法还可以接受参数，向 Generator 函数体内输入数据。

Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。

#### Thunk 函数

Thunk 函数是自动执行 Generator 函数的一种方法。

编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。它是“传名调用”的一种实现策略，用来替换某个表达式。

JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，**Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。**任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。

```
// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);

// Thunk版本的readFile（单参数版本）
var Thunk = function (fileName) {
  return function (callback) {
    return fs.readFile(fileName, callback);
  };
};
```

`yield`命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。

Thunk 函数真正的威力，在于可以自动执行 Generator 函数。

```javascript
function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
  }

  next();
}

function* g() {
  // ...
}

run(g);
```

上面代码的`run`函数，就是一个 Generator 函数的自动执行器。内部的`next`函数就是 Thunk 的回调函数。`next`函数先将指针移到 Generator 函数的下一步（`gen.next`方法），然后判断 Generator 函数是否结束（`result.done`属性），如果没结束，就将`next`函数再传入 Thunk 函数（`result.value`属性），否则就直接退出。

有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入`run`函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在`yield`命令后面的必须是 Thunk 函数。

```javascript
var g = function* (){
  var f1 = yield readFileThunk('fileA');
  var f2 = yield readFileThunk('fileB');
  // ...
  var fn = yield readFileThunk('fileN');
};

run(g);
```

上面代码中，函数`g`封装了`n`个异步的读取文件操作，只要执行`run`函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。

#### co 模块

##### 介绍

co 模块可以让你不用编写 Generator 函数的执行器。

```javascript
var co = require('co');
co(gen);
```

上面代码中，Generator 函数只要传入`co`函数，就会自动执行。

`co`函数返回一个`Promise`对象，因此可以用`then`方法添加回调函数。

##### 原理

Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。

（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。

（2）Promise 对象。将异步操作包装成 Promise 对象，用`then`方法交回执行权。

co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。

##### 处理并发的异步操作

co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。

这时，要把并发的操作都放在数组或对象里面，跟在`yield`语句后面。



### async 函数

#### 含义

**async 函数是什么？一句话，它就是 Generator 函数的语法糖。**

一比较就会发现，**`async`函数就是将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`，仅此而已。**

`async`函数对 Generator 函数的改进，体现在以下四点。

（1）内置执行器。

Generator 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。

（2）更好的语义。

`async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。

（3）更广的适用性。

`co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象，**而`async`函数的`await`命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。**

（4）返回值是 Promise。

**`async`函数的返回值是 Promise 对象**，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用`then`方法指定下一步的操作。

进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。

#### 基本用法

**`async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。**

#### 语法

`async`函数返回一个 Promise 对象。`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。

`async`函数返回的 Promise 对象，必须等到内部所有`await`命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到`return`语句或者抛出错误。也就是说，只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。

正常情况下，`await`命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。

**注意**

第一点，前面已经说过，`await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。

第二点，多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。

```javascript
let foo = await getFoo();
let bar = await getBar();
上面代码中，`getFoo`和`getBar`是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有`getFoo`完成以后，才会执行`getBar`，完全可以让它们同时触发。
// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
```

第三点，`await`命令只能用在`async`函数之中，如果用在普通函数，就会报错。

第四点，async 函数可以保留运行堆栈。上下文环境都保存着

#### async 函数的实现原理

**async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。**

#### 与其他异步处理方法的比较

我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。

假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。

**首先是 Promise 的写法。**

```javascript
function chainAnimationsPromise(elem, animations) {

  // 变量ret用来保存上一个动画的返回值
  let ret = null;

  // 新建一个空的Promise
  let p = Promise.resolve();

  // 使用then方法，添加所有动画
  for(let anim of animations) {
    p = p.then(function(val) {
      ret = val;
      return anim(elem);
    });
  }

  // 返回一个部署了错误捕捉机制的Promise
  return p.catch(function(e) {
    /* 忽略错误，继续执行 */
  }).then(function() {
    return ret;
  });

}
```

虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（`then`、`catch`等等），操作本身的语义反而不容易看出来。

接着是 Generator 函数的写法。

```javascript
function chainAnimationsGenerator(elem, animations) {

  return spawn(function*() {
    let ret = null;
    try {
      for(let anim of animations) {
        ret = yield anim(elem);
      }
    } catch(e) {
      /* 忽略错误，继续执行 */
    }
    return ret;
  });

}
```

上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在`spawn`函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的`spawn`函数就是自动执行器，它返回一个 Promise 对象，而且必须保证`yield`语句后面的表达式，必须返回一个 Promise。

最后是 async 函数的写法。

```javascript
async function chainAnimationsAsync(elem, animations) {
  let ret = null;
  try {
    for(let anim of animations) {
      ret = await anim(elem);
    }
  } catch(e) {
    /* 忽略错误，继续执行 */
  }
  return ret;
}
```

可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。

#### 实例：按顺序完成异步操作
#### 顶层 await

从 ES2022 开始，允许在模块的顶层独立使用`await`命令，它的主要目的是使用`await`解决模块异步加载的问题。顶层的`await`命令保证只有异步操作完成，模块才会输出值。

过去，异步操作执行速不同，如果异步操作没执行完，加载进来的值会不同，返回`undefined`。顶层的`await`命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。

代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。这时，模块的加载会等待依赖模块的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的`output`，不会因为加载时机的不同，而得到不一样的值。

下面是顶层`await`的一些使用场景。

```javascript
// import() 方法加载
const strings = await import(`/i18n/${navigator.language}`);

// 数据库操作
const connection = await dbConnector();

// 依赖回滚
let jQuery;
try {
  jQuery = await import('https://cdn-a.com/jQuery');
} catch {
  jQuery = await import('https://cdn-b.com/jQuery');
}
```

注意，如果加载多个包含顶层`await`命令的模块，加载命令是同步执行的。

```javascript
// x.js
console.log("X1");
await new Promise(r => setTimeout(r, 1000));
console.log("X2");

// y.js
console.log("Y");

// z.js
import "./x.js";
import "./y.js";
console.log("Z");
```

上面代码有三个模块，最后的`z.js`加载`x.js`和`y.js`，打印结果是`X1`、`Y`、`X2`、`Z`。这说明，`z.js`并没有等待`x.js`加载完成，再去加载`y.js`。

顶层的`await`命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。

### Class 的基本语法
#### 类的由来

ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。

基本上，ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

例如：

```
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```

**ES6 的类，完全可以看作构造函数的另一种写法。**类的数据类型就是函数，类本身就指向构造函数。

构造函数的`prototype`属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。

类的内部所有定义的方法，都是不可枚举的（non-enumerable）

> 所谓的可枚举就是可遍历的意思，也就是说对象的属性是否能够**通过遍历得到，即通过for...in循环遍历到**。不是”可迭代“**（Iterable）**

#### constructor() 方法

`constructor()`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor()`方法，如果没有显式定义，一个空的`constructor()`方法会被默认添加。

```
class Point {
}

// 等同于
class Point {
  constructor() {}
}
```

`constructor()`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。

**类必须使用`new`调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。**



#### 类的实例

类的属性和方法，除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。

**可以通过实例的`__proto__`属性为“类”添加方法。**

> `__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 `Object.getPrototypeOf()` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。

使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。



#### 实例属性的新写法

[ES2022](https://github.com/tc39/proposal-class-fields) 为类的实例属性，又规定了一种新写法。**实例属性现在除了可以定义在`constructor()`方法里面的`this`上面，也可以定义在类内部的最顶层**。

```
class IncreasingCounter {
  _count = 0;
  get value() {
    console.log('Getting the current value!');
    return this._count;
  }
  increment() {
    this._count++;
  }
}
```

这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。

#### 取值函数（getter）和存值函数（setter）

在“类”的内部可以使用`get`和`set`关键字，**对某个属性设置存值函数和取值函数，拦截该属性的存取行为**。

存值函数和取值函数是设置在属性的 Descriptor 对象上的。

如果这个类某个属性只设置了get方法，没有设置set方法，那么默认这个属性是只读的，那就不能在constructor里再设置 this.name = val。

#### 属性表达式

类的属性名，可以采用表达式。

```javascript
let methodName = 'getArea';

class Square {
  constructor(length) {
    // ...
  }

  [methodName]() {
    // ...
  }
}
```

上面代码中，`Square`类的方法名`getArea`，是从表达式得到的。

#### Class 表达式

与函数一样，类也可以使用表达式的形式定义。

```
let person = new class {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}('张三');

person.sayName(); // "张三"
```



#### 静态方法

类相当于实例的原型，所有在类中定义的方法，都会被实例继承。**如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。**

```
lass Foo {
  static classMethod() {
    return 'hello';
  }
}

Foo.classMethod() // 'hello'

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
```

父类的静态方法，可以被子类继承。

注意，如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例。



#### 私有方法和私有属性

私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装

[ES2022](https://github.com/tc39/proposal-class-fields)正式**为`class`添加了私有属性，方法是在属性名之前使用`#`表示。**

```javascript
class IncreasingCounter {
  #count = 0;
  get value() {
    console.log('Getting the current value!');
    return this.#count;
  }
  increment() {
    this.#count++;
  }
}
```

上面代码中，`#count`就是私有属性，只能在类的内部使用（`this.#count`）。如果在类的外部使用，就会报错。

在类的外部，读取或写入私有属性`#count`，都会报错。另外，不管在类的内部或外部，读取一个不存在的私有属性，也都会报错。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回`undefined`。

这种写法不仅可以写私有属性，还可以用来写私有方法。

私有属性也可以设置 getter 和 setter 方法。

##### in

[ES2022](https://github.com/tc39/proposal-private-fields-in-in) 改进了`in`运算符，使它也可以用来判断私有属性。

```javascript
class C {
  #brand;

  static isC(obj) {
    if (#brand in obj) {
      // 私有属性 #brand 存在
      return true;
    } else {
      // 私有属性 #foo 不存在
      return false;
    }
  }
}
```

上面示例中，`in`运算符判断某个对象是否有私有属性`#foo`。它不会报错，而是返回一个布尔值。

注意，判断私有属性时，`in`只能用在类的内部。

子类从父类继承的私有属性，也可以使用`in`运算符来判断。

#### 静态块

ES2022 引入了[静态块](https://github.com/tc39/proposal-class-static-block)（static block），允许在类的内部设置一个代码块，在类生成时运行且只运行一次，主要作用是对静态属性进行初始化。以后，新建类的实例时，这个块就不运行了。

```javascript
class C {
  static x = ...;
  static y;
  static z;

  static {
    try {
      const obj = doSomethingWith(this.x);
      this.y = obj.y;
      this.z = obj.z;
    }
    catch {
      this.y = ...;
      this.z = ...;
    }
  }
}
```

上面代码中，类的内部有一个 static 代码块，这就是静态块。它的好处是将静态属性`y`和`z`的初始化逻辑，写入了类的内部，而且只运行一次。

每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性。另外，静态块的内部不能有`return`语句。

静态块内部可以使用类名或`this`，指代当前类。

除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。

#### 类的注意点

类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。

类不存在变量提升,这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。



### Class 的继承

#### 简介

Class 可以通过`extends`关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。

**ES6 规定，子类必须在`constructor()`方法中调用`super()`，否则就会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用`super()`方法，子类就得不到自己的`this`对象。**

ES6 的继承机制，是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用`super()`方法，因为这一步会生成一个继承父类的`this`对象，没有这一步就无法继承父类。这意味着新建子类实例时，父类的构造函数必定会先运行一次。

另一个需要注意的地方是，在子类的构造函数中，只有调用`super()`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有`super()`方法才能让子类实例继承父类。

#### 私有属性和私有方法的继承

父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。

子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。

#### 静态属性和静态方法的继承

父类的静态属性和静态方法，也会被子类继承。

注意，静态属性是通过软拷贝实现继承的。要注意如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。

#### Object.getPrototypeOf()

`Object.getPrototypeOf()`方法可以用来从子类上获取父类。

```javascript
class Point { /*...*/ }
class ColorPoint extends Point { /*...*/ }
Object.getPrototypeOf(ColorPoint) === Point
// true
```

因此，可以使用这个方法判断，一个类是否继承了另一个类。

#### super 关键字

`super`这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。

第一种情况，`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super()`函数。**调用`super()`的作用是形成子类的`this`对象，把父类的实例属性和方法放到这个`this`对象上面。子类在调用`super()`之前，是没有`this`对象的，任何对`this`的操作都要放在`super()`的后面。**

作为函数时，`super()`只能用在子类的构造函数之中，用在其他地方就会报错。

第二种情况，`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

```javascript
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();
```

上面代码中，子类`B`当中的`super.p()`，就是将`super`当作一个对象使用。这时，`super`在普通方法之中，指向`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。

这里需要注意，由于`super`指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。

ES6 规定，在子类普通方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的子类实例。

#### 类的 prototype 属性和\__proto__属性

大多数浏览器的 ES5 实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的`prototype`属性。Class 作为构造函数的语法糖，同时有`prototype`属性和`__proto__`属性，因此同时存在两条继承链。

（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。

（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。

##### 实例的 __proto__ 属性

子类实例的`__proto__`属性的`__proto__`属性，指向父类实例的`__proto__`属性。也就是说，子类的原型的原型，是父类的原型。

通过子类实例的`__proto__.__proto__`属性，可以修改父类实例的行为。

#### 原生构造函数的继承

原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。

- Boolean()
- Number()
- String()
- Array()
- Date()
- Function()
- RegExp()
- Error()
- Object()

ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。下面是一个继承`Array`的例子。

```javascript
class MyArray extends Array {
  constructor(...args) {
    super(...args);
  }
}

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
```

上面代码定义了一个`MyArray`类，继承了`Array`构造函数，因此就可以从`MyArray`生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如`Array`、`String`等）的子类，这是 ES5 无法做到的。

#### Mixin 模式的实现

Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。

```javascript
const a = {
  a: 'a'
};
const b = {
  b: 'b'
};
const c = {...a, ...b}; // {a: 'a', b: 'b'}
```

上面代码中，`c`对象是`a`对象和`b`对象的合成，具有两者的接口。

### Module 的语法

#### 概述

ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

```javascript
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上面代码的实质是从`fs`模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载

除了静态加载带来的各种好处，ES6 模块还有以下好处。

- 不再需要`UMD`模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
- 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者`navigator`对象的属性。
- 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。

#### export 命令

模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。

**在`export`命令后面，使用大括号指定所要输出的一组变量。它与直接放置在`var`语句前是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。**

`export`命令除了输出变量，还可以输出函数或类（class）。

最后，`export`命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。

#### import 命令

使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块。

```javascript
// main.js
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}
```

上面代码的`import`命令，用于加载`profile.js`文件，并从中输入变量。`import`命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同。

`import`命令具有提升效果，会提升到整个模块的头部，首先执行。

#### 模块的整体加载

整体加载的写法如下。

注意，模块整体加载所在的那个对象（上例是`circle`），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。

```javascript
import * as circle from './circle';

// 下面两行都是不允许的
circle.foo = 'hello';
circle.area = function () {};
```

#### export default 命令

从前面的例子可以看出，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。

为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。

```javascript
// export-default.js
export default function () {
  console.log('foo');
}
```

上面代码是一个模块文件`export-default.js`，它的默认输出是一个函数。

其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。

```javascript
// import-default.js
import customName from './export-default';
customName(); // 'foo'
```

上面代码的`import`命令，可以用任意名称指向`export-default.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时`import`命令后面，不使用大括号。

显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应`export default`命令。

#### export 与 import 的复合写法

如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起。

```javascript
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };
```

上面代码中，`export`和`import`语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，`foo`和`bar`实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用`foo`和`bar`。

#### 模块的继承

模块之间也可以继承。

假设有一个`circleplus`模块，继承了`circle`模块。

```javascript
// circleplus.js

export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}
```

上面代码中的`export *`，表示再输出`circle`模块的所有属性和方法。注意，`export *`命令会忽略`circle`模块的`default`方法。然后，上面代码又输出了自定义的`e`变量和默认方法。

#### 跨模块常量

`const`声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。

```javascript
// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import {A, B} from './constants';
console.log(A); // 1
console.log(B); // 3
```

如果要使用的常量非常多，可以建一个专门的`constants`目录，将各种常量写在不同的文件里面，保存在该目录下。

```javascript
// constants/db.js
export const db = {
  url: 'http://my.couchdbserver.local:5984',
  admin_username: 'admin',
  admin_password: 'admin password'
};

// constants/user.js
export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];
```

然后，将这些文件输出的常量，合并在`index.js`里面。

```javascript
// constants/index.js
export {db} from './db';
export {users} from './users';
```

使用的时候，直接加载`index.js`就可以了。

```javascript
// script.js
import {db, users} from './constants/index';
```

#### import.meta

开发者使用一个模块时，有时需要知道模板本身的一些信息（比如模块的路径）。[ES2020](https://github.com/tc39/proposal-import-meta) 为 import 命令添加了一个元属性`import.meta`，返回当前模块的元信息。

`import.meta`只能在模块内部使用，如果在模块外部使用会报错。

这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，`import.meta`至少会有下面两个属性。

**（1）import.meta.url**

`import.meta.url`返回当前模块的 URL 路径。举例来说，当前模块主文件的路径是`https://foo.com/main.js`，`import.meta.url`就返回这个路径。如果模块里面还有一个数据文件`data.txt`，那么就可以用下面的代码，获取这个数据文件的路径。

```javascript
new URL('data.txt', import.meta.url)
```

注意，Node.js 环境中，`import.meta.url`返回的总是本地路径，即`file:URL`协议的字符串，比如`file:///home/user/foo.js`。

**（2）import.meta.scriptElement**

`import.meta.scriptElement`是浏览器特有的元属性，返回加载模块的那个`<script>`元素，相当于`document.currentScript`属性。

```javascript
// HTML 代码为
// <script type="module" src="my-module.js" data-foo="abc"></script>

// my-module.js 内部执行下面的代码
import.meta.scriptElement.dataset.foo
// "abc"
```



### Module 的加载实现
#### 浏览器加载

HTML 网页中，浏览器通过`<script>`标签加载 JavaScript 脚本。默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到`<script>`标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。

`<script>`标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。

##### 模块

浏览器加载 ES6 模块，也使用`<script>`标签，但是要加入`type="module"`属性。

```html
<script type="module" src="./foo.js"></script>
```

上面代码在网页中插入一个模块`foo.js`，由于`type`属性设为`module`，所以浏览器知道这是一个 ES6 模块。

**浏览器对于带有`type="module"`的`<script>`，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本。等同于打开了`<script>`标签的`defer`属性。**

对于外部的模块脚本，有几点需要注意。

- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
- 模块脚本自动采用严格模式，不管有没有声明`use strict`。
- 模块之中，可以使用`import`命令加载其他模块（`.js`后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用`export`命令输出对外接口。
- 模块之中，顶层的`this`关键字返回`undefined`，而不是指向`window`。也就是说，在模块顶层使用`this`关键字，是无意义的。
- 同一个模块如果加载多次，将只执行一次。

下面是一个示例模块。

```javascript
import utils from 'https://example.com/js/utils.js';

const x = 1;

console.log(x === window.x); //false
console.log(this === undefined); // true
```

利用顶层的`this`等于`undefined`这个语法点，可以侦测当前代码是否在 ES6 模块之中。

#### ES6 模块与 CommonJS 模块的差异

JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。

#### Node.js 的模块加载方法

##### 简介

**JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。**

**CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用`require()`和`module.exports`，ES6 模块使用`import`和`export`。**

它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。

Node.js 要求 ES6 模块采用`.mjs`后缀文件名。也就是说，只要脚本文件里面使用`import`或者`export`命令，那么就必须采用`.mjs`后缀名。Node.js 遇到`.mjs`文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定`"use strict"`。

如果不希望将后缀名改成`.mjs`，可以在项目的`package.json`文件中，指定`type`字段为`module`。一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。

注意，ES6 模块与 CommonJS 模块尽量不要混用。`require`命令不能加载`.mjs`文件，会报错，只有`import`命令才可以加载`.mjs`文件。反过来，`.mjs`文件里面也不能使用`require`命令，必须使用`import`。

##### package.json 的 main 字段

`package.json`文件有两个字段可以指定模块的入口文件：`main`和`exports`。比较简单的模块，可以只使用`main`字段，指定模块加载的入口文件。

```javascript
// ./node_modules/es-module-package/package.json
{
  "type": "module",
  "main": "./src/index.js"
}
```

上面代码指定项目的入口脚本为`./src/index.js`，它的格式为 ES6 模块。如果没有`type`字段，`index.js`就会被解释为 CommonJS 模块。

然后，`import`命令就可以加载这个模块。

```javascript
// ./my-app.mjs

import { something } from 'es-module-package';
// 实际加载的是 ./node_modules/es-module-package/src/index.js
```

上面代码中，运行该脚本以后，Node.js 就会到`./node_modules`目录下面，寻找`es-module-package`模块，然后根据该模块`package.json`的`main`字段去执行入口文件。

##### package.json 的 exports 字段

`exports`字段的优先级高于`main`字段。它有多种用法。

**（1）子目录别名**

`package.json`文件的`exports`字段可以指定脚本或子目录的别名。

```javascript
// ./node_modules/es-module-package/package.json
{
  "exports": {
    "./submodule": "./src/submodule.js"
  }
}
```

上面的代码指定`src/submodule.js`别名为`submodule`，然后就可以从别名加载这个文件。

**（2）main 的别名**

`exports`字段的别名如果是`.`，就代表模块的主入口，优先级高于`main`字段，并且可以直接简写成`exports`字段的值。

```javascript
{
  "exports": {
    ".": "./main.js"
  }
}

// 等同于
{
  "exports": "./main.js"
}
```

**（3）条件加载**

利用`.`这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。

```javascript
{
  "exports": {
    "require": "./main.cjs",
    "default": "./main.js"
  }
}
```

注意，如果同时还有其他别名，就不能采用简写，否则会报错。

##### Node.js 的内置模块

Node.js 的内置模块可以整体加载，也可以加载指定的输出项。

```javascript
// 整体加载
import EventEmitter from 'events';
const e = new EventEmitter();

// 加载指定的输出项
import { readFile } from 'fs';
readFile('./foo.txt', (err, source) => {
  if (err) {
    console.error(err);
  } else {
    console.log(source);
  }
});
```

##### 加载路径

ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。`import`命令和`package.json`文件的`main`字段如果省略脚本的后缀名，会报错。

目前，Node.js 的`import`命令只支持加载本地模块（`file:`协议）和`data:`协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以`/`或`//`开头的路径）。

#### 循环加载

“循环加载”（circular dependency）指的是，`a`脚本的执行依赖`b`脚本，而`b`脚本的执行又依赖`a`脚本。依赖关系复杂的大项目，很容易出现`a`依赖`b`，`b`依赖`c`，`c`又依赖`a`这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。

ES6 模块是动态引用，如果使用`import`从一个模块加载变量（即`import foo from 'foo'`），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

解决这个问题的方法，就是让其提升，可以通过将写成函数来解决，这是因为函数具有提升作用，在执行`import {bar} from './b'`时，函数`foo`就已经有定义了，所以`b.mjs`加载的时候不会报错。这也意味着，如果把函数`foo`改写成函数表达式，也会报错，因为函数表达式不提升。

```
// a.mjs
import {bar} from './b';
console.log('a.mjs');
console.log(bar());
function foo() { return 'foo' }
export {foo};

// b.mjs
import {foo} from './a';
console.log('b.mjs');
console.log(foo());
function bar() { return 'bar' }
export {bar};
```



### 编程风格

#### 严格模式

目的：

- 消除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为；(会将JavaScript陷阱直接变成明显错误，静默失败)

- 消除代码运行的一些不安全之处，保证代码运行的安全；（修正了一些引擎难以优化的错误）

- 提高编译器的效率，增加运行速度；

- 为未来新版本的JavaScript做好铺垫。

ES6 的模块自动采用严格模式，不管你有没有在模块头部加上`"use strict";`。

作用：

- 变量的声明---严格模式下，如果变量没有声明就赋值会报错；
- 禁止使用with语句
- eval语句本身构成一个作用域，不再能够生成全局变量了，他所生成的变量只能用于eval内部。
- 函数不能有重名的参数（正常模式下可以通过arguments可以读取，严格模式报错）
- 禁止八进制表示法

#### 块级作用域

**（1）let 取代 var**

`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。

**（2）全局常量和线程安全**

在`let`和`const`之间，建议优先使用`const`，尤其是在全局环境，不应该设置变量，只应设置常量。

- 一是`const`可以提醒阅读程序的人，这个变量不应该改变；
- 另一个是`const`比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；
- 最后一个原因是 JavaScript 编译器会对`const`进行优化，所以多使用`const`，有利于提高程序的运行效率，也就是说`let`和`const`的本质区别，其实是编译器内部的处理不同。

#### 字符串

静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。

```javascript
// bad
const a = "foobar";
const b = 'foo' + a + 'bar';

// acceptable
const c = `foobar`;

// good
const a = 'foobar';
const b = `foo${a}bar`;
```

#### 解构赋值

使用数组成员对变量赋值时，优先使用解构赋值。

函数的参数如果是对象的成员，优先使用解构赋值。

如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。

#### 对象

单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。

对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign`方法。

#### 数组

使用扩展运算符（...）拷贝数组。

使用 Array.from 方法，将类似数组的对象转为数组。

#### 函数

立即执行函数可以写成箭头函数的形式。

那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。

```javascript
// bad
[1, 2, 3].map(function (x) {
  return x * x;
});

// good
[1, 2, 3].map((x) => {
  return x * x;
});

// best
[1, 2, 3].map(x => x * x);
```

**箭头函数取代`Function.prototype.bind`，不应再用 self/_this/that 绑定 this。**

不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。

使用默认值语法设置函数参数的默认值。

#### Map 结构

只有模拟现实世界的实体对象时，才使用 Object。如果只是需要`key: value`的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。

#### Class

**总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。**

使用`extends`实现继承，因为这样更简单，不会有破坏`instanceof`运算的危险。

#### 模块

ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。


